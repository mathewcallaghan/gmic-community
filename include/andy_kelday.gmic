#@gmic

# Description: G'MIC custom command file
# Defines a set of image filters for use with the G'MIC program/plugin
#
# Author: Andy Kelday
# Date: 31st August 2016
# Contact: garagecoder@gmail.com
#
#  Licenses        : This file is 'dual-licensed', you have to choose one
#                    of the two licenses below to apply.
#
#                    CeCILL-C
#                    The CeCILL-C license is close to the GNU LGPL.
#                    ( http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html )
#
#                or  CeCILL v2.1
#                    The CeCILL license is compatible with the GNU GPL.
#                    ( http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html )
#
#  This software is governed either by the CeCILL or the CeCILL-C license
#  under French law and abiding by the rules of distribution of free software.
#  You can  use, modify and or redistribute the software under the terms of
#  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
#  at the following URL: "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
#

#@gui _<b>Artistic</b>

#@gui Aurora : gcd_aurora, gcd_aurora(1)
#@gui : note = note("<i>Simple aurora effect filter</i>"), sep = separator()
#@gui : Vertical Amount = float(6,0,50)
#@gui : Horizontal Amount = float(1,0,50)
#@gui : Blend Mode = choice(0,"None","Average")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_aurora : -skip ${1=6},${2=1},${3=0}
  -repeat $! -l[$>]
    -to_rgb --deriche $1%,2,y -deriche[-1] $2%,0,x
    -c[-1] 0,255 -n[-1] 0,255
    -if $3 -blend average -else -k[-1] -endif
  -endl -done

#@gui _<b>Black &amp; White</b>

#@gui Desaturate Norm : fx_gcd_norm_eq, fx_gcd_norm_eq_preview(0)
#@gui : note = note("<i>Desaturate sRGB using equalized norm</i>"), sep = separator()
#@gui : Red = float(0.5,0,1)
#@gui : Blue = float(0.5,0,1)
#@gui : Exp = float(2,1,3)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/12/27</i>.</small>")
fx_gcd_norm_eq : -skip ${1=0.5},${2=0.5},${3=2}
  -repeat $! -l[$>]
    -split_opacity
    -l[0]
      -to_rgb -srgb2rgb -gcd_gamma $3
      -sh 0 -sh.. 2 -*.. $1 -*. $2 -k[0]
      -norm -/ {sqrt(1+$1^2+$2^2)}
      -gcd_gamma {1/$3} -rgb2srgb
    -endl -a c
  -endl -done

fx_gcd_norm_eq_preview :
  -gui_split_preview "-fx_gcd_norm_eq ${1--2}",$-1

#@gui Multi-Layer Etch : fx_gcd_layeretch, fx_gcd_layeretch(2)
#@gui : note = note("<u>Etch with selectable number of layers</u>")
#@gui : note = note("<b>Warning: With high number of layers this can be VERY slow!</b>")
#@gui : sep = separator()
#@gui : Total Layers = int(11,2,16)
#@gui : White Layers = int(4,1,15)
#@gui : Etch Tones = int(12,2,32)
#@gui : Tone Blur = float(0.12,0,1)
#@gui : Noise Level = int(100,5,200)
#@gui : Dark Length = float(8.5,0,20)
#@gui : Bright Length = float(5,0,20)
#@gui : Start Angle = int(0,0,180)
#@gui : Random Angle = int(0,0,45)
#@gui : Max Curve = int(3,0,20)
#@gui : Gamma = float(1,0.01,2)
#@gui : Spread Angles = bool(1)
#@gui : Fast Resize = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2012/12/21</i>.</small>")
fx_gcd_layeretch : -skip ${1=16},${2=7},${3=14},${4=0.12},${5=100},${6=5},${7=4.65},${8=0},${9=0},${10=3},${11=1},${12=1},${13=0}
  -repeat $! -l[$>]
    w={w} h={h} sc=800 ml=$1 wl={min($2,$ml-1)}
    nwl={$ml-$wl} nwl={$nwl+($nwl%2==0)}
    -if {!$13} nw=$w nh=$h
    -elif {w>h} nw={min($sc,w)} nh={$nw/w*h}
    -else nh={min($sc,h)} nw={$nh/h*w} -endif
    -to_rgb[0] [0] -r[1] $nw,$nh
    -norm[1] -n[1] 0,255 --tones[1] $ml
    -repeat {$ml-1} -+[{-$<-1}] [{-$<-2}] -done
    -b[-$ml--1] $4%
    -repeat $ml
      pc={($>+1)/$ml} msk={2+$>} {w},{h},1,1,0
      -if $12 ang={$>/$nwl} -else ang=$pc -endif
      -if {$<>=$wl}
        -noise[-1] {(1-$pc)*$5},2 ==. 1
        -blur_linear[-1] {$6+$pc*($7-$6)}%,0,{$ang*360+u(-$9,$9)+$8}
        -quantize[-1] $3,0 -deform[-1] {u*$10+1}
      -endif
      -r[-1] $nw,$nh -n[-1] 0,255
      -mul[$msk,-1] -progress {$pc*100}
    -done
    -add[-$ml--1] -c[-1] 0,255
    -n[-1] 0,255 -negate[-1] -apply_gamma[-1] $11
    -if $13 -r[-1] $w,$h,1,3,5 -c[-1] 0,255 -endif
    -keep[-1]
  -endl -done

#@gui Threshold Etch : fx_gcd_etch, fx_gcd_etch_preview(1)
#@gui : note = note("<u>Replace tones with noise generated lines</u>")
#@gui : note = note("\n<i>Input Image Settings</i>"), sep = separator()
#@gui : Threshold Low = int(125,10,255)
#@gui : Threshold Mid = int(153,10,255)
#@gui : Threshold High = int(171,10,255)
#@gui : Threshold Max = int(185,10,255)
#@gui : Blur Amount = float(0.1,0,2)
#@gui : note = note("\n<i>Output Etch Settings</i>"), sep = separator()
#@gui : Horizontal Amount = int(50,0,100)
#@gui : Cross-Hatch Amount = int(80,0,100)
#@gui : Vertical 1 Amount = int(50,0,100)
#@gui : Vertical 2 Amount = int(10,0,100)
#@gui : sep = separator()
#@gui : Horizontal Length = int(15,0,50)
#@gui : Vertical 1 Length = int(12,0,50)
#@gui : Vertical 2 Length = int(20,0,50)
#@gui : Flip Cross-Hatch = bool(0)
#@gui : sep = separator()
#@gui : Curve Amount = int(1,0,20)
#@gui : Gamma = float(0.3,0.01,1)
#@gui : Fast Resize = bool(1)
#@gui : Color Image = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
fx_gcd_etch :
-skip ${1=125},${2=153},${3=171},${4=185},${5=0.1} -skip ${6=50},${7=80},${8=50},${9=10}
-skip ${10=15},${11=12},${12=20},${13=0} -skip ${14=1},${15=0.3},${16=1},${17=0}
  -repeat $! -l[$>]
    #image resizing
    w={w} h={h} sc=800 ml=4
    -if {w>h} nw={min($sc,w)} nh={$nw/w*h} -else nh={min($sc,h)} nw={$nh/h*w} -endif
    -to_rgb[0] [0] -if $16 -r[1] $nw,$nh -endif
    #convert to b&w negative
    -b[1] $5% -norm[1] -negate[1] -n[1] 0,255
    #split into value ranges
    --c[1] 0,{255-$4} --c[1] {255-$3},128 --c[1] {255-$2},192 --c[1] {255-$1},255 -n[-3--1] 0,255
    #create etch layers
    {w},{h},1,1,0 -noise[-1] $6,2 ==. 1 -deriche[-1] $10,0,x,0
    {w},{h},1,1,0 -noise[-1] $7,2 ==. 1 {w},{h},1,3,0 -fc[-1] 0,-1,0 -smooth[-2] [-1],30,30,0 -rm[-1]
    -if $13 -mirror[-1] x -endif
    {w},{h},1,1,0 -noise[-1] $8,2 ==. 1 -deriche[-1] $11,0,y,0
    {w},{h},1,1,0 -noise[-1] $9,2 ==. 1 -deriche[-1] $12,0,y,0
    #reduce colour levels, add curve
    -quantize[-$ml--1] 2,0 -deform[-$ml--1] $14
    #combine image & etch layers
    -repeat $ml -mul[{2+$>},-1] -done
    #merge layers down, remove negative
    -add[-$ml--1] -n[-1] 0,255 -rm[1]
    -negate[-1] -apply_gamma[-1] $15
    #restore original size, combine colour
    -if $16 -r[-1] $w,$h,1,3,5 -c[-1] 0,255 -endif
    -if $17 -blend[0,1] shapeaverage -else -keep[-1] -endif
  -endl -done

fx_gcd_etch_preview :
  -gui_split_preview "-fx_gcd_etch ${1--2}",$-1

#@gui _<b>Colors</b>

#@gui HSL Adjustment : gcd_hsl, gcd_hsl_preview(1)
#@gui : note = note("\n<i>Input Saturation Settings</i>"), sep = separator()
#@gui : Contrast = float(1,0,2)
#@gui : Level = float(0,-1,1)
#@gui : Auto Reduce Level (Level Slider Is Disabled) = bool(0)
#@gui : note = note("\n<i>Output Hue Settings</i>"), sep = separator()
#@gui : Hue = float(180,0,360)
#@gui : Amount = float(0.2,0,1)
#@gui : Auto Set Hue Inverse (Hue Slider Is Disabled) = bool(0)
#@gui : note = note("\n<i>Output Luminance Settings</i>"), sep = separator()
#@gui : Gamma = float(1,0,2)
#@gui : Contrast = float(1,0,2)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/05/15</i>.</small>")
gcd_hsl : -skip ${1=1},${2=0},${3=0},${4=180},${5=0.2},${6=0},${7=1},${8=1}
  -repeat $! -l[$>]
    -split_opacity -to_rgb[0] -rgb2hsv[0]
    -if $6
      --channels[0] 0
      -histogram[-1] 360,0,360
      hue={(xM+180)%360} -rm[-1]
    -else hue=$4 -endif

    -sh[0] 1,1
    -if $3 sat={-max(0,ia-0.5)} -else sat=$2 -endif
    --[-1] 0.5 -*[-1] $1 -+[-1] $sat
    -+[-1] 0.5 -c[-1] 0,1 -rm[-1]
    -hsv2rgb[0]

    --channels[0] 0 -*[-1] 66
    --channels[0] 1 -*[-1] 129 -+[-2,-1]
    --channels[0] 2 -*[-1] 25 -+[-2,-1]
    -+[-1] 128 -/[-1] 256 -+[-1] 16
    -apply_gamma[-1] {max(0.001,$7)}
    -if {$8!=1} --[-1] 128 -*[-1] $8 -+[-1] 128 -endif
    -c[-1] 0,255

    -sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
    ($hue^1^1) -hsv2rgb[-1] -n[-1] {1-$5},1
    -*[-4] {@0} -*[-3] {@1} -*[-2] {@2}
    -rm[-4--1] -rgb2ycbcr[0] -j[0] [-1] -rm[-1]
    -ycbcr2rgb[0] -a c
  -endl -done

gcd_hsl_preview :
  -gui_split_preview "-gcd_hsl ${1--2}",$-1

#@gui HSV Select: gcd_hsv_select, gcd_hsv_select(2)
#@gui : note = note("<i>Color Selection</i>"), sep = separator()
#@gui : Hue = int(0,0,360)
#@gui : Saturation = float(0.5,0,1)
#@gui : Value = float(1,0,1)
#@gui : note = note("\n<i>Color Range</i>"), sep = separator()
#@gui : Hue Range = int(180,0,180)
#@gui : Sat Range = float(0.5,0,0.5)
#@gui : Val Range = float(0.5,0,0.5)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Grow Alpha = int(2,-20,20)
#@gui : Blur Alpha = int(2,0,20)
#@gui : note = note("\n<i>Advanced Options</i>"), sep = separator()
#@gui : Patch Size = int(18,3,100)
#@gui : Fill Holes % = int(0,0,50)
#@gui : Min Area % = int(0,0,50)
#@gui : Show Watershed = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/11</i>.</small>")
gcd_hsv_select :
-skip ${1=0},${2=0.5},${3=1} -skip ${4=180},${5=0.5},${6=0.5}
-skip ${7=2},${8=2} -skip ${9=18},${10=0},${11=0},${12=0}
  -repeat $! -l[$>]
    -to_rgba[0] -remove_opacity[0]
    -if {!$12} [0] -endif
    -l[-1]
      -gcd_shrink
      --rgb2hsv[0] -s[-1] c
      bh={$1-$4} th={$1+$4}
      --ge[1] {360+$bh} --le[1] {$th-360}
      -ir[1] {max($bh,0)},{min($th,360)}
      -or[-2,-1] -or[1,-1]
      -ir[2] {$2-$5},{$2+$5}
      -ir[3] {$3-$6},{$3+$6}
      -and[-2,-1] -and[-2,-1]
      -meancurvature_flow[0] 3 -median[0] 3
      -+[0] 1 --gradient_norm[0] --b[-1] 2,1,1 -min_patch[-1] $9
      -*[0,-1] -*[-1] -1 # dots, mask, gradient
      --*[0] [1] -gt[0] 0 -negate[1] -*[0,1] -*[0] 0.5 -max[0,-1]
      --watershed[0] [-1] -k[-1] --[-1] 1
      -gcd_unshrink
    -endl
    -if {!$12}
      -channels[-1] 0 -ge[-1] 0
      --area[-1] 0 --le[-1] {($10%*max(w,h))^2}
      --negate[-3] -*[-2,-1] -inpaint[-3] [-1] -rm[-1]
      -le[-1] {($11%*max(w,h))^2} -*[-1] [-2]
      -inpaint[-2] [-1] -rm[-1] -*[-1] 255
      -if {$7>0} -dilate[-1] $7
      -elif {$7<0} -erode[-1] {abs($7)} -endif
      -if $8 -b[-1] $8,1,1 -endif
      -a[-2,-1] c
    -endif
    -c[-1] 0,255
  -endl -done

#@gui Specific Saturation: gcd_hio_levels, gcd_hio_levels_preview(1)
#@gui : note = note("\n<i>Hue Levels</i>"), sep = separator()
#@gui : Input = float(1,0,2)
#@gui : Opposing = float(1,0,2)
#@gui : Hue = int(39,0,360)
#@gui : Level = float(0,-0.5,0.5)
#@gui : note = note("\n<i>Luma Levels</i>"), sep = separator()
#@gui : Gamma = float(1,0.2,1.8)
#@gui : Contrast = float(1,0.2,1.8)
#@gui : sRGB Conversion = bool(0)
#@gui : Process Top Layer Only = bool(0)
#@gui : sep = separator(), Preview = choice("Full","Forward horizontal","Forward vertical","Backward horizontal",
#@gui : "Backward vertical","Duplicate horizontal","Duplicate vertical","Blend all layers")
#@gui : Is Preview = value(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/01/22</i>.</small>")
gcd_hio_levels : -skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0},${8=0},${9=0},${10=0}
  -if {$8} -_gcd_hio_levels[0] ${1--4} -else -_gcd_hio_levels ${1--4} -endif
  -if {$10" && "$!>1} -rv -blend alpha -endif

_gcd_hio_levels : -skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0}
  -repeat $! -l[$>]
    -split_opacity -to_rgb[0] --gcd_srgb2luma[0]
    -if {$4!=0}
      -sh[0] 0 -sh[0] 1 -sh[0] 2,2
      ({$3%360}^1^1) -hsv2rgb. -max. 0 -*. $4 --. {ia}
      -+[-4] {@0} -+[-3] {@1} -+[-2] {@2} -rm[-4--1] -max[0] 0
    -endif
    -gcd_hue_chroma[0] $3,$1,$2
    -gcd_srgb2jpeg[0] -j[0] [-1] -rm.
    -max[0] 0 -sh[0] 0 srgb={($5!=1" || "$6!=1)" && "$7}
    -if $srgb -srgb2rgb. -endif
    -gcd_gamma. $5
    -if {$6!=1}
      m={iM/2} --. $m --sign. -abs..
      -gcd_gamma.. $6,1,$m -*[-2,-1] -+. $m
    -endif
    -if $srgb -rgb2srgb. -endif
    -rm. -gcd_jpeg2srgb[0] -a c -c 0,255
  -endl -done

gcd_hio_levels_preview :
  -if {$-2==7} -gcd_hio_levels ${1--2},1
  -else -gui_split_preview "-gcd_hio_levels $*",$-2 -endif

gcd_hue_chroma : -skip ${1=0},${2=1},${3=1}
  -if {$2==1" && "$3==1} -return -endif
  -repeat $! -l[$>]
    # get channels/ratio for hue
    h={($1%360)/60} x={1-abs($h%2-1)} y={if($x>0,1/$x,0)} h={int($h)+1}
    p={arg($h,0,1,1,2,2,0)} s={arg($h,1,0,2,1,0,2)} z={arg($h,2,2,0,0,1,1)}

    # get current hue level [Ih]
    [0] -sh. $p -sh.. $s --*.. $x
    --le. [-2] -j[-3] [-2],0,0,0,0,1,[-1] -rm..
    -eq. 0 --*.. $y -j[-4] [-1],0,0,0,0,1,[-2]
    -rm[-4--1] -sh. $z -f. 0 -rm.

    # set chroma of hues [0] [Ih] [P] [I0min] [Pn]
    -sh. $p --compose_channels[0] min --eq.. 0 -+. [-3]
    -if {$3!=1}
      --/[-2,-1] --. 1 -r. 100%,100%,1,3 -*. [-5] -+[0] [-1]
      --compose_channels[0] min --[0] [-1] -*[0] $3 -+[0,-1] --[0,-1]
    -endif
    -if {$2!=1} ---[-3,-2] -*. $2 -+[-3,-1] -/[-2,-1] --. 1 -*[-3,-1] -rm. -+
    -else -k[0] -endif
  -endl -done

#@gui Transfer Colors [Patch-Based] : fx_gcd_transfer_colors_patch, fx_gcd_transfer_colors_patch_preview(1)
#@gui : note = note("<i>Generate a CLUT and apply it to other images.</i>")
#@gui : note = note("\n<i>Input Options</i>"), sep = separator()
#@gui : Resolution = int(6,2,8)
#@gui : Smooth = float(3,0,10)
#@gui : Iters = int(5,0,20)
#@gui : Random = int(5,0,20)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Reference = choice("Top layer","Bottom layer")
#@gui : Output CLUT = _choice("Disable","512x512 layer","4096x4096 layer")
#@gui : note = note("\n"), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/08/17</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set the <i>Input layers</i> option to transfer colors to other layers.</small>")
#@gui : note = note("<small>If only one input layer is selected a CLUT is always output.</small>")
#@gui : note = note("<small>Higher resolution, iters, or random generally produce better results - at the cost of processing time.</small>")
#@gui : note = note("<small>Results are not necessarily the same every time due to the random based algorithm.</small>")
fx_gcd_transfer_colors_patch : -skip ${1=6},${2=3},${3=5},${4=5},${5=0},${6=0}
  ref={if($5,$!-1,0)} n=$!
  --gcd_extract_clut[$ref] ${1-4}
  -map_clut[^-1,$ref] .
  -if {$6>0" || "$n==1}
    r,s={arg(max($6,1),64,256)},{arg(max($6,1),512,4096)}
    -r. $r,$r,$r,3,3 -r. $s,$s,1,3,-1
  -else -rm. -endif

fx_gcd_transfer_colors_patch_preview :
  -fx_gcd_transfer_colors_patch $*
  -if {!$5} -rm[0] -endif

#@gui _<b>Degradations</b>

#@gui CRT Sub-Pixels : fx_gcd_crt, fx_gcd_crt(2)
#@gui : note = note("<i>Cathode ray tube sub-pixel rendering filter</i>"), sep = separator()
#@gui : Horizontal Blur = float(1.8,0,5)
#@gui : Vertical Blur = float(1.8,0,5)
#@gui : Screen Border = bool(0)
#@gui : Equalize = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/12/11</i>.</small>")
fx_gcd_crt : -skip ${1=1.8},${2=1.8},${3=0},${4=0}
  -repeat $! -l[$>]
    -to_rgb[0]
    -expand_xy 12,0 24,14,1,3,0
    -f[-1] "if((x-c*4)%12<4,255,0)"
    -f[-1] "if(x%4==0,0,i)"
    -f[-1] "if((y%14==0)&&(x%24<12),0,i)"
    -f[-1] "if(((y-7)%14==0)&&((x+12)%24<12),0,i)"
    -array[-1] {0,round(w/24)},{0,round(h/14)},2
    -z[-1] 0,0,{0,w-1},{0,h-1}
    -s c -repeat 3 -blend[-4,-1] shapeaverage0 -done -a c
    -n[-1] 0,255 -meancurvature_flow[-1] 4
    -if $3
      {w},{h},1,1,0
      -rectangle[-1] 5%,5%,95%,95%,1,1
      -b[-1] 10% -*[0,1]
    -endif
    -deriche[-1] $1,0,x -deriche[-1] $2,0,y
    -shrink_xy[-1] 12 -n[-1] 0,255
    -if $4 -equalize[-1] 256 -endif
  -endl -done

#@gui _<b>Details</b>

#@gui Tone Enhance : gcd_tone_enhance, gcd_tone_enhance(1)
#@gui : note = note("<i>Sharpen or adjust shadows and highlights</i>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Shadows</i></small></span>")
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Highlights</i></small></span>")
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Mid Point</i></small></span>")
#@gui : Centre = int(128,0,255)
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Extra Shadow/Highlight recovery</i></small></span>")
#@gui : Boost = float(0.5,0,1)
#@gui : Smooth = float(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Detail Mask</i></small></span>")
#@gui : Smooth = int(0,0,20)
#@gui : sep = separator()
#@gui : Channels = choice(4,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Values = choice("cut","normalize")
#@gui : Color Median = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/01/03</i>.</small>")
gcd_tone_enhance :
-skip ${1=0},${2=1},${3=0},${4=1},${5=128},${6=0},${7=1}
-skip ${8=0.5},${9=0},${10=0},${11=4},${12=0},${13=0}
  -if $13 -repeat $! -l[$>]
    -gcd_srgb2jpeg -sh 1,2 -median. 5,20 -rm. -gcd_jpeg2srgb -c 0,255
  -endl -done -endif
  mode=${-arg\ 1+$11,hsi_i,hsv_v,lab_l,lrgb,rgb,ycbcr_y}
  -ac "-_gcd_tone_enhance ${1-10}",$mode,{$12+1}

_gcd_tone_enhance :
  -repeat $! -l[$>]
    -if {$9>0} -bilateral 1%,$9 -c 0,255 -endif
    --norm --bilateral.. 2%,30 -norm. --[-2,-1]
    --gradient_norm.. -n. 0,1 -oneminus. -*[-2,-1]
    -if $10 -b. {0.025*$10}% -endif
    --n.. 0,255 -median. 3 -bilateral. 2%,30
    -gcd_srgb2luma. --. $5 --abs. -negate.
    --max.. 0 -min... 0 -abs...
    -if {$8!=0.5}
      --n[{$8>0.5?-3:-1}] 0,1 --gcd_ibezier[0] {1-$8}
      -j[0] .,0,0,0,0,1,.. -rm[-2,-1]
    -endif
    --/... {if(iM#-3>0,iM#-3/(1/$2-1),1)} -+. 1
    --/... {if(iM#-3>0,iM#-3/(1/$7-1),1)} -+. 1 -*[-2,-1]
    --/.. {if(iM#-2>0,iM#-2/(1/$4-1),1)} -+. 1 -*[-2,-1]
    m={0,iM} -/[0] $m -^[0,-1] -*[0] $m
    -n... 0,$1 -n.. 0,$6 -n. 0,$3 -*[-3--1] [-4] -rm[-4] -+
  -endl -done

#@gui _<b>Repair</b>

#@gui Deinterlace2x: gcd_deinterlace2x, gcd_deinterlace2x_preview(0)
#@gui : note = note("<i>Blend 2x frames for 4:2:0 YUV</i>"), sep = separator()
#@gui : Balance = int(40,1,255)
#@gui : 2x Type = choice("DCCI2x","Box2x","Fast Blend","Set Aspect Only")
#@gui : Aspect = choice("None","1:1","4:3","5:4","16:9","16:10","2.35:1","1.85:1")
#@gui : Interp = choice(2,"linear","bicubic","lanczos")
#@gui : Ignore Current Aspect = bool(0)
#@gui : Fast Blend Preview = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/05/01</i>.</small>")
#@gui : note = note("\n<small><b>Note:</b> preview may be inaccurate</small>")
#@gui : note = note("<small>Interp is only used when setting aspect</small>")
gcd_deinterlace2x : -skip ${1=40},${2=0},${3=0},${4=2},${5=0},${6=1}
  -if {$3} # set aspect
    ca={if($5,1,h/w)} na={arg($3,1,{4/3},{5/4},{16/9},{1.6},{2.35},{1.85})}
    -r {$ca*$na*w},100%,1,3,{arg($4+1,3,5,6)} -c 0,255
  -endif -if {$2==3} -return -endif
  -repeat $! -l[$>]
    w={w} h={h} d={d} hh={int($h/2)} -rgb2yuv -s c
    -l[0] --shift 0,-1 -r $w,$hh,$d,1,4 -endl
    -l[-2,-1] -r $w,2,$d,$hh,-1 --shift 0,0,0,-1 -r $w,2,$d,50%,4 -r $w,$hh,$d,1,-1 -endl
    -a[0,2,3] c -a[^0] c -yuv2rgb # frames are now separate
    -if {$2==0} -scale_dcci2x ,,1 -r 50%,100%,1,3,4
    -elif {$2==1} -gcd_scale_box2x , -r 50%,100%,1,3,4
    -else # 2xH scaling
      a={2/3} b={-1/12} ($b,$a,$b;$b,$a,$b;0,0,0) --convolve[^-1] [-1] -rm...
      -r 100%,200%,1,3,4 -shift[-2,-1] 0,1 -+[-3,-1] -+[-3,-1]
    -endif # blend based on thresholded surrounding difference
    -c 0,255 -shift. 0,1 --- --norm. a={-192^-.5/$1} ($a,$a,$a;$a,0,$a;$a,$a,$a)
    -convolve.. [-1] -rm. -max. -1 -+. 1 -*[-2,-1] --[0,-1] -rm.
  -endl -done

gcd_deinterlace2x_preview :
  -gcd_deinterlace2x ${1},{if($6,max(2,$2),$2)},${3--1}

#@gui Despeckle: gcd_despeckle, gcd_despeckle(3)
#@gui : note = note("<i>Remove small dots and specks</i>"), sep = separator()
#@gui : Tolerance = int(20,0,50)
#@gui : Max Area = int(10,0,100)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.   Latest update : <i>2013/02/01</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set max area to 0 for no area size limit.</small>")
gcd_despeckle : -skip ${1=15},${2=30}
  -repeat $! -l[$>]
    ma={if(!$2,w*h,$2)}
    --label[-1] $1,1 nb={1+iM}
    --histogram[-1] $nb,0,{$nb-1}
    -map[-2] [-1] -rm[-1]
    -le[-1] $ma -*[-1] 255
    -inpaint[-2] [-1] -rm[-1]
  -endl -done

#@gui _<b>Stereoscopic 3D</b>

#@gui Stereo Image : gcd_stereo_img, gcd_stereo_img(1)
#@gui : note = note("<u>Create a 3D image from a flat one</u>")
#@gui : note = note("\n<i>3D Options</i>"), sep = separator()
#@gui : 3D Image Type = choice("Anaglyph: Red/Cyan","Side by Side","Depth Map","Inverse Depth Map")
#@gui : Balance Color = float(0.5,0,1)
#@gui : Depth = float(1.2,0,3)
#@gui : Distance = float(1,-2,2)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Despeckle = bool(1)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Auto Crop = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/07/02</i>.</small>")
gcd_stereo_img : -skip ${1=0},${2=2},${3=1.2},${4=1},${5=0.25},${6=2},${7=4},${8=1},${9=0}
  -repeat $! -l[$>]
  -to_rgb[0] b={abs($3%*w*$4)}
  --gcd_depth[0] $5,$6,$7,$8
  -gcd_stereo[0,1] $1,$2,$3%,$4
  -if {!$1" && "$9} -z[-1] $b,{w-1-$b} -endif
  -endl -done

gcd_depth : -skip ${1=0.25},${2=2},${3=4},${4=1}
  -repeat $! -l[$>]
    -if {w>h} -if {w>700} --r[-1] 700,{h*700/w} -else [0] -endif
    -elif {0,h>700} --r[-1] {0,w*700/h},700 -else [0] -endif
    -median[-1] 7 -gcd_segment_ch0[-1] 1
    -if $4 -gcd_label[-1] $3 -else -label[-1] $3,1 -endif
    -c[-1] 0,255 -b[-1] 0.45% -n[-1] 0,$2 -r[-1] [0],[0]
    -norm[0] -n[0] 0,1 -+[-2,-1] -b[-1] $1% -n[-1] 0,255
  -endl -done

gcd_segment_ch0 : -check "${1=1}>=0"
  -repeat $! -l[$>]
    min={im} -+ {1+$min} --gradient_norm -channels[0] 0
    --f[-1] "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
    -*[0,-1] -*[-1] -1 -watershed[-2] [-1] -rm[-1] -- {1+$min}
  -endl -done

gcd_stereo : -skip ${1=0},${2=1},${3=1.2%},${4=1}
  -l[-2,-1]
    -if {$1==2} -keep[-1] -return
    -elif {$1==3} -keep[-1] -negate -return -endif
    wfac={if(${"-is_percent $3"},$3*w,$3)} -n[-1] 0,$wfac
    -if {$1<2" && "$2>0} -gcd_balance_anaglyph[0] {2-$2} -endif
    -i[1] [0] -warp[0] [-1],1 -mul[-1] -1 -warp[1] [-1],1 -rm[-1]
    -if $1 -rv[0,1] -append[0,1] x -else -shift[0] {round(-$wfac*$4)} -shift[1] {round($wfac*$4)}
    -channels[0] 0 -channels[1] 1,2 -append[0,1] c
    -endif
  -endl

gcd_balance_anaglyph : -skip ${1=1},${2=0.43},${3=0.45}
  -l[-1] -sh 0,0 -sh[0] 1,1 -sh[0] 2,2 ---[2] [1] inv={255^(1-$1)*$2}
    -if {$1>1} --sign[-1] -abs[-2] -^[-2] $1 -*[-2] $inv -*[-2,-1] -else -*[-1] $2 -endif
    --[2,3] [-1] -*[-1] {1/$2-1} -+[1,-1] --*[3] 0.65 --[-1] [1] -max[-1] 0 -*[-1] $3
    --[3] [-1] -*[-1] {1/$3-1} -+[1,-1] -apply_gamma[1] 1.15 -rm[1-3] -c 0,255
  -endl

#@gui Undo Anaglyph : gcd_unstereo, gcd_unstereo_preview(1)
#@gui : note = note("<u>Attempt to revert red/cyan anaglyph to 2D</u>")
#@gui : note = note("<b>Warning: with high precision or large image this can be VERY slow!</b>")
#@gui : note = note("\n<i>Displacement Settings</i>"), sep = separator()
#@gui : Precision = float(5,1,6)
#@gui : Smoothness = float(0.1,0,1)
#@gui : Horizontal Warp Only = bool(1)
#@gui : Fast (Low Precision) Preview = bool(1)
#@gui : note = note("\n<i>Tile Settings</i>"), sep = separator()
#@gui : Horizontal Tiles = int(1,1,8)
#@gui : Vertical Tiles = int(1,1,8)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/10/26</i>.</small>")
gcd_unstereo : -skip ${1=5},${2=0.1},${3=0},${4=1},${5=1},${6=1},${7=0},${8=0}
  -repeat $! -l[$>]
    -if {$4" && "$8} pr=1 -else pr=$1 -endif # set precision to low for fast preview
    -to_rgb[0] -split_tiles[0] $5,$6
    -repeat $! -l[$>]
      -s[0] c --equalize[0,1] 256 # split red/green channels to new images
      --displacement[-2] [-1],$2,$pr # create displacement map from red/green comparison
      -if $3 -sh[-1] 1,1 -f[-1] 0 -rm[-1] -endif # remove vertical displacement if selected
      -/[-1] 2 -warp[1,2] [-1],1 -*[-1] -1 -warp[0] [-1],1 # warp channels
      -keep[0-2] -a c -c[0] 0,255 # merge channels back to RGB image
    -endl -done
    -append_tiles $5,$6
  -endl -done

gcd_unstereo_preview :
  -gui_split_preview "-gcd_unstereo ${1--1},1",$-1

#@gui _<b>Testing</b>
#@gui <i>Garagecoder</i>

#@gui CRMT Tiles : fx_gcd_crmt_tile, fx_gcd_crmt_tile(1)
#@gui : note = note("<i>Tiling by Clone, Rotate, Mirror, Translate method.</i>"), sep = separator()
#@gui : Constants = text{"t_w=[w] t_h=[round(1/2*sqrt(3)*$t_w)]"}
#@gui : Image Size = text("[3*$t_w,2*$t_h]")
#@gui : Command List = text{1,"C0 T0 C0 Fo R-60 T[-1/2*$t_w,0]"}
#@gui : Inpaint = bool(0)
#@gui : sep = separator(), note = note("<small>Implementation : <i>Garagecoder</i>.     Latest update : <i>2018/12/06</i>.</small>")
#@gui : note = note("<small>Author: <i>G. Bachelier</i></small>")
#@gui : note = note("\n<b>Warning</b>: alpha version, don't expect perfection!")
fx_gcd_crmt_tile :
  m "_crmt_tile_C : [$""1]"
  m "_crmt_tile_R : rotate. $""1 autocrop."
  m "_crmt_tile_Fo : mirror. x"
  m "_crmt_tile_Fi : mirror. y"
  ({'"_crmt_tiling_command : $1 {``$2},1,4 $3"'})
  replace_str. "C","_crmt_tile_C "
  replace_str. "Fo","_crmt_tile_Fo "
  replace_str. "Fi","_crmt_tile_Fi "
  replace_str. "R","_crmt_tile_R "
  replace_str. "T","_crmt_tile_T "
  replace_str. "[","{["
  replace_str. "]","]}"
  m {t}
  rm.
  repeat $! l[$>]
    _crmt_tiling_command k[1]
    if $4
      +channels[0] 100% negate. dilate. 3
      inpaint[0] .,0,0 rm.
    fi
  endl done
  uncommand _crmt_tiling_command

_crmt_tile_T : skip ${1=0},${2=0} # this command actually renders as well
  #split_opacity. n. 0,1 j[1] ..,$1,$2,0,0,1,. rm[-2,-1]
  f. ':i3>0?I(#1,$1+x,$2+y)=I;i' rm.

#@gui Deblur Texture : fx_gcd_blur_deblur_texture, fx_gcd_blur_deblur_texture_preview(0)
#@gui : note = note("<i>Variance-based edge preserving deblur or smooth</i>"), sep = separator()
#@gui : Iters = int(4,1,20)
#@gui : Sigma = float(1,0,4)
#@gui : Edges = float(0.5,0,1)
#@gui : Action = choice("Deblur","Smooth")
#@gui : Channels = choice(2,"RGB","Linear RGB","Luma","Chroma")
#@gui : Percentage sigma = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/09/02</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Iters: overall amount, increases computation time.</small>")
#@gui : note = note("<small>Sigma: detail scale.</small>")
#@gui : note = note("<small>Edges: amount of edge preservation.</small>")
#@gui : note = note("<small>Percentage sigma: make detail scale relative to image size.</small>")
fx_gcd_blur_deblur_texture : skip ${1=4},${2=1},${3=0.5},${4=0},${5=2},${6=0}
  v - repeat $! l[$>]
    mode=${-arg\ 1+$5,rgb,lrgb,ycbcr_y,ycbcr_cbcr}
    if $6 r=$2% else r=$2 fi
    if $4 ac "repeat $1 gcd_blur_texture "$r",$3 done",$mode,1
    else ac "repeat $1 +l +gcd_blur_texture "$r",$3 norm sub endl add done",$mode,1 fi
  endl done v +

fx_gcd_blur_deblur_texture_preview :
  gui_split_preview "fx_gcd_blur_deblur_texture $*",${-3--1}

#@cli gcd_blur_texture : std_deviation>=0[%],0<=edge_exponent<=1
#@cli : Edge preserving smooth.
#@cli : Default values: 'std_deviation=1' and 'edge_exponent=1'.
#@cli : $ image.jpg gcd_blur_texture 1
gcd_blur_texture : skip ${1=1},${2=1}
  e[^-1] "Apply blur texture filter of size $1, on image$?."
  v - repeat $! l[$>] # i = i + (A(k) - i) / stddev(k)^p
    [0] +sqr. b[-2,-1] $1 +sqr.. sub[-2,-1]
    max. 0 +eq. 0 add[-2,-1] sqrt. pow. -$2
    j[0] ..,0,0,0,0,1,. k[0]
  endl done v +

#@gui LMS Adjustment : gcd_balance_lms, gcd_balance_lms(1)
#@gui : note = note("<i>Chromatically adapt to a new illuminant</i>"), sep = separator()
#@gui : Long = float(1,0.5,1.5)
#@gui : Medium = float(1,0.5,1.5)
#@gui : Short = float(1,0.5,1.5)
#@gui : sep = separator()
#@gui : Adapt Luminance = bool(0)
#@gui : Pre Normalize = bool(0)
#@gui : Auto Balance = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/09/08</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>sRGB D65 input is assumed.</small>")
#@gui : note = note("<small>LMS sliders: control illuminant ratios.</small>")
#@gui : note = note("<small>Adapt Luminance: adjust luminance as well, may cause clipping.</small>")
#@gui : note = note("<small>Pre Normalize: stretch input RGB ranges to maximum.</small>")
#@gui : note = note("<small>Auto Balance: attempt to set neutral grey lighting.</small>")
gcd_balance_lms : skip ${1=1},${2=1},${3=1},${4=0},${5=0},${6=0}
  repeat $! l[$>]
    if $5 s c n 0,255 a c fi srgb2rgb rgb2xyz 1 # D65
    mix_channels (0.7328,0.4296,-0.1624;-0.7036,1.6975,0.0061;0.0030,0.0136,0.9834)
    if $6 # Compare average with average of equalized geometric mean
      m={[im,iM]} +r 1,1,1,100%,2 +n.. 0.002,0.998 log. gm={ia} +r. 1,1,1,100%,2
      repeat {s#2} sh[2] $> *. {$gm/i[#3,$>]} rm. done
      rm. exp. n. $m r. 1,1,1,100%,2 div[-2,-1]
    else (1^1^1) fi
    # Adapt to new illuminant (CAT02 with D = 1)
    ($1^$2^$3) n={L=$4?[0.454369,0.473533,0.072098]:[1,1,1];dot(L,I#1)/dot(L,I#2)}
    repeat {s#1} sh[0] $> *. {$n*i[#2,$>]/i[#1,$>]} rm. done k[0]
    mix_channels (1.096124,-0.278869,0.182745;0.454369,0.473533,0.072098;-0.009628,-0.005698,1.015326)
    xyz2rgb 1 rgb2srgb
  endl done

#@gui Cumulative Math : fx_gcd_cumul_math, fx_gcd_cumul_math_preview(1)
#@gui : note = note("<i>Cumulative Math glitch filter</i>"), sep = separator()
#@gui : Operation = choice(0,"Add","Or","Xor","And","Mod")
#@gui : Amount = int(1,1,512)
#@gui : Step = int(1,1,256)
#@gui : Horizontal = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/18</i>.</small>")
fx_gcd_cumul_math : skip ${1=0},${2=1},${3=1},${4=0}
  op=${arg\ 1+$1,"add","or","xor","and","mod"}
  ac "gcd_cumul_math $2,$3,"$op",$4",rgb replace_nan 255

gcd_cumul_math : skip ${1=1},${2=1},${3="add"},${4=0}
  repeat $! l[$>]
    100%,100%,100%,1,1 (0,$2) if $4 z. 1,1 fi
    +mul. $1 shift[1] {^} rm. m={^} rm. [0]
    repeat $1 +shift. $m +mul. [1] $3[0,-1] rm.. done k[0] mod 256
  endl done

fx_gcd_cumul_math_preview :
  gui_split_preview "fx_gcd_cumul_math ${1--2}",$-1

#@gui Upscale [Noise] : gcd_upscale_noise, gcd_upscale_noise_preview(0)
#@gui : note = note("<i>Upscale 2x using randomized estimation of original</i>"), sep = separator()
#@gui : Noise = int(16,0,32)
#@gui : Iters = int(2,1,3), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/08</i>.</small>")
#@gui : note = note("\n<small>Note: reduce iters and increase noise for poor images.</small>")
gcd_upscale_noise : skip ${1=16},${2=2}
  gcd_scale_noise $1,$2 c 0,255

gcd_upscale_noise_preview :
  z 25%,25%,75%,75% gcd_upscale_noise $*

gcd_scale_noise : skip ${1=16},${2=2}
  -v - repeat $! l[$>]
    200%,200%,100%,100% gcd_random. $1
    repeat $2 +r. ..,2 -. [0] r. .. boxfilter. 3 -[1,2] done rm..
  endl done -v +

gcd_random : skip ${1=1},"${2=?}"
  f "begin(a=int(255*u);b=int(64000*u+999);q=int(255*u+255));
     n=xor(a,a<<13);a=b;b=q;q=xor(xor(q,q>>15),xor(n,n>>10))"
  if {isval("$2")} n $1,$2 else n 0,$1 fi

#@gui Smooth [Geometric-Median] : fx_gcd_geometric_median, fx_gcd_geometric_median_preview(0)
#@gui : note = note("<i>Smooth using windowed geometric median of vectors</i>"), sep = separator()
#@gui : Radius = int(3,1,9)
#@gui : Iters = int(12,1,20)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/07/18</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>This prototype filter can be extremely slow to compute!</small>")
#@gui : note = note("<small>Only odd window sizes are currently supported.</small>")
fx_gcd_geometric_median :
  ac "gcd_geometric_median $1,$2",$3

fx_gcd_geometric_median_preview :
  gui_split_preview "fx_gcd_geometric_median $*",${-3--1}

#@gui Quick Tonemap : fx_gcd_quicktone, fx_gcd_quicktone(1)
#@gui : note = note("<i>Simple tone and detail control</i>"), sep = separator()
#@gui : Power = float(1,0.5,2.5)
#@gui : Radius = float(4,0,10)
#@gui : Range = float(20,0,20)
#@gui : Smooth = float(0,0,4)
#@gui : Channels = choice(3,"HSI","HSV","Lab","YCbCr")
#@gui : Values = choice(1,"cut","normalize")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/06/26</i>.</small>")
fx_gcd_quicktone : skip ${1=1},${2=4},${3=20},${4=0},${5=3},${6=1}
  mode=${-arg\ 1+$5,hsi_i,hsv_v,lab_l,ycbcr_y}
  if {$4>0} r={[im,iM]} bilateral 1%,$4 -c $r fi
  ac "+gcd_tonemap_gamma $2% +bilateral. $2%,{(iM#0-im#0)*$3/100} -[-2,-1] *. $1 +",$mode,{$6+1}

#@cli gcd_tonemap_gamma
#@cli : Map tones by local adjustment of geometric mean.
gcd_tonemap_gamma : skip ${1=100}
  -v - repeat $! l[$>] m={[im,iM]} n 0.002,0.998 log +b $1 *.. {0,is/whds} / exp n $m endl done -v +

#@gui Normalize Brightness : gcd_normalize_brightness, gcd_normalize_brightness(1)
#@gui : note = note("<i>Normalize brightness across the image</i>"), sep = separator()
#@gui : Bright = float(0,-2,2)
#@gui : Area = float(10,0,100)
#@gui : Smooth = float(0,0,4)
#@gui : Channels = choice(3,"HSI","HSV","Lab","YCbCr","sRGB")
#@gui : Mask = choice("Normal","Darken","Lighten")
#@gui : Absolute Brightness = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/05/27</i>.</small>")
#@gui : note = note("<small>\n<u>Tips:</u>\n\nDefault settings for de-haze.</small>")
#@gui : note = note("<small>Large area and Lab for very bright images.</small>")
#@gui : note = note("<small>Small area and HSV for very dark images.</small>")
#@gui : note = note("<small>Medium area and HSV for high contrast images.</small>")
#@gui : note = note("<small>Smooth to reduce artifacts, however some detail may be lost.</small>")
gcd_normalize_brightness : -skip ${1=0},${2=10},${3=0},${4=3},${5=0},${6=0}
  mode=${-arg\ 1+$4,hsi_i,hsv_v,lab_l,ycbcr_y,rgb}
  -if {$3>0} -bilateral 1%,$3 -c 0,255 -endif
  -if {$5==0} -ac "-gcd_tonemap_area $2,$1,$6",$mode,2
  -else --ac "-gcd_tonemap_area $2,$1,$6",$mode,2 -blend ${-arg\ $5,darken,lighten} -endif

gcd_tonemap_area : -skip ${1=100},${2=0},${3=0}
  -repeat $! -l[$>]
    -+ 0.5 m={iM+1} -/ $m # Set domain
    -if $3 a={$2/4.001+0.5} -else --^. $2 a={is} -rm. --^. {$2-1} a={$a/is} -rm. -endif # Lehmer mean
    H={1/$a-1} --oneminus -/. .. -b. $1% -^. -1 -*. $H # Rational factor map
    --oneminus. -*. [0] -+[-2,-1] -/ -* $m -- 0.5 # Rational mapping
  -endl -done

#@gui Auto Balance: gcd_auto_balance, gcd_auto_balance(1)
#@gui : note = note("<i>Map based tone and color balance</i>"), sep = separator()
#@gui : Area = float(30,0,200)
#@gui : Smooth = float(0,0,2)
#@gui : Channels = choice(0,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Balance sRGB = bool(1)
#@gui : Reduce RAM = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/08</i>.</small>")
gcd_auto_balance : -skip ${1=30},${2=0},${3=0},${4=1},${5=0}
  mode=${-arg\ 1+$3,hsi_i,hsv_v,lab_l,lrgb,rgb,ycbcr_y}
  -if {$2>0} -bilateral 1%,$2 -c 0,255 -endif
  -if {$4!=0} -ac "-gcd_rgb_balance",rgb -endif
  if $5 ac "-gcd_tonemap_inplace $1",$mode,2
  else -ac "-gcd_tonemap $1",$mode,2 fi

gcd_tonemap : -skip ${1=100},${2=255}
  -repeat $! -l[$>]
    -/ $2 --boxfilter $1%
    ---. 0.5 -sign. -*. -1
    --*.. -2 -+. 1 -/[1] .
    --eq. 0 -+[-2,-1] -/[0,-1]
    --sqr.. -+[0,-1] -max[0] 0
    -sqrt[0] -*[0,-1] -- -* $2
  -endl -done

gcd_tonemap_inplace : skip ${1=100},${2=255}
  repeat $! l[$>]
    div $2 +boxfilter $1%
    f[0] "*A=i(#-1,x,y,z,c);B=1-2*A;Bx=A/B;-sign(A-0.5)*sqrt(i/B+Bx^2)-Bx;"
    rm. mul $2
  endl done

gcd_rgb_balance :
  -repeat $! -l[$>]
    m={iM} -s c -n 0,$m -a c [0] --r. 1,1,1,100%,2
    -repeat {s#1} -sh[1] $> --. {2,i[$>]+$m/2} -rm. -done
    -rm. -n. 0,$m --/[0] $m --^. 3 -compose_channels. + -/. -3 -+. 1
    -compose_channels.. max -*[-2,-1] -j[0] ..,0,0,0,0,1,. -k[0]
  -endl -done

#@gui Inverse Bezier Warp: gcd_ebwarp, gcd_ebwarp(1)
#@gui : note = note("<i>Horizontal inverse conformal bezier warp</i>"), sep = separator()
#@gui : Mid = float(0.5,0,1)
#@gui : End = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/02/06</i>.</small>")
#@gui : note = link("http://benpaulthurstonblog.blogspot.co.uk/2015/12/ebezier.html")
gcd_ebwarp : -skip ${1=0.5},${2=1}
  -repeat $! -l[$>]
    b={w*$1*$2} c={w*$2} d={2*$c-4*$b}
    e={(4*$b-$c)/(2*$d)} se={sqr($e)}
    {w},{h},1,1,x
    -if {$1==0.5} -*. {1/$c} -else
      -/. $d -+. $se
      -if {$1>1} -abs. -endif
      -sqrt.
      -if {$1>0.5} -*. -1 -endif
      --. $e
    -endif
    -*. {w} {w},{h},1,1,y -a[^0] c
    -warp[0] [-1],0,2,0 -rm. -c 0,255
  -endl -done

#@gui Multi Thresholds : tran_multi_threshold, tran_multi_threshold(1)
#@gui : note = note("<i>Apply color to selectable tones</i>"), sep = separator()
#@gui : Threshold_1 = int(50,0,255)
#@gui : Threshold_2 = int(100,0,255)
#@gui : Threshold_3 = int(150,0,255)
#@gui : Threshold_4 = int(200,0,255)
#@gui : 1st Color = color(9,0,1)
#@gui : 2nd Color = color(175,42,27)
#@gui : 3rd Color = color(101,101,101)
#@gui : 4th Color = color(174,165,131)
#@gui : 5th Color = color(247,228,160)
#@gui : sep = separator(), note = note("<small>Author : <i>trandoductin</i>.      Latest update : <i>2016/08/25</i>.</small>")
tran_multi_threshold : -skip ${1=50},${2=100},${3=150},${4=200}
  -repeat $! -l[$>]
    -split_opacity --rgb2ycbcr[0] -channels. 0 -fc[0] ${5-7}
    --fc[0] ${8-10} --ge[-2] $1 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
    --fc[0] ${11-13} --ge[-2] $2 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
    --fc[0] ${14-16} --ge[-2] $3 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
    --fc[0] ${17-19} --ge[-2] $4 -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
    -rm. -a c
  -endl -done

#@gui PQCT Example: gcd_pqct, gcd_pqct(1)
#@gui : note = note("<i>Parameterized Quadratic Conformal transformation</i>")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/02/07</i>.</small>")
#@gui : note = note("\nBased on example code from:")
#@gui : note = link("http://benpaulthurstonblog.blogspot.co.uk/2015/12/parameterized-quadratic-conformal.html")
gcd_pqct :
  -repeat $! -l[$>]
    ({w*.1},{h*.2};{w*.2},{h*.6};{w*.2},{h*.9};{w*.5},{h*.1};\
     {w*.6},{h*.8};{w*.9},0;{w*.85},{h*.4};{w},{h*.75})
    -transpose. 9,2,1,1
    -repeat 2 # coefficients
      -sh[2] $>,$>,0,0 -sh[1] $>,$>,0,0
      k={"k=(i[1]+i[3]+i[4]+i[6])/4; i(#-2,0)=k;
      i(#-2,1)=(i[6]-i[1])/2; i(#-2,2)=(i[3]-i[4])/2;
      i(#-2,3)=(i[6]+i[1])/2-k; i(#-2,4)=(i[3]+i[4])/2-k;
      i(#-2,5)=(i[2]+i[5]-i[0]-i[7])/4;
      i(#-2,6)=(i[0]+i[5]-i[2]-i[7])/4+(i[4]-i[3])/2;
      i(#-2,7)=(i[5]+i[7]-i[0]-i[2])/4+(i[1]-i[6])/2;
      i(#-2,8)=(i[0]+i[2]+i[5]+i[7])/4-k;0"}
      -rm[-2,-1]
    -done
    --f[0] 0 -r. 100%,100%,1,2,-1 -sh[0] 0
    -f. "begin(cx0=i(#2,0);cx1=i(#2,1);cx2=i(#2,2);cx3=i(#2,3);
         cx4=i(#2,4);cx5=i(#2,5);cx6=i(#2,6);cx7=i(#2,7);cx8=i(#2,8);
         cy0=i(#2,0,1);cy1=i(#2,1,1);cy2=i(#2,2,1);cy3=i(#2,3,1);
         cy4=i(#2,4,1);cy5=i(#2,5,1);cy6=i(#2,6,1);cy7=i(#2,7,1);cy8=i(#2,8,1));
    s=(2*x/w-1); t=-(2*y/h-1); s2=s*s; t2=t*t;
    i(#3,x,y,0,0)=cx8*s2*t2+cx7*s*t2+cx6*s2*t+cx5*s*t+cx4*t2+cx3*s2+cx2*t+cx1*s+cx0;
    i(#3,x,y,0,1)=cy8*s2*t2+cy7*s*t2+cy6*s2*t+cy5*s*t+cy4*t2+cy3*s2+cy2*t+cy1*s+cy0; i"
    -rm[-4,-3,-1] -round. [0],[0],[0],[0] -sh[0] 0 px=""
    -repeat {0,s} px=$px;i(#2,a,b,0,$>)=i$>#0 -done
    -f. 'a=i#1;b=i1#1$px' -rm. -j[0] [-1] -k[0]
  -endl -done

#@gui Blend [Feather]: gcd_blend_feather, gcd_blend_feather(1)
#@gui : note = note("<u>Overlay layers seamlessly by feathering edges</u>")
#@gui : note = note("<small>1. Set Input layers to <b>Active &amp; below</b> for two layers</small>")
#@gui : note = note("<small>2. For best results ensure layers are the same size</small>")
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Max Delta = int(100,0,200)
#@gui : Color Transfer = float(0.5,0,1)
#@gui : Hue Extent = float(2,0,6)
#@gui : Remove BG = int(0,0,20)
#@gui : Keep Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/05/05</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Remove BG can help mask off unwanted areas, which works</small>")
#@gui : note = note("<small>best on objects surrounded by simple backgrounds.</small>")
#@gui : note = note("<small>Overlaying a larger area can sometimes improve the output.</small>")
gcd_blend_feather : -skip ${1=100},${2=0.5},${3=2},${4=0},${5=0}
  -r[^-1] [-1],[-1],1,100%,0,0,0.5,0.5
  -if $5
    --gcd_blend_maxdelta ${1-4}
    -to_a[0] -split_opacity[0] -rv[1,-1] -a[1,-1] c -rm[0]
  -else -gcd_blend_maxdelta ${1-4} -endif

gcd_blend_maxdelta : -skip ${1=100},${2=0.5},${3=2},${4=0}
  -if {$!>1} -repeat {$!-1} -l[0,1]
    -to_a -split_opacity -/[1,3] 255
    -nm[0] upper -nm[1] alpha -nm[2] lower -nm[3] mask

    # transfer colours
    --r[lower] 1,1,1,100%,2
      --+[upper] 0.1 -*[-1] [alpha]
      -s[-1] c -discard[-3--1] 0 -a[-3--1] c
      -r[-1] 1,1,1,100%,2 -r[-2,-1] [upper]
    -*[-2,-1] $2 -sub[upper,-1] -add[upper,-1] -c[upper] 0,255

    # get distance, full blending for lower layer transparency
    --distance[alpha] 0 -nm[-1] dist
    -eq[mask] 0 -*[mask] {dist,iM} -max[dist] [mask]

    # get foreground mask
    -if {$4>0}
      [upper] [alpha] -a[-2,-1] c
      -gcd_fgmask[-1] {20-$4} -b[-1] 3 -*[alpha,-1]
    -endif

    # hue extent
    --n[dist] 0,$3 -c[-1] 0,1 -*[-1] [alpha]
    -gcd_srgb2jpeg[upper,lower] -sh[upper,lower] 1,2
    -j[-1] [-2],0,0,0,0,1,[-3] -rm[-3--1]
    -gcd_jpeg2srgb[upper,lower]

    # blend using distance as maximum difference
    -n[dist] 0,{255*$1%}
    --sub[upper] [lower] -*[-1] [alpha]
    --sign[-1] -abs[-2] -min[dist,-2] -*[dist,-1]
    -+[lower] [dist] -k[lower] -c 0,255
  -endl -done -endif

gcd_fgmask : -skip ${1=0}
# fast foreground select based on central positioning
# within an alpha selected region, pre-processing with
# -median can improve selections. output range 0 -> 1
  -repeat $! -l[$>]
    -to_a -expand_xy 20,0 -split_opacity -gt[-1] 0
    --distance[-1] 0 -max_patch[-1] 3 -*[-1] 2
    --erode[1] 20 -*[-2,-1] -dilate[-1] $1
    --gradient_norm[-2] -gt[-1] 0
    -gradient_norm[0] --eq[-1] 0 -*[0,-1]
    -max[-2,-1] -*[0,1] -*[0] -1
    -watershed[-1] [-2] -rm[-2]
    -shrink_xy 20 -- 1
  -endl -done

#@gui Upscale [Box]: gcd_upscale_box, gcd_upscale_box_preview(0)
#@gui : note = note("<i>Box average upscale</i>"), sep = separator()
#@gui : Upscale Factor = choice("2x","4x"), sep = separator()
#@gui : CbCr Median = bool(0)
#@gui : Sharpen = bool(0), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/09/27</i>.</small>")
#@gui : note = note("\n<small>Soft upscale with sharpening, may cause edge artifacts.</small>")
gcd_upscale_box : -skip ${1=0},${2=0},${3=0}
  -if $2 -ac "-median 5,20",ycbcr_cbcr -endif
  -gcd_scale_box2x $1,$3 -c 0,255

gcd_upscale_box_preview :
  -if $1 -z 37.5%,37.5%,62.5%,62.5% -else -z 25%,25%,75%,75% -endif
  -gcd_upscale_box $*

gcd_scale_box2x : -skip ${1=0},${2=0}
  -repeat $! -l[$>]
    -if {$1>0} (400,5,7,49,33) -else (200,3,3,9,5) -endif
    --r.. {@0}%,{@0}% -median. {1,@1} -boxfilter. {1,@1}
    --r. [0],2 --[0,-1] -r[0] .
    -if $2
      [0] -boxfilter[0] {1,@2} -*[0] {1,@3}
      --[0,-1] -/[0] {1,@4} -rm.. -+
    -else -boxfilter[0] {1,@2} -rm.. -+ -endif
  -endl -done

#@gui Depth Blur : gcd_depth_blur, gcd_depth_blur(1)
#@gui : note = note("<u>Selectively blur based on estimated depth</u>")
#@gui : note = note("<small>Amount of blur applied is relative to luminance of the depth map</small>")
#@gui : note = note("\n<i>Focus Options</i>"), sep = separator()
#@gui : Distance Threshold = int(0,0,100)
#@gui : Blur Amount = int(15,0,100)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Create/View Depth Map = bool(0)
#@gui : Reverse Map = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/24</i>.</small>")
gcd_depth_blur : -skip ${1=0},${2=15},${3=0.25},${4=2},${5=4},${6=0},${7=1}
  -repeat $! -l[$>]
  sa={$2*max(w,h)/1000}
  -to_rgb[0]
  --gcd_depth[0] $3,$4,$5
  -if $7 -negate[-1] -endif
  -threshold[-1] $1%,1 -n[-1] 0,255
  -if $6 -keep[-1] -else
    {w},{h},1,1,0 [-2] -a[-3--1] c
    -smooth[-2] [-1],$sa,30,0 -rm[-1]
    -c[-1] 0,255
  -endif
  -endl -done

#@gui Emboss: gcd_emboss, gcd_emboss_preview(1)
#@gui : note = note("<i>Make an image look embossed</i>"), sep = separator()
#@gui : Midpoint = int(128,0,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/11/11</i>.</small>")
gcd_emboss : -skip ${1=128}
  -repeat $! -l[$>]
    --norm --bilateral[0] 2%,30 -norm[-1] --[-2,-1]
    --n[0] 0,255 -median[-1] 3 -bilateral[-1] 2%,30
    -gcd_srgb2luma[-1] --[-1] $1
    --abs[-1] -negate[-1]
    --max[-2] 0 -min[-3] 0 -abs[-3]
    -pde_flow[1] 20,7,iee
    --n[-3] 0,2 -*[-1] [1] -+[0,-1]
    --n[-1] 0,2 -*[-1] [1] -+[0,-1]
    --n[-2] 0,2 -*[-1] [1] -+[0,-1]
    -+[0,2] --[0,3] -k[0]
    -gcd_srgb2luminance -c 0,255
  -endl -done

gcd_emboss_preview :
  -gui_split_preview "-gcd_emboss ${1--2}",$-1

#@gui Image InfoMap: gcd_infomap, gcd_infomap(1)
#@gui : note = note("<i>View images in various informational ways</i>"), sep = separator()
#@gui : Output = choice("Spectral tones","Detail map","JPEG CbCr detail","Local equality","Standard score")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/09/26</i>.</small>")
gcd_infomap :
  -repeat $! -l[$>] -to_rgb
    -if {$1>3} gcd_std_score_patch 3 n 0,255
    -elif {$1>2}
      --dilate 3 --erode.. 3 -eq[-2,-1] -compose_channels. min
      -orientation.. -* -n 0,255
    -elif {$1>1} -gcd_srgb2jpeg -channels 1,2 -equalize 256 -gcd_detail
    -elif {$1} -gcd_detail -else -gcd_spectral -endif
  -endl -done

gcd_detail :
  -repeat $! -l[$>] --bilateral 2%,30 -norm -- -n 0,255 -endl -done

gcd_spectral :
  -repeat $! -l[$>]
    -to_rgb -gcd_srgb2luma -- 128
    --max 0 --min[0] 0 -abs[^-2] -negate[0] -a c -n 0,255
  -endl -done

gcd_std_score_patch : skip ${1=3}
  repeat $! l[$>]
    +gcd_variance_patch $1 sqrt.
    +boxfilter.. $1 sub[0,-1] +eq. 0 add[-2,-1] div
  endl done

gcd_variance_patch : skip ${1=3}
  repeat $! l[$>] +sqr boxfilter $1 sqr.. rv sub max 0 endl done

#@gui Layer Manipulation: gcd_layers, gcd_layers_preview(1)
#@gui : note = note("\n<i>Transform</i>"), sep = separator()
#@gui : Scale = float(100,1,200)
#@gui : Angle = int(0,-90,90)
#@gui : Reduce Only (Requires Two Layers) = bool(1)
#@gui : note = note("\n<i>Position</i>"), sep = separator()
#@gui : CentreX = float(0,-50,50)
#@gui : CentreY = float(0,-50,50)
#@gui : note = note("\n<i>Edges</i>"), sep = separator()
#@gui : Erode = float(0,0,50)
#@gui : Smooth = int(0,0,25)
#@gui : Curvature (Instead of Gaussian) = bool(0)
#@gui : note = note("\n<i>Layer</i>"), sep = separator()
#@gui : Opacity = float(1,0,1)
#@gui : Mode = choice{"Normal","Add","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Grain Extract","Grain Merge","Hard Light","Hue","Lighten",
#@gui : "Multiply","Overlay","Saturation","Soft Light","Screen","Subtract","Value"}
#@gui : Flip = choice("None","Horizontal","Vertical","Both")
#@gui : Match Lower Layer Size = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/06/05</i>.</small>")
#@gui : note = note("\n<small><b>Note:</b> preview is low quality for speed</small>")
gcd_layers : -skip ${1=100},${2=0},${3=1},${4=50},${5=50},${6=0},${7=0},${8=0},${9=1},${10=1},${11=0},${12=0},${13=0}
  one={$!<2}
  -l[${-arg\ 1+$one,0-1,0}]
    -if {$3" && "!$one" && "$1>100} -r2dx. {w/$1%},{if($-1,2,6)} -c. 0,255 -endif # ** SCALE
    w={w} h={h} -gcd_force_a[0]
    -l[0]
      -if {$11} -mirror ${-arg\ $11,x,y,xy} -endif # FLIP
      -if {!$3" || "$one" || "$1<100} -r2dx {w*$1%},{if($-1,2,6)} -c 0,255 -endif # ** SCALE
      -if {$2} -split_opacity -rotate. $2,{2-($-1)} -rotate.. $2,{2-($-1)},1 -a c -c 0,255 -endif # ** ROTATE
      -if {$6" || "$7} # ** ERODE/SMOOTH
        -sh 100% --gt. 1 -expand_xy. 1,0 -distance. 0 -gt. {1+$6}% -shrink_xy. 1
        -*. .. -if {$8" && "$7} -pde_flow. $7,30,iee,0 -max. 0 -endif -min[-2,-1] -rm.
      -endif
      -if {!$8" && "$7} -sh 100% -b. {$7/10}%,1,{!$-1} -rm. -endif
    -endl
    pos={round(($w-w#0)/2+$w*$4%)},{round(($h-h#0)/2-$h*$5%)} # ** POSITION
    -if {$-1" || "$12} -i[0] $w,$h,1,{0,s} -j[0] [1],$pos -rm[1] pos=""
    -else pos=,pos($pos) -endif
    mode=${-arg\ 1+$10,alpha,add,burn,darken,difference,\
    divide,dodge,grainextract,grainmerge,hardlight,hue,lighten,\
    multiply,overlay,saturation,softlight,screen,subtract,value}
    -if {$-1} -if {$!>1} -rv -blend $mode,$9 -else -sh 100% -*. $9 -rm. -endif
    -else -nm[0] mode($mode),opacity({$9*100})$pos -endif # ** OPACITY
  -endl

gcd_layers_preview :
  -gcd_layers $*,1

#@gui Recolor : gcd_recol, gcd_recol(1)
#@gui : note = note("<i>Apply colors to a black and white image</i>"), sep = separator()
#@gui : Min Hue Drift = int(-14,-45,0)
#@gui : Max Hue Drift = int(14,0,45)
#@gui : sep = separator(), note = note("<b>Note :</b> This filter needs two layers to work properly.")
#@gui : note = note("<small>Original Author : <i>David Tschumperl&#233;</i></small>")
#@gui : note = note("<small>Adapted by : <i>Garagecoder</i>.   Latest update: <i>2013/01/16</i>.</small>")
gcd_recol :
  -repeat {int($!/2)} -l[$>,{$>+1}]
    -rv[-2,-1]
    -channels[-2] 0 -to_rgb[-2] # -2=b&w -1=cols\RGBA
    -to_rgba[-1] -split_opacity[-1] -neq[-1] 0  # -3=b&w\RGB -2=cols\RGB -1=mask\L
    -srgb2rgb[-3,-2] -rgb2lab8[-3,-2] -channels[-3] 0 -channels[-2] 1,2 # -3=b&w\L -2=cols\AB -1=mask\L
    -+[-2] 1 -*[-2] [-1]
    --meancurvature_flow[-3] 3 -median[-1] 3
    -gradient_norm[-1] -*[-1] -1 -watershed[-3] [-1] -rm[-1] --[-2] 1
    # cols=(cols+1)*mask, wshed with b&w-gnorm*-1 -3=b&w\L -2=wshedcols\AB -1=mask\L
    -rm[-1] -a[-2,-1] c -lab82rgb[-1] -rgb2srgb[-1]
    -rgb2hsv[-1] -s c --equalize[2] 512 -n[-1] $1,$2 -+[0,-1] -%[0] 360 -a c -hsv2rgb[-1] #stretch hues
  -endl -done

#@gui Sharpen [Gradient]: gcd_sharpen_gradient, gcd_sharpen_gradient_preview(1)
#@gui : note = note("<i>Sharpen areas with low detail</i>"), sep = separator()
#@gui : Amount = float(0.5,0,2)
#@gui : Scale = float(2,0.1,2)
#@gui : Values = choice("cut","normalize luma")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/09/28</i>.</small>")
gcd_sharpen_gradient : -skip ${1=0.5},${2=2},${3=0}
  -repeat $! -l[$>]
    -split_opacity
    --norm[0] --bilateral[0] $2%,30 -norm[-1] --[-2,-1]
    --gradient_norm[0] -negate[-1] -n[-1] 0,$1 -*[-2,-1] -+[0,-1]
    -if {$3} -ac[0] "-n 0,255",ycbcr_y -else -c[0] 0,255 -endif
    -a c
  -endl -done

gcd_sharpen_gradient_preview :
  -gui_split_preview "-gcd_sharpen_gradient ${1--2}",$-1

#@gui Sharpen [Tones]: gcd_sharpen_tones, gcd_sharpen_tones_preview(1)
#@gui : note = note("<i>Sharpen shadows and highlights</i>"), sep = separator()
#@gui : Amount = float(1,0,4)
#@gui : Centre = int(128,0,255)
#@gui : Values = choice("cut","normalize luma")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/09/28</i>.</small>")
gcd_sharpen_tones : -skip ${1=1},${2=128},${3=0}
  -repeat $! -l[$>]
    -split_opacity
    --norm[0] --bilateral[0] 2%,30 -norm[-1] --[-2,-1]
    --gradient_norm[0] -n[-1] 0,1 -oneminus[-1] -*[-2,-1]
    --n[0] 0,255 -median[-1] 3 -bilateral[-1] 2%,30
    -gcd_srgb2luma[-1] --[-1] $2
    --max[-1] 0 -min[-2] 0 -abs[-2]
    -n[-2,-1] 0,$1 -*[-2,-1] [-3] -rm[-3] -+[0,-2,-1]
    -if {$3} -ac[0] "-n 0,255",ycbcr_y -else -c[0] 0,255 -endif
    -a c
  -endl -done

gcd_sharpen_tones_preview :
  -gui_split_preview "-gcd_sharpen_tones ${1--2}",$-1

#@gui Smart Rotate : gcd_srotate, gcd_srotate(1)
#@gui : note = note("<u>Rotate an image and extrapolate the corners</u>")
#@gui : note = note("\n<i>Rotation Options</i>"), sep = separator()
#@gui : Angle = int(0,-90,90)
#@gui : Centrex = int(50,0,100)
#@gui : Centrey = int(50,0,100)
#@gui : note = note("\n<i>Quality Options</i>"), sep = separator()
#@gui : Interpolation = choice(1,"Linear","Bicubic")
#@gui : Inpainting = choice(1,"Low","Normal","High","Ultra")
#@gui : Lookup Scale = int(6,1,16)
#@gui : Lookup Factor = float(0.6,0.2,2)
#@gui : Seamless = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/12/05</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>* Dimensions are not altered</small>")
#@gui : note = note("<small>* Quality settings affect speed!</small>")
#@gui : note = note("<small>The preview is a rough guide only.  Images with simple edges tend to work best.</small>")
#@gui : note = note("<small>Results can be improved by selecting a higher inpainting quality, but processing will take longer.</small>")
#@gui : note = note("<small>Select seamless to reduce visible seams at the corners.</small>")
gcd_srotate : -skip ${1=0},${2=50},${3=50},${4=1},${5=1},${6=6},${7=0.6},${8=0}
  -repeat $! -l[$>]
    -rotate $1,{$4+1},1,$2%,$3% -c 0,255 -split_opacity
    -l[0]
      {w},{h},1,1,1 -rotate[-1] $1,0,0,$2%,$3%
      -eq[-1] 0 --area[-1] 0 -*[-1] [-2]
      ps={max(round(iM^0.5/6),4)} -rm[-1]
      -if $8
        --inpaint[0] [-1],$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08
        -rv[-2,-1] -a[-2,-1] c -blend_seamless 0,0,25%
      -else
        -inpaint[0] [-1],$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08 -rm[-1]
      -endif
    -endl -a c
  -endl -done

#@gui Split Objects : gcd_splitobj, gcd_splitobj_preview(1)
#@gui : note = note("<u>Extract objects from an image to a new layer</u>")
#@gui : note = note("<small>1. Create a new transparent layer, mark background red and objects green</small>")
#@gui : note = note("<small>2. Set Input layers to <b>Active &amp; below</b>, objects will be split to two layers</small>")
#@gui : note = note("\n<i>Edge Detection Options</i>"), sep = separator()
#@gui : Alpha Min = int(50,0,100)
#@gui : Edge Flow = int(3,0,20)
#@gui : Median = int(3,0,7)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Swap Layers = bool(0)
#@gui : Grow Alpha = int(0,-20,20)
#@gui : Blur Alpha = int(0,0,20)
#@gui : Opacity = int(40,0,100)
#@gui : Inpainting = choice(0,"Off","Low","Normal","High","Ultra")
#@gui : Is Preview = value(0)
#@gui : sep = separator(), note = note("<b>Note :</b> This filter needs two layers to work properly.")
#@gui : note = note("<small>Author : <i>Garagecoder</i>.   Latest update: <i>2016/01/22</i>.</small>")
gcd_splitobj : -skip ${1=50},${2=3},${3=3},${4=0},${5=0},${6=0},${7=40},${8=0},${9=0}
  -if {$!<2} -return -endif
  -repeat {int($!/2)} -l[$>,{$>+1}]
    -if {w!={0,w}" || "h!={0,h}} -continue -endif
    -to_rgba [-1] -s[1] c,-3 -ge[2] $1% -luminance[1]
    -meancurvature_flow[1] $2 -median[1] $3 -*[1,2]
    -channels[0] 0,1 -s[0] c -gt[0,1] 50% -*[{$4!=0}] 2 -+[0,1]
    -gradient_norm[1] -*[1] -1 -watershed[0] [1] --[0] 1 -rm[1]
    -if {$5>0} -erode[0] $5 -elif {$5<0} -dilate[0] {abs($5)} -endif
    -if $6 -b[0] $6,1,1 -c[0] 0,1 -endif
    [1] -sh[-1] 3,3 -*[-1] [0] -rm[-1] -oneminus[0]
    -if {$8>0}
      -le[0] 80% --area[0] 0 -*[-1] [0]
      ps={max(round(iM^0.5/6),4)} -rm[-1] -n[0] 0,255
      -inpaint[1] [0],$ps,{$ps*6},1,{9-$8*2},{$ps*1.2},0,0.08,10,1
    -else -sh[1] 3,3 -*[-1] [0] -rm[-1] -endif
    -rm[0] -gcd_fix_alpha -nm[1] opacity($7)
    -if {$9} -blend alpha,{$7/100} -endif
  -endl -done

gcd_splitobj_preview :
  -gcd_splitobj ${1--2},1

#@gui Stereo Video : gcd_stereo_vid, gcd_stereo_vid_preview(1)
#@gui : note = note("<u>Convert a series of image files to 3D</u>")
#@gui : note = note("\n<i>File Options</i>"), sep = separator()
#@gui : Start Image = file()
#@gui : End Image = file()
#@gui : Output Folder = _folder()
#@gui : note = note("\n<i>3D Options</i>"), sep = separator()
#@gui : 3D Image Type = choice("Anaglyph: Red/Cyan","Side by Side","Depth Map","Inverse Depth Map")
#@gui : Balance Color = float(0.5,0,1)
#@gui : Depth = float(1.2,0,2)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Despeckle = bool(1)
#@gui : note = note("\n<i>Video Options</i>"), sep = separator()
#@gui : Frame Buffer = _int(5,1,10)
#@gui : Scene Detection = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/07/02</i>.</small>")
gcd_stereo_vid :
  1 -l[-1]

  -i "$1" st_folder={f} st_file={b} st_ext={x} ({'$st_file'}) cpx={w}
  -do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} -while {($isnum)&&($cpx>0)}
  -if {$cpx>0} --z[-1] 0,$cpx fsname={t} -rm[-1] -else fsname="" -endif
  -z[-1] {$cpx+{!$isnum}},100% dgts={w} fsnum={{t}} -rm[-1]

  1 -nm[-1] "$2" en_file={b} ({'$en_file'}) cpx={w}
  -do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} -while {($isnum)&&($cpx>0)}
  -z[-1] {$cpx+{!$isnum}},100% fenum={{t}} -rm[-2,-1]

  bufsz=$11 ttlbuf={$bufsz*2} ttlimg={$fenum-$fsnum+1}
  scene=1 scframe=0 ov={iv} oa={ia}

  -repeat {$ttlimg}
    -if {$scene" && "$>==$scframe}
      -k[-1] scene=0
      -repeat {min($ttlbuf,$ttlimg-$scframe-1)}
        curnum={$fsnum+$scframe+$>+1} curnum=${-gcd_add0\ $curnum,$dgts}
        -i ""${st_folder}${fsname}${curnum}.${st_ext}""
        vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
        ov=$vr oa=$av
        -if {$12&&($pvr>0.1" || "$pav>0.1)} scene=1 scframe={$scframe+$>+1} -break
        -endif
      -done
      #sum of depths in [0], depths in [1], images in [2]
      --l[0--{1+$scene}] -ap "-gcd_depth $7,$8,$9,$10" --add[0--1] -a[0--2] z -endl
      -mv[-1] 0 -mv[-1] 1 -a[2--{1+$scene}] z
    -endif

    --slices[2] 0 --div[0] {1,d} -gcd_stereo[-2,-1] $4,$5,$6%

    curnum={$fsnum+$>} curnum=${-gcd_add0\ $curnum,$dgts}
    -if ${-is_windows} -o[-1] "$3"""{`92`}${fsname}${curnum}.${st_ext}""
    -else -o[-1] "$3"""{`47`}${fsname}${curnum}.${st_ext}"" -endif
    -progress {($>+1)/$ttlimg*100}

    -rm[-1] -slices[2] 1,100%

    -if {!$scene" && "($>>=($scframe+$bufsz))" && "($><($ttlimg-$bufsz-1))}
      curnum={$fsnum+$>+$bufsz+1} curnum=${-gcd_add0\ $curnum,$dgts}
      -i ""${st_folder}${fsname}${curnum}.${st_ext}""
      vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
      ov=$vr oa=$av
      -if {$12&&($pvr>0.1" || "$pav>0.1)} scene=1 scframe={$>+$bufsz+1}
      -else
        --gcd_depth[-1] $7,$8,$9,$10 -add[0] [-1] -a[1,-1] z -a[2,-1] z
        --slices[1] 0 -sub[0,-1] -slices[1] 1,100%
      -endif
    -endif
  -done
  -rm
  -endl

gcd_stereo_vid_preview : -skip "${1=}","${2=}"
  -l -i "$1" -onfail 100,100,1,3,0 -text[-1] "Select\nStart\nImage   ",0,0,32,1,255 -endl
  -l -i "$2" -onfail 100,100,1,3,0 -text[-1] "Select\nEnd\nImage   ",0,0,32,1,255 -endl
  -k[-2,-1] -a[0,1] x -to_rgb[0] --gcd_depth[-1] $7,$8,$9,$10 -gcd_stereo $4,$5,$6%

gcd_add0 :
  ({'"$1"'}) -if {w<$2} {$2-w},1,1,1,48 -rv[-2,-1] -a[-2,-1] x -endif -u {t} -rm[-1]

#@gui Temperature Balance: gcd_temp_balance, gcd_temp_balance(1)
#@gui : note = note("<i>Auto-detect lighting and adjust color temperature</i>"), sep = separator()
#@gui : Saturation = float(0,-1,1)
#@gui : Level = float(0,-1,1)
#@gui : Color = float(1,0,2)
#@gui : Lighting = choice("Automatic","Automatic [Scan All Hues]","Standard [No Scan]")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/08/30</i>.</small>")
gcd_temp_balance : -skip ${1=0},${2=0},${3=1},${4=0}
  -repeat $! -l[$>]
    -split_opacity -to_rgb[0] --gcd_srgb2luma[0]
    -if {$4<2}
      m={if($4,360,90)} $m,1,1,1 --r[0] 32,32,100%,100%,2
      -repeat $m --gcd_hue_level. $> -=... {ia},$> -rm. -done
      -rm. h={xM} -rm.
    -else h=39 -endif
    -if {$2!=0}
      --l[0] -sh[0] 0 -sh[0] 1 -sh[0] 2
        ({$h%360}^1^1) -hsv2rgb. -max. 0 -*. $2 --. {ia}
        -+[-4] {@0} -+[-3] {@1} -+[-2] {@2} -rm[-4--1] -max[0] 0
      -endl
      --compose_channels[0] max -n. 0,1
      -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
    -endif
    -gcd_hue_chroma[0] $h,{($1+1)*$3},$3
    -gcd_srgb2jpeg[0] -j[0] [-1] -rm.
    -gcd_jpeg2srgb[0] -round 1 -a c -c 0,255
  -endl -done

gcd_hue_level : -skip ${1=0}
  -repeat $! -l[$>]
    h={($1%360)/60} x={1-abs($h%2-1)} y={if($x>0,1/$x,0)} h={int($h)+1}
    p={arg($h,0,1,1,2,2,0)} s={arg($h,1,0,2,1,0,2)} z={arg($h,2,2,0,0,1,1)}
    -sh. $p -sh.. $s --*.. $x
    --le. [-2] -j[-3] [-2],0,0,0,0,1,[-1] -rm..
    -eq. 0 --*.. $y -j[-4] [-1],0,0,0,0,1,[-2]
    -rm[-4--1] -sh. $z -f. 0 -rm.
  -endl -done

#@gui Unquantize [JPEG Smooth]: gcd_unquantize, gcd_unquantize(0)
#@gui : note = note("<u>Remove quantization artifacts</u>")
#@gui : note = note("<small>1. Preview will <b>not</b> show the final result accurately.</small>")
#@gui : note = note("<small>2. Be sure to apply <b>before</b> any image resizing.</small>")
#@gui : note = note("\n<i>Block Smoothing Options</i>"), sep = separator()
#@gui : Iterations = int(6,0,8)
#@gui : Preserve Edges = float(1,0,1)
#@gui : Color Channels = bool(1)
#@gui : note = note("\n<i>Anti-Aliasing Options</i>"), sep = separator()
#@gui : Iterations = int(5,0,30)
#@gui : Threshold = int(15,1,200)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/04/29</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Useful for removal of common compression and rescaling artifacts.</small>")
#@gui : note = note("<small>* If a specific glitch remains, try reducing edge preservation.</small>")
#@gui : note = note("<small>* For AA only set Block Iterations to 0.</small>")
gcd_unquantize : -skip ${1=6},${2=1},${3=1},${4=5},${5=15}
  -repeat $! -l[$>]
    -gcd_srgb2jpeg -s c
    -if {$1>0}
      --edges[0] 14.5% -n[-1] {1-$2},1
      -if {$3" && "$!>2}
        -a[1,2] c --apply_parallel_overlap[1] "-median 5",3
        -j[1] [-1],0,0,0,0,1,[-2] -rm[-1]
      -endif
      {w},{h},1,1,0 -grid[-1] 8,8,0,0,1,1 -grid[-1] 8,8,-1,-1,1,1
      -b[-1] 1,0 -*[-2,-1] -n[-1] 0,1 --pde_flow[0] $1,30,iee,0
      -j[0] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
    -endif
    -if {$4>0}
      --median[0] 3 -sub[-1] [0]
      -abs[-1] -ge[-1] $5
      -dilate[-1] 3 -n[-1] 0,1
      --apply_parallel_overlap[0] "-pde_flow "$4",7,iee,0",8
      -j[0] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
    -endif
    -a c -gcd_jpeg2srgb -c 0,255
  -endl -done

#@gui Warp Map: gcd_warpmap, gcd_warpmap(1)
#@gui : note = note("<i>Warp an image using another as a surface</i>"), sep = separator()
#@gui : Depth = float(5,0,20)
#@gui : Detail = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Blend Mode = choice("Warp","Multiply","Softlight","None")
#@gui : Swap Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>The top layer will be warped using the bottom layer as a surface.</small>")
#@gui : note = note("<small>\nDepth: Set the apparent depth of the surface.</small>")
#@gui : note = note("<small>Detail: Perform second warp with no smooth for fine detail.</small>")
#@gui : note = note("<small>Smooth: Set low for emboss, high to wrap around large objects.</small>")
gcd_warpmap : -skip ${1=5},${2=0},${3=0},${4=0},${5=0}
  -repeat {int($!/2)} -l[$>,{$>+1}]
    -if $5 -rv -endif
    -if {$4==3} bm=0 -i[0] [-1] -else bm=$4 -endif
    -if $2 --gcd_warp[-2,-1] $1,$3 -rm[-3] -rv[-2,-1] -gcd_warp[-2,-1] $2,0,$bm
    -else -gcd_warp[-2,-1] $1,$3,$bm -endif
    -if {$4==3} -rv -endif
  -endl -done

gcd_warp : -skip ${1=5},${2=0},${3=0} # params: max_warp, smooth, blend_type (currently warp/mult/softlight)
  -repeat {int($!/2)} -l[$>,{$>+1}]
    wfac={$1%*w} -to_rgba[-2,-1] --norm[-1]  # 0=img to warp 1=surface 2=b&w of surface
    -blur_xy[-1] $2%,$2% -n[-1] 0,255 -g[-1] xy -a[-2,-1] c # change 2 into warp field using gradient
    -*[-1] -1 -n[-1] -$wfac,$wfac -warp[0] [-1],1 -rm[-1] # set warp range, warp image 0
    -if {$3==0} -rm[-1] -break -endif # discard surface and exit if blend mode=warp
    -if {$3==1} -blend multiply,1,1 -else -blend softlight,1,1 -endif
  -endl -done

#@gui Wiremap: gcd_wiremap, gcd_wiremap(1)
#@gui : note = note("<i>Turn an image into a wireframe map</i>"), sep = separator()
#@gui : Segments = int(100,4,400)
#@gui : Depth = int(100,4,400)
#@gui : Smoothness = float(0.5,0,2)
#@gui : Distance = float(0.5,-2,2)
#@gui : Output = choice("Black &amp; White","Color","Transparent Black &amp; White","Transparent Color")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/01/27</i>.</small>")
#@gui : note = note("<small>\n<b>Warning:</b> can be extremely slow with high segments!</small>")
#@gui : note = note("<small>Lower layer will be used for color if available.</small>")
gcd_wiremap : -skip ${1=100},${2=100},${3=0.5},${4=0.5},${5=0}
  dm={$!>1" && "$5%2}
  -l[${-arg\ 1+$dm,0,0-1}]
    -if {$dm} op=0
      -if {s==2||s==4} -split_opacity. -rv[^0] op=1 -remove_opacity[0]
      -elif {0,s==2||s==4} -split_opacity[0] op=1 -endif
    -else -split_opacity op={$!>1} -endif
    --norm[0] -b. $3% -n. 0,$2 -*. -1 w={w/2} h={h/2}
    -r. $1,{round(h/w*$1)},1,3,2 v={w*h} p={(w-1)*h+(h-1)*w} ln={h}
    -sh. 0 -f. x -n. -$w,$w -rm.
    -sh. 1 -f. y -n. -$h,$h -rm. -permute. cxyz -y.
    (67.5;73.5;109.5;103.5;51.5;100.5) # CImg3d
    ($v;$p) # number of vertices, primitives

    # primitive type, vert. index
    {($1-1)*2},$ln,1,1,if(x%2,-1,2) {($1-1)*2},$ln,1,1,"y*$1+round(x/2)"
    -a[-2,-1] c -permute. cxyz -discard. -1

    {($ln-1)*2},$1,1,1,if(x%2,-1,2) {($ln-1)*2},$1,1,1,"round(x/2)*$1+y"
    -a[-2,-1] c -permute. cxyz -discard. -1 -a[-2,-1] y

    -if {$5%2} # colour
      --r[{$dm?$dm+$op:0}] $1,{0,round(h/w*$1)},1,3,3 --z. 0,0,100%,{h-2}
      -permute. cyxz -z.. 0,0,{-2,w-2},100% -permute.. cxyz -y[-2,-1] -a[-2,-1] y
    -else 1,{$p*3},1,1,255 -endif

    -if {$op} # opacity
      --r[1] $1,{0,round(h/w*$1)},1,1,3 -gt. 1 --z. 0,0,100%,{h-2} -permute. cyxz
      -z.. 0,0,{-2,w-2},100% -permute.. cxyz -y[-2,-1] -a[-2,-1] y -rm[1]
    -else 1,$p,1,1,1 -endif

    -mv[-6] -3 -a[-6--1] y
    -if {$5>1} # transparent
      -f[0] 0 -to_a[0] -sh[0] 100% -f. 255
      -j3d[0] [-2],50%,50%,{$2*$4},1,1,1,0 -negate. -rm[-2,-1]
    -else -f[0] 0 -j3d[0] [-1],50%,50%,{$2*$4},1,1,1,0 -rm. -endif
  -endl

#@gui Xbr2x: gcd_xbr2x, gcd_xbr2x(1)
#@gui : note = note("Implementation of the xBR 2x [noblend] algorithm by Hyllian.")
##@gui : note = note("For more info visit: "), note = link("http://board.byuu.org/viewtopic.php?f=10&t=2248")
#@gui : note = link("http://code.google.com/p/2dimagefilter/wiki/ImageResizer")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.  Latest update : <i>2013/05/29</i>.</small>")
#@gui : note = note("<small>Disclaimer : This is a near complete recode based on C# source from ImageResizer</small>")
#@gui : note = note("<small>The results may not fully represent the original routine!</small>")
gcd_xbr2x :
-repeat $! -l[$>] -to_rgb[0]
  (-1,-1;0,-1;1,-1;-1,0;0,0;1,0;-1,1;0,1;1,1;\
  -1,-2;0,-2;1,-2;-2,-1;-2,0;-2,1;2,-1;2,0;2,1;-1,2;0,2;1,2)
  pa_=0 pb_=1 pc_=2  pd_=3 pe_=4 pf_=5  pg_=6 ph_=7 pi_=8
  a1_=9 b1_=10 c1_=11  a0_=12 d0_=13 g0_=14
  c4_=15 f4_=16 i4_=17  g5_=18 h5_=19 i5_=20
  e0=21 e1=22 e2=23 e3=24
  ($pe_,$pi_,$ph_,$pf_,$pg_,$pc_,$pd_,$pb_,$f4_,$i4_,$h5_,$i5_,$e1,$e2,$e3;\
  $pe_,$pc_,$pf_,$pb_,$pi_,$pa_,$ph_,$pd_,$b1_,$c1_,$f4_,$c4_,$e0,$e3,$e1;\
  $pe_,$pa_,$pb_,$pd_,$pc_,$pg_,$pf_,$ph_,$d0_,$a0_,$b1_,$a1_,$e2,$e1,$e0;\
  $pe_,$pg_,$pd_,$ph_,$pa_,$pi_,$pb_,$pf_,$h5_,$g5_,$d0_,$g0_,$e3,$e0,$e2)
  -*[1] -1
  -repeat 21 --shift[0] {1,round(i(0,$>))},{1,round(i(1,$>))},0,0,1 -done
  [0] [0] [0] [0]
  -nm[0] orig -mv[0] $! -rm[0] -nm[0] kern -mv[0] $!
  -repeat 4
    pe={kern,i(0,$>)}  pi={kern,i(1,$>)}  ph={kern,i(2,$>)}
    pf={kern,i(3,$>)}  pg={kern,i(4,$>)}  pc={kern,i(5,$>)}
    pd={kern,i(6,$>)}  pb={kern,i(7,$>)}  f4={kern,i(8,$>)}
    i4={kern,i(9,$>)}  h5={kern,i(10,$>)} i5={kern,i(11,$>)}
    n1={kern,i(12,$>)} n2={kern,i(13,$>)} n3={kern,i(14,$>)}
    #compare centre pixel to right/below, create lvl1 mask
    --gcd_eq[$pe,$pf] --gcd_eq[$pe,$ph] -or[-2,-1] -eq[-1] 0 -nm[-1] lvl1
    #get red/blue distances
    --gcd_yuv[$pe,$pc] --gcd_yuv[$pe,$pg] -+[-2,-1]
    --gcd_yuv[$pi,$h5] -+[-2,-1] --gcd_yuv[$pi,$f4] -+[-2,-1]
    --gcd_yuv[$ph,$pf] -*[-1] 4 -+[-2,-1]
    -nm[-1] red
    --gcd_yuv[$ph,$pd] --gcd_yuv[$ph,$i5] -+[-2,-1]
    --gcd_yuv[$pf,$i4] -+[-2,-1] --gcd_yuv[$pf,$pb] -+[-2,-1]
    --gcd_yuv[$pe,$pi] -*[-1] 4 -+[-2,-1]
    -nm[-1] blue
    #take colour from closest match between centre and right/below
    --gcd_yuv[$pe,$pf] --gcd_yuv[$pe,$ph] -le[-2,-1]
    --image[$ph] [$pf],0,0,0,0,1,[-1] -nm[-1] px -rm[-2]
    #If (red<blue)&&((pf!=i4)&&(ph!=i5)&&(pe==pi)||(pf!=pb)&&(ph!=pd)||(pe==pg)||(pe==pc))
    --lt[red,blue]
    --gcd_neq[$pf,$i4] --gcd_neq[$ph,$i5] -and[-2,-1] --gcd_eq[$pe,$pi] -and[-2,-1]
    --gcd_neq[$pf,$pb] --gcd_neq[$ph,$pd] -and[-2,-1] -or[-2,-1]
    --gcd_eq[$pe,$pg] -or[-2,-1] --gcd_eq[$pe,$pc] -or[-2,-1]
    -and[-2,-1] -nm[-1] lvl2
    #level 2 interp
      --gcd_yuv[$pf,$pg] -nm[-1] lver # left vertice dist
      --gcd_yuv[$ph,$pc] -nm[-1] uver # upper vertice dist
      #If 2lv<=uv AND pe,pd != pg THEN Left2X(n3,n2,px)
      --*[lver] 2 -le[-1] [uver]
      --gcd_neq[$pg,$pe] --gcd_neq[$pg,$pd] -and[-2,-1]
      -and[-2,-1] -and[-1] [lvl2] -image[$n3] [px],0,0,0,0,1,[-1]
      #If 2uv<lv AND pe,pb != pc THEN Up2X(n3,n1,px)
      --*[uver] 2 -lt[-1] [lver]
      --gcd_neq[$pc,$pe] --gcd_neq[$pc,$pb] -and[-2,-1]
      -and[-2,-1] -and[-1] [lvl2] -image[$n3] [px],0,0,0,0,1,[-1]
      #ELSE Dia2X(n3,px) - not relevant for noblend
      #-or[-2,-1] -eq[-1] 0
      -rm[-2,-1,lver,uver]
    #else if red<=blue blend - not relevant for noblend
    #-eq[lvl2] 0 -and[lvl1,lvl2] --le[red,blue] -and[lvl1,-1]
    #blend pixel using lvl1 mask
    #-image[$n3] [px],0,0,0,0,0,[lvl1]
    -rm[red,blue,lvl1,lvl2,px] #cleanup
  -done
  #render scaled image
  {orig,w},{orig,h},1,1,1 -r2dx[-1] {orig,w*2},4 -nm[-1] msk
  -r2dx[orig,$e0,$e1,$e2,$e3] {orig,w*2},1
  -image[orig] [$e0],0,0,0,0,1,[msk] -shift[msk] 1
  -image[orig] [$e1],0,0,0,0,1,[msk] -shift[msk] -1,1
  -image[orig] [$e2],0,0,0,0,1,[msk] -shift[msk] 1
  -image[orig] [$e3],0,0,0,0,1,[msk]
  -k[orig]
-endl -done

gcd_eq : -l[-2,-1] --[-2,-1] -norm[-1] -eq[-1] 0 -endl
gcd_neq : -l[-2,-1] --[-2,-1] -norm[-1] -neq[-1] 0 -endl
gcd_yuv : -l[-2,-1] --[-2,-1] -abs[-1] -rgb2yuv[-1] -abs[-1] -s[-1] c -*[-3] 48 -*[-2] 7 -*[-1] 6 -+[-3--1] -endl

#@gui JPEG Smooth : gcd_jpeg_smooth, gcd_jpeg_smooth_preview(0)
#@gui : note = note("<i>Quick JPEG cleanup for moderate compression glitches</i>")
#@gui : sep = separator()
#@gui : Compression Filter = bool(1)
#@gui : Anti Alias = bool(1)
#@gui : Quick Enlarge = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_jpeg_smooth : -skip ${1=1},${2=1},${3=0}
  -repeat $! -l[$>]
    -if $1 -gcd_comp_blur[-1] 2,3,1,100,1 -endif
    -if $3 -r[-1] 140%,140%,1,3,5 -c[-1] 0,255 -endif
    -if $2 -gcd_anti_alias[-1] 10,0.3,10 -endif
  -endl -done

gcd_jpeg_smooth_preview :
  -gui_split_preview "-gcd_jpeg_smooth ${1--2}",$-1

#@gui Compression Blur : gcd_comp_blur, gcd_comp_blur_preview(0)
#@gui : note = note("<i>For subtle smoothing of compression artifacts</i>")
#@gui : sep = separator(), note = note("<small>1. Preview will <b>not</b> show the final result accurately.</small>")
#@gui : note = note("<small>2. Be sure to apply <b>before</b> any image resizing.</small>")
#@gui : note = note("<small>3. Reduce grid width when increasing divisions to avoid over-smoothing.</small>")
#@gui : note = note("<small>4. Set grid divisions to zero for 100% smoothing.\n</small>")
#@gui : sep = separator()
#@gui : Grid Divisions = int(2,0,3)
#@gui : Grid Width = int(3,1,3)
#@gui : Grid Smoothing = float(1,0,1)
#@gui : Preserve Edges = int(100,0,100)
#@gui : Colour Channels = bool(1)
#@gui : Boost Smooth = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/05/15</i>.</small>")
gcd_comp_blur : -skip ${1=2},${2=3},${3=1},${4=100},${5=1},${6=0}
  gsz={2^(5-$1)}
  -repeat $! -l[$>]
    -remove_opacity[-1]
    --to_gray[0] -edges[-1] 14.5% -n[-1] {100-$4}%,100%
    -if {0,s>1" && "$5}
      --ac[0] "-median 5",ycbcr_cbcr
      -image[0] [-1],0,0,0,0,1,[-2] -rm[-1]
    -endif
    -if {$1==0} {w},{h},1,1,255 -mul[-2,-1] -else
      {w},{h},1,1,0
      -grid[-1] $gsz,$gsz,0,0,1,255
      -if {$2>=2} -grid[-1] $gsz,$gsz,1,1,1,255 -endif
      -if {$2==3} -grid[-1] $gsz,$gsz,-1,-1,1,255 -endif
      -blur[-1] $3,0 -mul[-2,-1]
    -endif
    -i[-2] [0] -append[-2,-1] c
    -smooth[1] {100*$6+100},0.6,0.3
    -blend[0,1] alpha
    -if {!$6} -sharpen[-1] 20 -endif
  -endl -done

gcd_comp_blur_preview :
  -gui_split_preview "-gcd_comp_blur ${1--2}",$-1

#@gui Anti Alias : gcd_anti_alias, gcd_anti_alias_preview(0)
#@gui : note = note("<i>Selectively smooth resizing pixelation</i>"), sep = separator()
#@gui : Smooth Amount = int(60,0,200)
#@gui : Edge Exponent = float(0.3,0,10)
#@gui : Lighten Edges = int(50,0,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_anti_alias : -skip ${1=10},${2=0.3},${3=10}
  -repeat $! -l[$>]
    -remove_opacity[-1]
    --smooth[0] $1,0,1,1.6,1.1,0.8,30,0.6
    --gradient_norm[0] --n[-1] 0,$3 -add[0,-1]
    -pow[-1] $2 -n[-1] 0,255
    --gradient_norm[-1] -pow[-1] $2 -n[-1] 0,255
    -blend[-2,-1] overlay -append[-2,-1] c
    -blend[0,1] alpha -c 0,255
  -endl -done

gcd_anti_alias_preview :
  -gui_split_preview "-gcd_anti_alias ${1--2}",$-1

gcd_srgb2jpeg :
  -repeat $! -l[$>]
    -if {s<3} -continue -endif
    -if {s==4} -split_opacity -endif
    -mix_rgb[0] 0.299,0.587,0.114,-0.1687,-0.3313,0.5,0.5,-0.4187,-0.0813
    -sh[0] 1,2 -+[-1] 128 -rm[-1] -a c
  -endl -done

gcd_jpeg2srgb :
  -repeat $! -l[$>]
    -if {s<3} -continue -endif
    -if {s==4} -split_opacity -endif
    -sh[0] 1,2 --[-1] 128 -rm[-1]
    -mix_rgb[0] 1,0,1.402,1,-0.34414,-0.71414,1,1.772,0 -a c
  -endl -done

gcd_srgb2luma :
  -repeat $! -l[$>]
    -remove_opacity
    -if {s!=3} -continue -endif
    -sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
    -*[1] 0.299 -*[2] 0.587 -*[3] 0.114
    -+[1-3] -rm[1] -channels[0] 0
  -endl -done

gcd_srgb2luminance :
  -repeat $! -l[$>]
    -remove_opacity
    -if {s!=3} -continue -endif
    -srgb2rgb[0] -sh[0] 0,0 -sh[0] 1,1 -sh[0] 2,2
    -*[1] 0.2126 -*[2] 0.7152 -*[3] 0.0722
    -+[1-3] -rm[1] -channels[0] 0
  -endl -done

gcd_gamma : -skip ${1=1},${2=0},${3=255}
  -if {$1==1} -return -endif
  -repeat $! -l[$>]
    -if {!$2} g={1/max($1,0.001)} -^ $g -* {$3^(1-$g)}
    -else -* -1 -+ $3 -max 0 -^ $1 -* {-$3^(1-$1)} -+ $3 -endif
  -endl -done

gcd_sbezier : -skip ${1=0.5},${2=255}
  -repeat $! -l[-1] -/ $2 --sqr -*. {1-2*$1} -*.. {2*$1} -+ -* $2 -endl -done

gcd_ibezier : -skip ${1=0.5},${2=255}
  -if {$1==0.5} -return -endif
  -repeat $! -l[-1]
    d={1-2*$1} e={$1/$d} -/ {$2*$d} -+ {$e*$e}
    -sqrt. -* {$1>0.5?-1:1} -- $e -* $2
  -endl -done

gcd_label : -skip ${1=4},${2=0.067}
#***** CUSTOM LABEL, INPAINT SMALL AREAS *****
# -gcd_label <tolerance=4>,<size=0.2>
  -repeat $! -l[$>]
    -label[-1] $1,1 nb={1+iM}
    --histogram[-1] $nb,0,{$nb-1}
    --map[-2] [-1] -rm[-2]
    -le[-1] {$2%*w*h} -*[-1] 255
    -inpaint[-2] [-1] -rm[-1]
  -endl -done

gcd_shrink :
#***** SHRINK AN IMAGE TO 700px FOR SPEED *****
  _gcd_w={0,w} _gcd_h={0,h}
  -repeat $! -l[$>] -if {max(w,h)>700} -rr2d[-1] 700,700,0,1 -endif -endl -done

gcd_unshrink :
  -repeat $! -l[$>] -r $_gcd_w,$_gcd_h -endl -done

gcd_fix_alpha :
#***** Force gimp to set transparent region pixels black *****
  -repeat $! -l[$>] -if {s==2||s==4}
    -sh 0,{s-2} -sh[0] 100%,100% -max[-1] 1 --neq[-1] 1 -*[-3,-1] -k[0]
  -endif -endl -done

#@cli gcd_noalpha
#@cli : Remove any gimp alpha channel and zero transparencies
gcd_noalpha :
  -e[^-1] "Remove gimp alpha channel from image$?."
  -v - -repeat $! -l[$>] -if {s==2||s==4}
    m={s-2} -sh 0,$m -sh.. 100% -neq. 0 -*.. . -k[0] -channels 0,$m
  -endif -endl -done -v +

#@cli gcd_splitalpha
#@cli : Split any gimp alpha channel and zero transparencies
gcd_splitalpha :
  -e[^-1] "Split gimp alpha channel from image$?."
  -v - -repeat $! -l[$>] -if {s==2||s==4}
    m={s-2} -sh 0,$m -sh.. 100% [-1] -neq.. 0 -*[1,2] -k[^1] -channels.. 0,$m
  -endif -endl -done -v +

#@cli gcd_force_rgb
#@cli : Force selected gimp images to be in RGB mode.
gcd_force_rgb :
   -e[^-1] "Force gimp image$? to be in RGB mode."
   -v - -repeat $! -l[$>]
     -if {s>4} -v + -error[] "Command '-gcd_force_rgb': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
     -elif {s==4} -sh 0,2 -sh.. 3 -neq. 0 -*.. . -k[0] -channels 0,2
     -elif {s==2} -sh 0 -sh.. 1 -neq. 0 -*.. . -k[0] -channels 0 -r 100%,100%,100%,3
     -elif {s==1} -r 100%,100%,100%,3
     -endif
   -endl -done -v +

#@cli gcd_force_rgba
#@cli : Force selected gimp images to be in RGBA mode.
gcd_force_rgba :
   -e[^-1] "Force gimp image$? to be in RGBA mode."
   -v - -repeat $! -l[$>]
     -if {s>4} -v + -error[] "Command '-gcd_force_rgba': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
     -elif {s==4} --channels 3 -neq. 0 -*
     -elif {s==3} -channels 0,3 -sh. 3 -f. 255 -rm.
     -elif {s==2} --channels 1 -neq. 0 -* -r 100%,100%,100%,4 -sh. 2 -f. .. -rm.
     -elif {s==1} -r 100%,100%,100%,4 -sh. 3 -f. 255 -rm.
     -endif
   -endl -done -v +

#@cli gcd_force_a
#@cli : Force selected gimp images to have an alpha channel.
gcd_force_a :
  -e[^-1] "Force gimp image$? to have an alpha channel."
  -v - -repeat $! -l[$>]
    -if {s==1||s==3} -channels 0,{s} -sh. {s-1} -f. 255 -rm.
    -elif {s==2||s==4} --channels 100% -neq. 0 -* -endif
  -endl -done -v +

#@cli gcd_srgb2rgb
#@cli : Convert from sRGB gamma to RGB by fast approximate.
gcd_srgb2rgb :
  -e[^-1] "Convert image$? from sRGB gamma to RGB by fast approximate."
  -v - -c 0,255 -* 257 -round 1 (0,255) -r. 65536,1,1,1,3 -srgb2rgb. -map[^-1] . -rm. -v +

#@cli gcd_rgb2srgb
#@cli : Convert from RGB to sRGB gamma by fast approximate.
gcd_rgb2srgb :
  -e[^-1] "Convert image$? from RGB to sRGB gamma by fast approximate."
  -v - -c 0,255 -* 257 -round 1 (0,255) -r. 65536,1,1,1,3 -rgb2srgb. -map[^-1] . -rm. -v +

#@cli gcd_extract_clut : _resolution_root,_smoothness,_nb_iterations>=0,_nb_randoms>=0
#@cli : Extract color LUT from selected images.
gcd_extract_clut : -skip ${1=8},${2=3},${3=5},${4=5}
  -e[^-1] "Extract color LUT from image$?."
  -v - -to_rgb b={int($1)^2} s={$b^1.5}
  (0,1;0,1/0,1;0,1^0,0;1,1/0,0;1,1^0,0;0,0/1,1;1,1)
  -*. 255 -r. $b,$b,$b,3,3 -r. $s,$s,1,3,-1
  -repeat {$!-1} -l[$>,-1] nm="[CLUT: "{0,n}"]"
    --matchpatch. ..,1,1,1,$3,$4 -warp[0] .,0
    -rm. -r.. $b,$b,$b,3,-1 -b.. $2 -nm.. $nm
  -endl -done -rm. -v +

#@cli gcd_geometric_median : size>=0,_nb_iter>=0
#@cli : Apply geometric median filter on vector-valued images.
#@cli : Default values: 'size=3' and 'nb_iter=12'.
#@cli : $ image.jpg +gcd_geometric_median 3
gcd_geometric_median : skip ${1=3},${2=12}
  -e[^-1] "Apply geometric median filter of size $1, on image$?."
  -v -
  repeat $! l[$>]
  [0] +boxfilter. {$1+1-$1%2} sh. 0
  f. "*
    begin(
      const boundary = 1;
      const N = int($1/2);
      const W = N+1;
      weightedSum = I(#1);
      totalDist = weightedSum;
    );

    Y = I(#2,x,y); # centroid

    for (iters = 0, iters<$2, ++iters,
      weightedSum = 0;
      totalDist = 0;
      distSum = 0;
      flag = 0;

      for (j = -N, j<W, ++j,
        for (k = -N, k<W, ++k,
          X = J(#1,j,k);
          diff = X - Y;
          dist = norm2(diff);
          if(dist==0, flag=1,
            R = 1/dist;
            weightedSum += R * X;
            totalDist += R * diff;
            distSum += R;
          );
        );
      );

      if(totalDist==0, break(),
        bal = flag ? 1/norm2(totalDist) : 0;
        Y = max(0, 1 - bal) * weightedSum / distSum + min(1, bal) * Y;1
      )
    );

    I(#0,x,y) = Y;1" k[0]
  endl done -v +

#@cli gcd_poisson_disk : _radius[%]>0,_value,_max_iters>0
#@cli : Add poisson disk sampling noise to selected images.
#@cli : Default values: 'radius=8', 'value=1' and 'max_iters=30'.
#@cli : $ 800,800 gcd_poisson_disk 8
gcd_poisson_disk : check "${1=8}>0 && ${3=30}>0" skip ${2=1}
  e[^-1] "Add noise points to image$?, with specified minimum distance."
  v - repeat $! l[$>]
    R={${"is_percent $1"}?max(w,h,d)*$1:$1}
    # [0] input image to draw samples on
    dim={d>1?3:h>1?2:1} cw={0.999*$R/sqrt($dim)} # dimensions, grid cell width
    ({[w,h,d,1]}) y. c  # [1] image dimensions vector
    {[ceil(I/$cw)]}     # [2] "accelerator" grid/cells
    r[1] 1,1,1,$dim,-1  # keep only used dimensions in [1]
    1,1,1,$dim 1,1,1,1  # [3] samples list, [4] active list
    {vector$dim(2*ceil(sqrt($dim))+1)} r. 100%,100%,100%,2 # [5] cell proximity kernel
    f. "P=[x,y,z]-int([w/2,h/2,d/2]);[sum(sqr(P)),dot(P,[1,w#2,w#2*h#2])]"
    r. {[whd,s,1,1,-1]} sort. +,x z. 0,1,100%,100% y. c # sort kernel by distance
    nm[1] dims nm[2] grid nm[3] samples nm[4] active nm[5] prox
    eval ${-math_lib}"
      const N = "$dim";
      const radius = "$R";
      const grid_cw = "$cw";
      const max_sample_attempts = $3;
      mag2(vec) = (sum(sqr(vec)));
      prox = I#5;
      lim = I#1;

      dar_insert(#3,I#1,0);               # dummy sample to simplify bounds checks
      dar_insert(#3,u(I#1),1);            # add initial sample to list
      dar_insert(#4,1,0);                 # add its index to active list
      I(#2,int(I[#3,1]/grid_cw)) = 1;     # add its index to grid cell
      I(#0,I[#3,1]) = $2;                 # draw the point

      while (dar_size(#4)>0,
        R = int(u(dar_size(#4)-1e-4));    # choose a random active list index
        P = i[#4,R];                      # get the index of that sample
        T = I[#3,P];                      # position vector of that sample

        for (attempts=0, attempts < max_sample_attempts, ++attempts,

          do (S=4*(u(vectorN(1))-0.5); M=mag2(S), M <= 1 || M > 4);

          X = T + radius * S;             # potential sample from annulus around T
          if (min(X)<0 || min(lim-X)<0, continue()); # check within bounds

          # check proximity of surrounding points
          G = int(X/grid_cw);             # grid cell position vector
          GI = dot(G,[1,w#2,w#2*h#2]);    # grid cell direct buffer index

          for (K=0;rejected=0, K<size(prox), ++K,
            V = i[#2,GI+prox[K]];         # sample index from grid to check
            if (V>0 && mag2(I[#3,V]-X)<sqr(radius), rejected=1;break())
          );

          if (!rejected,
            Q = dar_size(#3);               # sample found, get new index
            dar_insert(#3,X,Q);             # insert into samples list
            dar_insert(#4,Q,dar_size(#4));  # insert its index into active
            I(#2,G) = Q;                    # insert its index into grid
            I(#0,X) = $2;                   # draw the point
            break();
          );
        );

        if (attempts == max_sample_attempts, dar_remove(#4,R));
      );
    " k[0]
  endl done v +

#@gui _

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
