#@gmic
# (^ don't forget this first line !)
#
#GMic filters from Arto Huotari. All filters lisenced under the same Cecill lisence as G'Mic
#
#####################################################################
# Artistic Folder
#####################################################################
#@gui _<b>Artistic</b>

#****************************************
#Dream smoothing
#****************************************
#@gui Dream Smoothing : fx_dreamsmooth, fx_dreamsmooth_preview(0)
#@gui : note = note("Updated for 1.5.4.0")
#@gui : note = note("A relatively slow filter that uses anisotropic filtering to smooth an image. More iterations produces softer image as does lower opacity values. Practical modes for merging are Alpha and Average. Note that results are resolution dependent.")
#@gui : sep = separator(), note = note("General settings")
#@gui : Iterations = int(3,1,10)
#@gui : Equalize at Each Step = bool(1)
#@gui : sep = separator(), note = note("Merging of iterations")
#@gui : Merging Option = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor","edges")
#@gui : Opacity = float(0.8,0,1)
#@gui : Reverse Order = bool(0)
#@gui : note = note("Settings for layer mode edges")
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator()
#@gui : note = note("Parallel processing settings. Increase spatial overlap if vertical bands appear.")
#@gui : Parallel Processing = choice(1,"Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gui : Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2014/02/20</i>.</small>")
#@gui : note = link("Sample processing here","http://www.flickr.com/photos/naggobot/7644006608/")


fx_dreamsmooth :
-m "MergeChoise : $""=_mode" -MergeChoise "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"

-to_rgb
Iterations=$1
Eqa=$2
MergingOption=$3
Opacity=$4
ReverseOrder=$5
Smoothness=$6
Threads=$7
Overlap=$8
#Handle multiple layers
-repeat $! -l[$>]
#Enter loop and smooth first image
-repeat $Iterations
	#Calculate width and height
	IWidth={0,round(w/($<+1))}
	IHeight={0,round(h/($<+1))}
	#Resize previously processed image. Not done on first repeat loop since there is no such image yet.
	-if {$>!=0}
		#Resize [image_w],[image_h],[image_d],[image_s],_interpolation,_boundary,_ax,_ay,_az,_ac
		-r[-1] $IWidth,$IHeight,1,3,5,1
	-endif
	#Resize and make a copy
	--r[0] $IWidth,$IHeight,1,3,5,1 #Image 1 and on loop 2 image 2 / -1 and -2
	#Smoothing
	-fx_smooth_anisotropic[-1] {430/$Iterations*($<+1)},0.4,0.5,0.6,2,0.8,30,2,0,0,1,0,$Threads,$Overlap,0
	-fx_smooth_anisotropic[-1] {600/$Iterations*($<+1)},0.4,1,0.6,4,0.8,15,5,0,1,1,0,$Threads,$Overlap,0
	#Combine images	if not first round
	-if {$>!=0}
		#Something wrong with this boolean. It does not work.
		-if {$3!=42}
			-blend[-1,-2] ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
		-endif
		-if {$3==42}
			 -blend_edges[-1,-2] $Opacity,$Smoothness,$ReverseOrder
		-endif
		-if {$Eqa}
			-equalize[-1] 256
		-endif
	-endif
-done
-keep[-1]
#End command for multilayer handling block
-endl -done

fx_dreamsmooth_preview :
  -gui_split_preview "-fx_dreamsmooth ${1--2}",$-1

#************END OF FILTER*************


#****************************************
#Morphology painting
#****************************************

#@gui Morphology Painting : fx_MorphoPaint, fx_MorphoPaint_preview(0)
#@gui : sep = separator()
#@gui : note = note("Creates a painting using Morphology-, Segmentation- and Painting- filters. CPU intensive filter that may take long.")
#@gui : sep = separator()
#@gui : note = note("Morphology settings")
#@gui : sep = separator()
#@gui : Method = choice(1,"Erosion","Dilation","Opening","Closing")
#@gui : MorphoStrenght = int(18,2,60)
#@gui : Shape = choice(2,"Square","Octagonal","Circular")
#@gui : sep = separator()
#@gui : note = note("Lightness for Morpholayer")
#@gui : Black Point = int(25,0,50)
#@gui : Expand Shadows = int(100,50,255)
#@gui : Compress Highlights = int(230,200,255)
#@gui : sep = separator()
#@gui : note = note("Smoothing strength")
#@gui : Spread Amount = int(8,0,20)
#@gui : Blurr Strength = int(3,0,10)
#@gui : sep = separator()
#@gui : note = note("Segmentation settings")
#@gui : Edge Threshold = float(4,0,15)
#@gui : Smoothness = float(0.5,0,5)
#@gui : sep = separator()
#@gui : note = note("Painting Settings")
#@gui : Abstraction = int(2,1,10)
#@gui : Details Scale = float(0.5,0,5)
#@gui : Smoothness = float(200,0,1000)
#@gui : sep = separator()
#@gui : Merge Layers? = bool(1)
#@gui : note = note("When unchecked the filter will output layers separately for manual composing. Set G'Mic output to new layers.")
#@gui : sep = separator()
#@gui : Enable Paintstroke = bool(1)
#@gui : Stroke Strength = float(1,0,1)
#@gui : Enable Segmentation = bool(1)
#@gui : Segments Strength= float(1,0,1)
#@gui : Enable Morphology = bool(1)
#@gui : Morphology Strength= float(1,0,1)
#@gui : Normalize = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6108637935/")

fx_MorphoPaint :
-to_rgb[0]
--fx_morpho[0] $1,$2,0,2,0,$3,0 #Morpho as nro 1
--fx_apply_curve[1] $4,50,$5,200,$6,-1,128,-1,128,-1,128,255,1,3,0,0,0 #Curved morpho as nro 2
-fx_spread[1] $7,$7,0,0 #Spread Morpho nro 1
-fx_gaussian_blur[2] $8,0,0,1,0,0,0 #Blurr Morpho+Spread nro 1
-fx_segment_watershed[1] $9,$10,0,0 #Segment Morpho+Spread+Blurr nro 1
--fx_painting[0] $11,$12,1.5,$13,1,0 #Paint from original nro 0
-remove[0] #Remove original from stack
-reverse[0,2] #reverse images to logical order (Important if output to Gimp)
-reverse[1,2]
-if $14

	-if {$19==0} MorphoStrength={0} -elif {$19==1} MorphoStrength={$20} -endif	#Set layer value to zero if enabled
	-mul[2] {$MorphoStrength/3} #Morphology

	-if {$15==0} StrokeStrength={0} -elif {$15==1} StrokeStrength={$16} -endif	#Set layer value to zero if enabled
	-mul[0] {$StrokeStrength/3} #Paint stroke

	-if {$17==0} SegmentStrength={0} -elif {$17==1} SegmentStrength={$18} -endif	#Set layer value to zero if enabled
	-mul[1] {$SegmentStrength/3}  #Segments

	-add[1] [2] #Combine images
	-add[1] [0]

		-if $21 -normalize[1] 0,255 -endif #Conditional normalize to get the image to correct range
	-remove[0,2] #remove extra images
-endif

fx_MorphoPaint_preview :
  -gui_split_preview "-fx_MorphoPaint ${1--2}",$-1


#****************************************
#Simple Noise canvas
#****************************************

#@gui Simple noise canvas : fx_SimpleNoiseCanvas, fx_SimpleNoiseCanvasPreview(0)
#@gui : note = note("Simpe noise based xy canvas effect. Preserve canvas and bumpmap image with canvas after filtering for best results. Merge option DoNothing outputs only original image if Preserve canvas option is not selected.")
#@gui : sep = separator()
#@gui : Scale factor = float(0,0,1)
#@gui : sep = separator()
#@gui : note = note("Noise parameters")
#@gui : Amplitude = float(3,0,20)
#@gui : Noise type = choice(2,"Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : sep = separator()
#@gui : note = note("Thread length")
#@gui : Horisontal length = float(5,2,15)
#@gui : Vertical length = float(5,2,15)
#@gui : Over all blurr = float(0,0,15)
#@gui : Canvas brightness = float(255,230,255)
#@gui : Canvas darkness = float(0,0,255)
#@gui : sep = separator()
#@gui : note = note("How to combine XY threads")
#@gui : Merging Option = choice(2,"Average","Multiply","Darken","Edges")
#@gui : Invert Canvas Colors = bool(0)
#@gui : Invert Image Colors = bool(0)
#@gui : note = note("How to combine image + canvas")
#@gui : Reverse order = bool(0)
#@gui : Merging Option = choice (1,"Avg","Multiply","Scr","Darken","Lighten","Dif","Negation","Exclusion","Overlay","Hardlight","Softlight","Dodge","Colorburn","Reflect","Freeze","Stamp","Interpolate","Grainext","Grainmerge","Xor","Edges","DoNothing")
#@gui : Preserve Canvas for post bump mapping = bool(0)
#@gui : Canvas Color = color(255,255,255,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6152040642/")

fx_SimpleNoiseCanvas :
#Filter has some unnecessary reversing of layers due to change from compose to blend
CanvasScale={$1}
NoiseAmplitude=$2
NoiseType=$3
ThreadHorizLen=$4
ThreadVertLen=$5
OverAllBlurr=$6
HighCut=$7
LowCut=$8
CanvasMergeChoice=$9
InvertCanvasColors=$10
InvertImageColors=$11
ReverseChoice=$12
MergeChoice=$13
PreserveCanvas=$14
#(Remember that color is set directly with param 15-17)

#Remove alpha channel from image
-to_rgb[0]

#Invert scale factor for scaling
CanvasScale={1.2-$CanvasScale}

#Make white base image with specified color and resize it to inputimage size
(255^255^255)
-r[-1] [0]

#Resize to scale factor
-r[1] {100*$CanvasScale}%,{100*$CanvasScale}%

#add noise
-if {$NoiseType!=2} NoiseAmplitude={($NoiseAmplitude*10)} -endif
-fx_noise[1] $NoiseAmplitude,$NoiseType,0,1,0
#make noise BW
-fx_ditheredbw[1] 1,1,0,0,0,0 #[G'MIC] B&W dithering
#Blur X for noize, make new image
--fx_gaussian_blur[1] 0,$ThreadHorizLen,0,1,0,0,0 #image 2
#Blur y for noize, make new image
--fx_gaussian_blur[1] 0,0,$ThreadVertLen,1,0,0,0 #image 3
-normalize[2] 0,255
-normalize[3] 0,255

#Combine canvas

#-if {$CanvasMergeChoice==0} -blend[2,3] average
#-elif {$CanvasMergeChoice==1} -blend[2,3] multiply
#-elif {$CanvasMergeChoice==2} -blend[2,3] darken
#-elif {$CanvasMergeChoice==3} -blend_edges[2,3] 0.9
#-endif

-if {$CanvasMergeChoice==0} -blend[2,3] average
-elif {$CanvasMergeChoice==1} -blend[2,3] multiply
-elif {$CanvasMergeChoice==2} -blend[2,3] darken
-elif {$CanvasMergeChoice==3} -blend_edges[2,3] 0.9
-endif


#OverAllBlurr
-fx_gaussian_blur[2] $OverAllBlurr,0,0,1,0,0,0 #image 3

#Remove noise image
-remove[1]

#scale canvas back to image size
-r[1] [0]

#Make color and transfer it
($15^$16^$17) #image 2
-r[2] [0]
-blend[1,2] multiply

#Adjust range
-fx_apply_curve {$LowCut},-1,128,-1,128,-1,128,-1,128,-1,128,{$HighCut},1,3,0,0,0

#reverse if requested
-if {$ReverseChoice==1} -reverse[0,1] -endif

#Invert canvas colors if requested
-if {$InvertCanvasColors==1} -negate[1] -endif

#Invert Image colors if requested
-if {$InvertImageColors==1} -negate[0] -endif

#Combine to original

-if {$MergeChoice==0} --blend[1,0] average #Image 2
-elif {$MergeChoice==1} --blend[1,0] multiply
-elif {$MergeChoice==2} --blend[1,0] screen
-elif {$MergeChoice==3} --blend[1,0] darken
-elif {$MergeChoice==4} --blend[1,0] lighten
-elif {$MergeChoice==5} --blend[1,0] difference
-elif {$MergeChoice==6} --blend[1,0] negation
-elif {$MergeChoice==7} --blend[1,0] exclusion
-elif {$MergeChoice==8} --blend[1,0] overlay
-elif {$MergeChoice==9} --blend[1,0] hardlight
-elif {$MergeChoice==10} --blend[1,0] softlight
-elif {$MergeChoice==11} --blend[1,0] dodge
-elif {$MergeChoice==12} --blend[1,0] colorburn
-elif {$MergeChoice==13} --blend[1,0] reflect
-elif {$MergeChoice==14} --blend[1,0] freeze
-elif {$MergeChoice==15} --blend[1,0] stamp
-elif {$MergeChoice==16} --blend[1,0] interpolation
-elif {$MergeChoice==17} --blend[1,0] grainextract
-elif {$MergeChoice==18} --blend[1,0] grainmerge
-elif {$MergeChoice==19} --blend[1,0] xor
-elif {$MergeChoice==20} --blend_edges[1,0] 0.8
-endif
#Reverse original and canvas if it was done previously
-if {$ReverseChoice==1} -reverse[0,1] -endif
#Remove canvas if not asked to preserve
-if {$PreserveCanvas==0} -remove[1]  -endif
#PreserveCanvas=1
-if {$PreserveCanvas==1" && "$MergeChoice!=21} -reverse[1,2]  -endif

#remove original if merging is done
-if {$MergeChoice!=21} -remove[0] -endif

#Switch items for correct preview

-if {$MergeChoice!=21" && "$PreserveCanvas==1} -reverse[0,1] -endif

fx_SimpleNoiseCanvasPreview :
  -gui_split_preview "-fx_SimpleNoiseCanvas ${1--2}",$-1

#************END OF FILTER*************

######################################
#Gimp pastell
#####################################
#@gui Pastell art : fx_pastell, fx_pastell_preview(1)
#@gui : MasterOpacity = float(0.6,0.3,1)
#@gui : Bg textured = bool(1)
#@gui : Reverse Effect = bool(0)
#@gui : sep = separator(),note = note("Rodilius settings")
#@gui : Amplitude = float(20,0,30)
#@gui : Thickness = float(30,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(1,1,36)
#@gui : Offset = float(30,0,180)
#@gui : Color mode = choice(1,"Darker","Lighter")
#@gui : sep = separator(),note = note("Gradient settings")
#@gui : Smoothness = float(1,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Negative colors = bool(0)
#@gui : sep = separator(),Activate Shakes = bool(0)
#@gui : Amount = float(10,0,30)
#@gui : Strenth = float(3,1,300)
#@gui : sep = separator(),Activate Lizards = bool(0)
#@gui : Toes = float(9,0,300)
#@gui : Shivers = float(3,0,4)
#@gui : sep = separator(),Activate Pink elephants = bool(0)
#@gui : Trunks = float(12,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6294075073/")
fx_pastell :
#Filter may have some unnecessary reversing of layers due to change from compose to blend
#Variables
MasterOpacity=$1
BgTextured=$2
ReverseEffect=$3
RAmplitude=$4
RThickness=$5
RSharpness=$6
ROrientations=$7
ROffset=$8
RColormode=$9
GSmoothness=$10
GLinearity=$11
GNegativeColors=$12
ActivateShakes=$13
RiAmplitude=$14
RiSize=$15
ActivateLizards=$16
WAmplitude=$17
WSmoothness=$18
ActivatePink=$19
RDeform=$20
#Constants
RChannels=0
GMinThreshold=0
GMaxThreshold=100
RiShape=3
RiAngle=135
#Code
-if {$ActivatePink==1} -deform[0] $RDeform -endif
--fx_rodilius[0] $RAmplitude,$RThickness,$RSharpness,$ROrientations,$ROffset,0,$RColormode,$RChannels,0 #img1
--fx_gradient_norm[0] $GSmoothness,$GLinearity,$GMinThreshold,$GMaxThreshold,$GNegativeColors,0 #img2
-fx_smooth_bilateral[0] 15,10,3,3,0
-if {$ActivateLizards==1} -water[0,2] $WAmplitude,$WSmoothness -endif
-if {$ActivateShakes==1} -ripple[0,2] $RiAmplitude,$RiSize,$RiShape,$RiAngle,0 -endif
-if {$ReverseEffect==1} -reverse[0,2] -endif
--blend[0,2] divide,1,0 #img3
-reverse[1,3]
-blend[1,3] value,1,0 #img1
-if {$BgTextured==1} -fx_ellipsionism[0] 20,2,10,0.5,1,1,0 -endif
-blend[0,1] alpha,$MasterOpacity,0
-keep[0]
fx_pastell_preview :
  -gui_split_preview "-fx_pastell ${1--2}",$-1


######################################
#ColorAbstractionPaint
#####################################
#@gui Color Abstraction Paint : fx_ColorAbstractionPaint, fx_ColorAbstractionPaint_Preview(0)
#@gui : Abstraction = int(5,1,10)
#@gui : Ellipse ratio = float(10,1,100)
#@gui : sep = separator(),note = note("Opacities, try 0 to see individual effect layers")
#@gui : Ellipsionism opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : Use as Hue = bool(0)
#@gui : Painting opacity = float(1,-1,1)
#@gui : sep = separator()
#@gui : Use as Saturation = bool(0)
#@gui : Color abstraction opacity = float(1,-1,1)
#@gui : Negative Color Abstraction = bool(0)
#@gui : Cubism on Color Abstraction = bool(0)
#@gui : Kuwahara on painting = bool(0)
#@gui : Soften = float(0,0,100)
#@gui : Soften all channels = bool(0)
#@gui : DoNotMergeLayers = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = link("Sample art here","http://www.flickr.com/photos/naggobot/6640743133/")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2014/02/23</i>.</small>")

fx_ColorAbstractionPaint :
#Filter may have some unnecessary reversing of layers due to change from compose to blend
#Alternative merge is Ellipsionism->Value, Painting -> Hue, Color -> Saturation
#Force rgb
-to_rgb

#Ellipsionism e
pAbstraction=$1
EllipseRatio=$2
ValueOpacity=$3
UseHue=$4
MultiplyOpacity=$5
UseSaturation=$6
GrainMergeOpacity=$7
NCA=$8
CubeIt=$9
KuwaIt=$10
Soften=$11
SoftenAll=$12
DoNotCompose=$13
ReverseOrder0=1
ReverseOrder1=1
ReverseOrder2=1
eSmoothness=1
eOpacity=0.8
eOutline=1
eDensity={1.5*$eSmoothness/10}
#Painting p
pDetailsScale={$pAbstraction/2}
pColor=1.5
pSmoothness={10*$pAbstraction}
#y=y0+(x-x0)(y1-y0)/(x1-x0)
#Smoothness Y goes to 10 from 0 when abstraction X goes to 1 from 10
eSmoothness={10+($pAbstraction-1)*(1-10)/(10-1)}
ePrimaryRadius={0,($pAbstraction/5)*($pAbstraction/5)*sqrt(h)}
eSecondaryRadius={$EllipseRatio/100*$ePrimaryRadius}
cAbstraction={2+($pAbstraction-1)*(10-2)/(10-1)}
#CubeSize={$ePrimaryRadius*$cAbstraction/30}
CubeSize={4+($pAbstraction-1)*(10-4)/(10-1)}

--fx_ellipsionism[0] $ePrimaryRadius,$eSecondaryRadius,$eSmoothness,$eOpacity,1,$eDensity,0 #1 #-3
-if {$SoftenAll==1" && "$Soften>0} -blur[-1] $Soften,0 -endif
--fx_painting[0] $pAbstraction,$pDetailsScale,$pColor,$pSmoothness,1,0 #2 #-2
-if {$KuwaIt==1} -fx_kuwahara[-1] 2,$pAbstraction,0,0 -endif
-if {$Soften>0} -blur[-1] $Soften,0 -endif
--fx_color_abstraction[0] $cAbstraction,45,0.35,0 #3 #-1
#If negative then invert colors of -1
-if {$NCA==1} -negate[-1] -endif
-if {$CubeIt==1} -cubism[-1] 600,$CubeSize,40,0.7,0 -endif
-if {$Soften>0} -blur[-1] $Soften,0 -endif
-if {$DoNotCompose==0}
	#Compose Original and Ellipsionism with value
	-blend[0,1] value,$ValueOpacity,$ReverseOrder0 #0 #-3
	#Compose Original+Ellipsionism with painting
	-if {$MultiplyOpacity<0}
		ReverseOrder1=0
		MultiplyOpacity={-1*$MultiplyOpacity}
	-endif
	-if {$UseHue==0}
		-blend[0,1] multiply,$MultiplyOpacity,$ReverseOrder1 #0 #-2
	-elif {$UseHue==1}
		-blend[0,1] hue,$MultiplyOpacity,$ReverseOrder1
	-endif

	#Compose Original+Ellipsionism+Painting with Color abstraction
	-if {$GrainMergeOpacity<0}
		ReverseOrder2=0
		GrainMergeOpacity={-1*$GrainMergeOpacity}
	-endif
	-if {$UseSaturation==0}
		-blend[0,1] grainmerge,$GrainMergeOpacity,$ReverseOrder2
	-elif {$UseSaturation==1}
		-blend[0,1] saturation,$GrainMergeOpacity,$ReverseOrder2
	-endif
	-keep[0]
-endif
-if {$DoNotCompose==1} -remove[0] -endif

fx_ColorAbstractionPaint_Preview :
  -gui_split_preview "-fx_ColorAbstractionPaint ${1--2}",$-1

#****************************************
#Make Squiggly
#****************************************
#@gui Make Squiggly : fx_Squiggly, fx_Squiggly_Preview(0)
#@gui : note = note("Squigles an image")
#@gui : note = note("Squigle parameters")
#@gui : Spread noise amount  = float(2,0,20)
#@gui : Segmentation edge threshold = float(12,0,15)
#@gui : Segmentation smoothness = float(0.8,0,5)
#@gui : GradienNormSmoothness = float(0,0,10)
#@gui : GradienNormLinearity = float(0.5,0,1.5)
#@gui : Invert Luminance = bool(1)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("<b>Optional color enhancement</b>")
#@gui : note = note("Note that the effect of sliders depends on the merge setting.")
#@gui : Activate Color Enhancement = bool(0)
#@gui : Toggle to view base image = bool(0), note = note("Check this to view base image")
#@gui : IncreaseChroma1 = float(3,1,4)
#@gui : Tone threshold = float(0.2,0,1)
#@gui : Tone gamma = float(0.4,0,1)
#@gui : note = note("Select merging mode to original")
#@gui : Merging Option = choice("Alpha","And","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain extract","Grain merge",
#@gui : "Hard light","Hue","Interpolation","Lighten","Lightness","Luminance","Multiply","Negation","Or","Overlay","Reflect","Saturation",
#@gui : "Soft light","Screen","Stamp","Value","Xor")
#@gui : Opacity = float(1,0,1)
#@gui : Reverse order = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6667673847/")


fx_Squiggly :

#Variables
SpreadNoiseAmount=$1
SEgThrshld=$2
SegSmooth=$3
GNSmooth=$4
GNLin=$5
InvertLuminance=$6
EnhanceColors=$7
ToggleOrg=$8
Chroma=$9
ToneTr=$10
ToneGm=$11
OrgMergeCh=$12
OrgOpacity=$13
OrgReverseorder=$14

repeat $! l[$>]

#Enable original preview from color enhancement section
-if {$ToggleOrg==1}
	OrgMergeCh=30
	OrgReverseorder=1
-endif

#Remove alpha channel, something goes wrong if image has aplha
-to_rgb

--fx_spread[0] $SpreadNoiseAmount,$SpreadNoiseAmount,0,0  #Spread noise (image1)
-fx_segment_watershed[1] $SEgThrshld,$SegSmooth,0,0   #Segmentation (image1)
--fx_gradient_norm[1] $GNSmooth,$GNLin,0,100,0,0 #Gradient norm (image2)

#Create colorized squiggle
--blend[2,1] multiply #image 3

#Make bg white
-if {$InvertLuminance==1}
	#Convert to LAB
	-rgb2lab[-1]
	#Split channels
	-split[-1] c
	-negate[-3]
	-append[-3--1] c
	-lab2rgb[-1]
-endif

-if {$EnhanceColors==1}
	#Increase chroma
	-fx_mix_ycbcr[3] 1,0,0,$Chroma,0,0,$Chroma,0,0,0,2,0 #image 3
	#Tonemap original
	-fx_map_tones[0] $ToneTr,$ToneGm,0.1,30,0,0 #image 0
	#-fx_apply_curve[0] 0,30,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
	#Compose Squigglies to original
	-fx_blend[0,3] $OrgMergeCh,0,$OrgOpacity,$OrgReverseorder
	-keep[0]
-endif

-keep[-1]

endl done

fx_Squiggly_Preview :
  -gui_split_preview "-fx_Squiggly ${1--2}",$-1

#************END OF FILTER*************


#################################################################################################################
#@gui _<b>Details</b>
#################################################################################################################

#******************************************
#USM WITH LCE
#******************************************
#@gui Local contrast enhancement : fx_LCE, fx_LCE_preview(0)
#@gui : note = note("Local contrast enhancement is <i>Unsharp Mask</i> with high radius. Apply filter to RGB channels for color and contrast enhancement.")
#@gui : Spatial radius = float(80,30,200)
#@gui : Amount = float(0.5,0,5)
#@gui : Darkness level = float(1,0,4)
#@gui : Lightness level = float(1,0,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = note{"\n\n<small><b>Note : </b>
#@gui : Original USM code by <i>by David Tschumperl&#233;</i>.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors : <i>Arto Huotari, PhotoComiX</i>.      Latest update : <i>2013/03/23</i>.</small>")
_fx_LCE :
SpatialRadius=$1
Amount=$2
DarknessLevel=$3
LightnessLevel=$4
#Since LCE a threshold of 0 is used always
Threshold=0
--blur[-1] $SpatialRadius
--[-1] [-2] -*[-1] -$Amount
--norm[-1] -ge[-1] $Threshold% -r[-1] [-2] -*[-2,-1]
--c[-1] 0,100% -c[-2] -100%,0 -*[-2] $DarknessLevel -*[-1] $LightnessLevel -+[-2,-1]
-+[-2,-1] -c[-1] 0,255
fx_LCE :
  -ac "-_fx_LCE $1,$2,$3,$4",$5,0
fx_LCE_preview :
  -gui_split_preview "-fx_LCE ${1--2}",$-1
#******************************************
#END OF FILTER
#******************************************

#******************************************
#YAG effect
#******************************************
#@gui YAG_effect : fx_yag_soften, fx_yag_soften_preview(0)
#@gui : Darken  = float(0,0,100)
#@gui : Soften  = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6260257923/")
fx_yag_soften :
Darken=$1
Soften=$2
#Make sharpener layer
--fx_laplacian[0] 0,0,100,0,0,0 #image 1
#Blurr laplacian
-if {$Soften>0}
-fx_gaussian_blur[1] {$Soften/10},0,0,1,0,0,0
-endif
#Make soft and vivid
--fx_mix_lab[0] 0.5,50,0.2,1,2,1,1,2,1,0,10,0 #image 2
#Make darkener mask with softlight
#Multiply with previous darkener mask
-if {$Darken>0}
	--blend[0,2] softlight #image 3
	-blend[0,3] multiply,{$Darken/100}
-endif
#Compose soft and vidid with hardlight
-blend[0,2] hardlight #image0 is modified, image 2 is removed
#Sharpen with grainextract
-if {$Soften!=100}
	-blend[0,1] grainextract #Image 0 image 1 is removed
-elif {$Soften==100}
	-remove[1]
-endif
fx_yag_soften_preview :
  -gui_split_preview "-fx_yag_soften ${1--2}",$-1


#******************************************
#END OF FILTER
#******************************************

###################################################################################################################
#@gui _<b>Testing</b>
###################################################################################################################

#@gui Naggobot
#******************************************
#Import 16 bit image
#******************************************
#@gui Import 16bit image : fx_import_image_16, fx_import_image_16
#@gui : note = note("Filter can be used to import and adjust 16 bit images to Gimp. Plugin may have limited set of import formats available depending on compilation. At minimum only .png should work reliably.")
#@gui : note = note("1. Create new empty image to Gimp")
#@gui : note = note("2. Open G'Mic from filters menu")
#@gui : note = note("3. Set G'Mic output to "new layers")
#@gui : note = note("4. Select 16 bit image from folder")
#@gui : note = note("5. Make adjustments using sliders")
#@gui : note = note("6. Image will be outputted to Gimp")
#@gui : note = note("By default a scaled down image is processed. Before processing full size disable preview window from gui.")
#@gui : note = note("LAB adjustment often yields more aesthetic results than RGB adjustment.")
#@gui : Input image = file()
#@gui : Process selection = choice(1,"Preview Only", "Histogram", "Logarithmic Histogram", "Full resolution")
#@gui : Gamma = float(2.2,0,5)
#@gui : sep = separator(), note = note("LAB adjustment")
#@gui : Brightness = float(0,-1,1)
#@gui : Contrast = float(1,0,3)
#@gui : Equalize = float(0,0,1)
#@gui : Saturation = float(0,-1,10)
#@gui : A(R-G) = float(0,-1,1)
#@gui : B(Y-B) = float(0,-1,1)
#@gui : sep = separator(), note = note("RGB cut and normalize histogram by percentage")
#@gui : Cut high light values = float(100,0,100)
#@gui : Cut dark values = float(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Arto Huotari;</i>.      Latest update: <i>2014/04/02</i>.</small>")

fx_import_image_16 :
#Variables
ProcessTo=$2
Gamma=$3
Brightness=$4
Contrast=$5
Equalize=$6
AB=$7
A=$8
B=$9
CutHigh=$10
CutLow=$11
#Remove import image
-rm -i
#Import image from disk
"$1"
#Make sure that the input is rgb
-to_rgb
#Scale down to preview size
-if {$ProcessTo!=3}
	-resize2dx 520,1
-endif
-apply_gamma $Gamma
#Check if image has pixelvalues over 255
#Correct only for gamma if not
-if {0,iM>256}
	-if $Equalize
		--equalize 65535
		-blend alpha,{$Equalize/2}
	-endif
	#Scale values to 0 to 1 range
	-div 65535
	#Separate luminance from colour
	-rgb2lab
	-split c
	-if $Brightness
		-add[-3] $Brightness
	-endif
	-if {$Contrast!=1}
		-mul[-3] $Contrast
	-endif
	#Adjust saturation by multiplying both A and B channels
	-if $AB
		-mul[-2] $AB
		-mul[-1] $AB
	-endif
	#Adjust colour balance by multiplying A or B channel.
	-if $A
		-mul[-2] {1+$A}
	-endif
	-if $B
		-mul[-1] {1+$B}
	-endif
	-append c
	-lab2rgb
	#RGB cut and normalize
	-if {$CutHigh!=100" || "$CutLow!=0}
		Range=1
		#Calculate cut high
		HighValue={$CutHigh/100*$Range}
		#Calculate low value from remaining
		LowValue={$CutLow/100*$HighValue}
		-cut $LowValue,$HighValue
		-normalize 0,1
	-endif
	#Scale to 255 for Gimp
	-mul 255
	#Cut 0,255 for Gimp
	-cut 0,255
	-if {$ProcessTo==1}
			--display_histogram {0,w},{0,h},255,0,254,0
			-blend lighten,0.7
	-endif
	-if {$ProcessTo==2}
			--display_histogram {0,w},{0,h},255,0,254,0,log(1+i)-1
			-blend lighten,0.7
	-endif
-endif
#******************************************
#END OF FILTER
#******************************************

#******************************************
#Luminance to alpha
#******************************************
#@gui Luminance to Alpha : fx_split_luminance, fx_split_luminance(1)
#@gui : note = note("Filter splits image to different levels of Luminance. Set preview output to "all outputs". Order of output to Gimp from top to bottom is Midtones,Light,LL,..,Dark,DD,.. If reduced overlap is used then first Light layer is removed from output as redundant if more than one level is processed. Mutilevel output becomes Midtones,,LL,LLL,..,Dark,DD,DDD.. with intermediary light and dark levels containing midtones. ")
#@gui : sep = separator()
#@gui : Levels = int (1,1,6)
#@gui : Output as alpha = bool(1)
#@gui : Reduce overlap = bool(1)
#@gui : sep = separator(), note = note("Use -keep[] or -remove[] to select output images")
#@gui : Keep custom = bool(0)
#@gui : Keep custom = text(0,-keep[-1])
#@gui : sep = separator(), note = note("<small>Author: <i>Arto Huotari;</i>.      Latest update: <i>2014/04/13</i>.</small>")

####################
intersect_images:
#Create masks to extract
#Extract areas in L that are darker than those in D (white shows light areas)
--lt[0] [1]
-mul[-1] 255
#Extract areas in D that are darker than those in L (white shows dark areas)
--lt[1] [0]
-mul[-1] 255
#Subtract booleans from L and D -> areas with selected pixels will go to 0 or below
-sub[0] [-1]
-sub[1] [-2]
#Remove booleans
-remove[-1,-2]
#Cut to 0-1 range - remove areas selected by booleans
-cut[0] 0,255
-cut[1] 0,255
#Combine images - this image now contains
#midtone area pixels but grey values = image pixel values
-add[0] [1]
-remove[1]
#Normalize to create mask i.e. pixel with value of 127.5
#will be shown with opacity of 255 when mask is used
####################

####################
create_base_levels:
Levels=$1
#Create Lighter levels
#Darker levels are created by subtracting D from L repeatedly
#there fore Li=L-i*D
-repeat {$Levels-1}
	#Multiply D level with loop index+1
	--mul[2] {$>+1}
	#Subtract i*D from L
	--sub[1] [-1]
	-remove[-2]
	-cut[-1] 0,255
-done

#Create Darker levels
#Ligter levels are created by subtracting L repeatedly from D
-repeat {$Levels-1}
	#Multiply L with loop index + 1
	--mul[1] {$>+1}
	#Subtract i*L from D
	--sub[2] [-1]
	-remove[-2]
	-cut[-1] 0,255
-done
####################

####################
reorder_stack :
Levels=$1
#Subtract overlapping portions from Light masks
#Stack is now
#  O, L, D, M, LL,LLL,LLLL,DD,DDD,DDDD
#  0, 1, 2, 3,  4,  5,   6, 7,  8,   9
#-10,-9,-8,-7, -6, -5,  -4,-3, -2,  -1
#Stack needs to be re-arranged to
#  O,M,L,LL,LLL,LLLL,D,DD,DDD,DDDD
#  O,M, L, D, _ , LL,LLL,LLLL,DD,DDD,DDDD
-move[3] 1
#  O,M, L, D, LL,LLL,LLLL,DD,DDD,DDDD
-if {$Levels>1}
	-reverse[2,3]
#  O,M, D, L,LL,LLL,LLLL,DD,DDD,DDDD to
#  O,M, _ , L,LL,LLL,LLLL,D,DD,DDD,DDDD
	-move[2] {-$Levels+1}
-endif
####################

####################
reduce_overlap :
Levels=$1
-repeat {$Levels-1}
	-sub[{2+$>}] [{3+$>}]
	-cut[{2+$>}] 0,255
-done
-repeat {$Levels-1}
	-sub[{-$Levels+$>}] [{-$Levels+$>+1}]
	-cut[{-$Levels+$>}] 0,255
-done
#subtract brights and lights from midtones
-sub[1] [{-$Levels-1}]
-sub[1] [-1]
-cut[1] 0,255
#####################

fx_split_luminance:
Levels=$1
AlphaOutput=$2
ReduceOverlap=$3
KeepCustom=$4
KeepText=$5
-to_rgb
#L
--rgb2lab
-split[-1] c
-rm[-1,-2]
-normalize[-1] 0,255
#D
--negate[-1]
#M
--intersect_images[-1,-2]
-if {$ReduceOverlap==0}
	-normalize[-1] 0,255
-endif

#Create base levels
-create_base_levels $Levels

#Reorder stack
-reorder_stack $Levels
#Stack is now  O,M,L,LL,LLL,LLLL,D,DD,DDD,DDDD

-if {{$ReduceOverlap==1}" && "{$Levels>1}}
	-reduce_overlap $Levels
-endif

-repeat {$!-1}
	#add 1 to alpha  and cut 0,225 to avoid cutting of colour channels
	#no idea why this is necessary, it yields correct results
	#Ma and ma are already 0 and even though 1 is added the output is still
	#0 for transparent areas of the mask.
	-add[{$>+1}] 1
	-cut[$>] 0,255
-done

#Combine with original
-if $AlphaOutput
-repeat {$!-1}
	--append[0,1] c
	-remove[1]
-done
-endif

-if {{$ReduceOverlap==1}" && "{$Levels>1}}
	#D and L are now equal, remove first
	-remove[2]
-endif

#Remove original
-remove[0]

-if $KeepCustom
	$KeepText
-endif
#******************************************
#END OF FILTER
#******************************************


#****************************************
#Exposure Fusion weight map
#****************************************
#@gui Exposure fusion weight map : fx_ExposureWeightMap, fx_ExposureWeightMapPreview(1)
#@gui : sep = separator()
#@gui : note = note("Create exposure fusion weight map")
#@gui : sep = separator()
#@gui : note = note("Set filter output to "New layers". Copy filter output to corresponding layer mask. Use aligned layers to combine multiple exposures.")
#@gui : sep = separator()
#@gui : Contrast bias = float(0.3,0,1)
#@gui : Saturation bias = float(0.3,0,1)
#@gui : Exposure Sigma = float(0.2,0,1)
#@gui : Exposure bias = float(0.3,0,1)
#@gui : BlurMap = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2014/11/30 v2</i>.</small>")
##@gui : note = link("Based on article","http://research.edm.uhasselt.be/tmertens/papers/exposure_fusion_reduced.pdf")

#Sub, Contrast bias factor, returns absolute laplacian
Sub_Contrast_Bias:
-div[-1] 255
-to_gray[-1]
-laplacian[-1]
-abs[-1]
#End Of Sub

#Sub, Saturation bias factor, returns standard deviatin of picel values
Sub_Saturation_Bias:
#1: Calculate average values
-div[-1] 255
--split[0] c
-blend[-1,-2,-3] average #Destroyes images 1,2,3, leaves 0 and 1
#2: Calculate difference values
-split[0] c # images ,0, R1,G2,B3; 0 contains average
#Probable error on removing next image.
#Commented out on 30.11.2014
#-rm[0]
--sub[0] [1] # images ,0, R1,G2,B3,DR4
-rm[1] # images ,0,,G2,B3,DR4
--sub[0] [1] # images 0,,G1,B2,DR3,DG4
-rm[1] # images ,0,,,B1,DR2,DG3
--sub[0] [1] # images 0,,,B1,DR2,DG3,DB4
-rm[1] # images ,0,,,,DR1,DG2,DB3
-rm[0] # images ,,,,,DR1,DG2,DB3
#Raise to power
-pow[0] 2 #DR1²
-pow[1] 2 #DR2²
-pow[2] 2 #DR3³
#sum
-add[1] [2] #DR1²,DR3²+DR2²,DR3²
-rm[2]
-add[0] [1] #DR1²+(DR3²+DR2²),DR3²+DR2²
-rm[1] #DR1²+(DR3²+DR2²)
#Population has three datapoints, divide by 3
-div[0] 3
#Standard deviation
-sqrt[0]
#End Of Sub

#Sub, Exposure bias factor
#Wchannel=exp(-(V-0.5)²/(2*sigma*sigma))
#V-0.5
Sub_Exposure_Bias :
-div[0] 255
-sub[0] 0.5
-pow[0] 2
-div[0] {2*$1*$1}
-mul[0] -1
-exp[0]
-split[0] c #1,2,3
-mul[0] [2]
-rm[2]
-mul[0] [1]
-rm[1]
#End Of Sub

#Sub, Pyramid blurring
Sub_BlurPyramid :
#Calculate size
size={0,min(w,h)}
levels={round(log($size)/log(5))}
Deviation=1

#Scale down and blur
-blur[0] $Deviation,1,1 #Blur image 100
-repeat {$levels-1}
	--resize[-1] 50%,50%,5,1 #Scale subsequently down, create {$levels-1} images
	-blur[-1] $Deviation,1,1 #Blur scaled image
-done

#Scale up and blend
blndalpha=0.5
-repeat {$levels-1}
	index={-($<+1)} #Image index to blend, start at next step of pyramid and progress to smaller iteratins
	-resize[$index] [0],5,1
	-blend[0,$index] alpha,$blndalpha,0
	blndalpha={$blndalpha/2} #Reduce opacity of blending by factor of 2 on each iteration
-done

#Main, Combined weight
fx_ExposureWeightMap :
wc=$1
ws=$2
sigma=$3
we=$4
BlurMap=$5
-to_rgb[0]
--Sub_Contrast_Bias[0] #CB, 0,1
--Sub_Saturation_Bias[0] #SB, 0,1,2
--Sub_Exposure_Bias[0] $sigma #EB, 0,1,2,3
-rm[0] #0,1,2
#Weight W=CB^wc+SB^ws+EB^we
-pow[0] $wc
-pow[1] $ws
-pow[2] $we
-add[0] [1]
-add[0] [2]
-keep[0]
-normalize[0] 0,255
#Blur mask
-if {$BlurMap==1}
		-Sub_BlurPyramid[0]
-endif
#End Of Main

fx_ExposureWeightMapPreview :
  -gui_split_preview "-fx_ExposureWeightMap ${1--2}",$-1

#******************************************
#END OF FILTER
#******************************************

############################
#Smooth sketch
############################
#@gui Smooth Sketch : fx_SmoothSketch, fx_SmoothSketch_preview(0)
#@gui : note = note("Convert image to black and white sketch. By default gradient edges are used but if filter input set to Active and Below a premade edge layer can be used from the layer below. Sketch strength slider will not have any effect if premade edges layer is used.")
#@gui : sep = separator()
#@gui : note = note("Sketch and edges")
#@gui : Create sketch = bool(1)
#@gui : Sketch strength = float(6,0,20)
#@gui : Sharpness = float(0.8,0,1)
#@gui : Anisotropy = float(0.3,0.1,1)
#@gui : Smoother scaling = float(0.3,0.1,2.5)
#@gui : Smoother Degradation = float(0,0,1)
#@gui : Smoothing amplitude = float(1000,1,3000)
#@gui : Smudge angle = float(0,-180,180)
#@gui : sep = separator()
#@gui : note = note("Empty area coloring")
#@gui : Coloring density = float(50,0,200)
#@gui : Coloring stroke length = float(10,0,100)
#@gui : Coloring style = choice(2,"Linear","Angular","Linear wavy","Angular wavy")
#@gui : Coloring opacity = float(0.6,0,1)
#@gui : sep = separator()
#@gui : note = note("Post processing parameters")
#@gui : Post gamma = float(0.55,0.1,2)
#@gui : Fast = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2014/08/31</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/groups/gmic/discuss/72157628307225747")

fx_SmoothSketch :
UsmRadius=5
CreateSketch=$1
UsmAmount=$1
Sharpness=$2 #Sharpness for diffusion tensor
Anisotropy=$3
SmScale=$4
SmAccuracy={$5}
Amplitude=$6 #Smoothing ampliture
fi=$7 #Rotation angle for tensor field
Density=$8 #Noise density
BlurLength=$9 #blur length
Style=$10 #Bg Style selection
BgOpacity=$11 #Bg blend opacity
PostGamma=$12 #Gamma correction
OptimizedResult=$13

-if $OptimizedResult
	OriginalWidth={0,w}
	#Resize to 1024 width (all in case a bottom layer is included
	-resize2dx 1024
	-fx_smooth_selective[-1] 5,0.5,5,1,0,0,24,0
-endif

-if {$CreateSketch==1}
	#Unsharp to enhance edges and detail
	#-unsharp[-1] $UsmRadius,$UsmAmount
	-fx_unsharp[-1] 0,$UsmRadius,30,$UsmAmount,0,1,1,1,0,0,0
	#Gradient norm for lines
	--gradient_norm[-1]
	#Invert for white bg
	-negate[-1]
	#Normalize for max range
	-normalize[-1] 0,255
-endif

##Noise gb for smudging
#New white image
(255;255;255)
#Resize to image size
-r[-1] [-2]
#Add noise
-fx_noise[-1] $Density,0,3,0,0

#Blurr and deform bg according to choice
-if {$Style==0}
	-fx_blur_linear[-1] $BlurLength,0,135,500,1,3,0,0
-endif
-if {$Style==1}
	-fx_blur_angular[-1] $BlurLength,1.2,1.2,0,0,0
-endif
-if {$Style==2}
	-fx_blur_linear[-1] $BlurLength,0,135,500,1,3,0,0
	-deform[-1] {$Density/5}
-endif
-if {$Style==3}
	-fx_blur_angular[-1] $BlurLength,1.2,1.2,0,0,0
	-deform[-1] {$Density/5}
-endif

#Blend bg and edge
-blend[-1,-2] multiply,$BgOpacity,0
-normalize[-1] 0,255
--diffusiontensors[0] $Sharpness,$Anisotropy,0.6,1.1,0 #Create diffusion tensor field from original.
-rotation3d 0,0,1,{$fi} #It seems this creates a new image "a rotation matrix" Subtract 45 because this gives sharp image at 0 degrees.
-mix_channels[-2] ({@0-2};{@3-5};{@6-8}) #Channel mixer is used here with the rotation matrix
-rm[-1] #remove rotation matrix
#Scale matrix, this was changed to static and
#parameter used for diffusion tensor anisotropy
-mul[-1] {$SmScale/max(abs(iM),abs(im))}
-noise[-1] {$SmAccuracy*max(abs(iM),abs(im))}
-reverse[-1,-2]
-smooth[-1] [-2],$Amplitude
-keep[-1]
-apply_gamma[-1] $PostGamma

-if $OptimizedResult
	-resize2dx $OriginalWidth
-endif

fx_SmoothSketch_preview :
  -gui_split_preview "-fx_SmoothSketch ${1--2}",$-1

#******************************************
#END OF FILTER
#******************************************


#****************************************
#Composition analysis
#****************************************
#@gui Composition analysis : fx_CompositionAnalysis, fx_no_preview
#@gui : note = note("A tool to abstract the image for subjective composition analysis. Two different methods are available. Set filter output to New layers. For actual analysis the aesthetic sense of the artist is required.")
#@gui : Method = choice(0,"Thumbnail abstraction","Value and lines")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2015/01/17</i>.</small>")

sub_thumbnailabstraction :
#To RGB
-to_rgb[0]
IWidth={0,w}
IHeight={0,w}
#FInd out which is larger and scale accordingly
-if {$IWidth>=$IHeight}
	ScaleByWidth=1
-endif

#Resize to 100 px on larger dimension
-if {$ScaleByWidth==1}
	--resize2dx[0] 200,5
	-blur[-1] 2
	#Resize to 1024 px
	-resize2dx[-1] 1024,5
	#Segmentation
	-fx_segment_watershed[-1] 0.5,5,0,0

-elif
	--resize2dy[0] 200,5
	-blur[-1] 2
	#Resize to 1024 px
	-resize2dy[-1] 1024,5
	#Segmentation
	-fx_segment_watershed[-1] 0.5,5,0,0
-endif
#Resize to original size for output
-resize[-1] [0]
#Luminance analysis
--rgb2lab[0]
-split[-1] c
-rm[-1,-2]
-blur[-1] 10%
-normalize[-1] 0,255
-blend[-1,-2] hardlight,1,1
-keep[-1]

sub_colors_and_lines :
image_width={0,w}
image_height={0,h}
-resize2dx 1024
-luminance[0]
-normalize 0,255
-to_rgb[0]
-fx_smooth_bilateral[0] 2,15,2,0,0,24,0
-fx_colormap[0] 0,0,3,3,0,0,0,255,255,255,255,0,0,0,255,0,0,0,255,255,255,0,255,0,255,0,255,255,0
--fx_smooth_anisotropic[0] 300,0.1,1,0,10,1,1,1,0,1,1,0,0,24,0
-fx_gradient_norm[-1] 0,0.5,0,100,1,0
-blend[0,1] multiply,1
-resize[-1] $image_width,$image_height,1,3,5,1

fx_CompositionAnalysis :
method=$1
-if {$method==0} -sub_thumbnailabstraction -endif
-if {$method==1} -sub_colors_and_lines -endif



#****************************************
#Blockism
#****************************************
#@gui Blockism : fx_blockism, fx_blockism_preview(1)
#@gui : note=note("Renders rectangles on to the image.")
#@gui : note=note("Parameters")
#@gui : Relative size = float(3,0,20)
#@gui : Ratio = float(1.6,1,10)
#@gui : Size Variance = float(0.5,0,10)
#@gui : Relative block count = int(50,0,500)
#@gui : Opacity = float(0.5,0,1)
#@gui : Flip tolerance = int(64,0,255)
#@gui : Reverse flip = bool(0)
#@gui : Quick = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/8063058705/")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2012/10/07</i>.</small>")

fx_blockism:
XSize={int($1/100*w)}
-if {$XSize==0} XSize=1 -endif
Ratio=$2
Variance={int($3*$XSize)}
Randomness=-1,1
Repeats={int($4/100*max(w,h))}
Opacity=$5
FlipTol=$6
ReverseFlip=$7
LAB=1-$8
#Calculate Y size and max size for the block
YSize={int($Ratio*$XSize)}
MaxXSize={int($XSize+$Variance)}
MaxYSize={int($MaxXSize*$Ratio)}
#Force RGB (remove alpha)
-to_rgb[0]
#Split image to LAB channels if not quick
-if {$LAB}
	-rgb2lab[0]
	-split[0] c
-endif
#Render blocks
-repeat $!
	#Take copy of the last image in the stack for grey value checking
	[-1]
	-repeat $Repeats
		#Random point from canvas to draw the block on
		X={int(u(-1,w))}
		Y={int(u(-1,h))}
		#If the value is below threshold then invert width and length
		#note that quick uses only Red channel to flip
		-if {$ReverseFlip==0}
			-if {i($X,$Y,0,0)>$FlipTol}
				#Calculcate block size. Interpolate linearly with random value
				#Linear interpolation is
				#y=ya+(yb-ya)(x-xa)/(xb-xa)
				#x is random value between -1 and 1
				#ya is minimum block size
				#yb is maximum block size
				#y is block size
				#abs is used to invert negative values to positive
				BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
				BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
			-endif
			-if {i($X,$Y,0,0)<=$FlipTol}
				BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
				BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
			-endif
		-endif
		-if {$ReverseFlip==1}
			-if {i($X,$Y,0,0)<$FlipTol}
				BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
				BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
			-endif
			-if {i($X,$Y,0,0)>=$FlipTol}
				BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
				BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
			-endif
		-endif
		#Calcualte corners
		x0={int($X-$BW/2)}
		y0={int($Y-$BH/2)}
		x1={int($x0+$BW)}
		y1={int($y0+$BH)}
		#Draw a rectangle with the gray of the block center value  of the L, A or B channel
		-rectangle[-2] $x0,$y0,$x1,$y1,$Opacity,{i($X,$Y,0,0)},{i($X,$Y,0,1)},{i($X,$Y,0,2)},{i($X,$Y,0,3)}
	-done
	-remove[-1]
	-mv[-1] 0
-done
-if {$LAB}
	-append[-3,-2,-1] c
	-lab2rgb[-1]
-endif
fx_blockism_preview :
 -gui_split_preview "-fx_blockism $1,$2,$3,{$4*10},$5,$6,$7,$8",$-1


#****************************************
#HDR black fixing
#****************************************
#@gui Night HDR image black noise correction: fx_fix_HDR_black, fx_fix_HDR_black_preview(0)
#@gui : note=note("Filter to remove blue, magenta and red noise from the black areas of HDR images. Filter is designed specifically for HDR night shots but may work on other images as well. Bilateral filtering and Haar Wavelets are used to filter the noise from the image and mask is used to apply the noise removal only to dark areas.")
#@gui : sep = separator(), note=note("Mask opacity settings, Black values must be lower than Highlight values. Tick Show mask to view mask and to see the effect of the sliders.")
#@gui : note=note("Black cutoff")
#@gui : X-coord(1) = int(20,0,255)
#@gui : Y-coord(1) = int(25,0,255)
#@gui : note=note("Highlight raising")
#@gui : X-coord(2) = int(50,0,255)
#@gui : Y-coord(2) = int(200,0,255)
#@gui : Show mask = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2013/11/02</i>.</small>")
fx_fix_HDR_black:
-to_rgb[0]
X1=$1
Y1=$2
X2=$3
Y2=$4
ShowMask=$5
--fx_smooth_bilateral[-1] 4,8,6,4,0 #0,1
-fx_smooth_haar[-1] 0.6,5,2,3,1,24 #0,1
--rgb2lab[-1] #0,1,2
-split[-1] c #0,1,2,3,4
-rm[-1,-2] #0,1,2(luminance info of smoothed image only)
-fx_apply_curve[-1] 0,$X1,$Y1,$X2,$Y2,-1,128,-1,128,-1,128,255,1,0,0,21,0
-if {$ShowMask==0}
	-negate[-1] #Negative of Luminance
	-append[-2,-1] c #append luminance info to smoothed image
	-to_rgba[-1] #0,1,force RGBA for 1
	-blend[0,-1] alpha #Blend with original
	-keep[0]
-endif

fx_fix_HDR_black_preview :
  -gui_split_preview "-fx_fix_HDR_black ${1--2}",$-1


#************END OF FILTER*************


#****************************************
#Noise paint
#****************************************
#@gui Noise Painting : fx_noisepainting, fx_noisepainting_preview(0)
#@gui : note = note("A preprocess suggestion for the painting filter.")
#@gui : sep = separator(), note = note("Pre process for painting")
#@gui : Spread noise = int(0,0,20)
#@gui : Additive noise = int(0,0,30)
#@gui : Luminance only = bool(0)
#@gui : sep = separator(), note = note("Painting abstration")
#@gui : Abstraction = int(5,1,10)
#@gui : Details scale = float(2.5,0,5)
#@gui : Color = float(1.5,0,4)
#@gui : Smoothness = float(50,0,1000)
#@gui : Sharpen shades = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2012/07/12</i>.</small>")
fx_noisepainting :
DegrLarge=$1
DegrSmall=$2
Channel=$3
Abstr=$4
Details=$5
Color=$6
Smooth=$7
Sharp=$8
-to_rgb[0]
-if {$Channel} Channel=3 -elif Channel=0 -endif
     #Pre segmentation
     -if $PreProcess -fx_segment_watershed $EdgeThresh,$WaterSmooth,0,0 -endif
     #Degradation with additive noise
     -if {$DegrLarge!=0} -fx_spread $DegrLarge,$DegrLarge,0,0 -endif
     # -fx_noise 47.0046,2,3,0,0
   -if {$DegrSmall!=0} -fx_noise $DegrSmall,2,$Channel,0,0 -endif
     -fx_painting $Abstr,$Details,$Color,$Smooth,$Sharp,0
fx_noisepainting_preview :
  -gui_split_preview "-fx_noisepainting ${1--2}",$-1

#****************************************
#BW film simulation
#****************************************
#@gui Black &amp; White Film : fx_bwfilmsimulate, fx_bwfilmsimulate_preview(1)
#@gui : Film type / RGB balance = choice(0,"Manual","Agfa 200X","Agfapan 25","Agfapan 100","Agfapan 400","Iford Delta 100","Iford Delta 400","Iford Delta 400 pro & 3200","Ilford FP4","Ilford HP4","Ilford Pan F","Ilford SFX","Ilford XP2 Super","Kodak Tmax 100","Kodak Tmax 400","Kodak Tri-X")
#@gui : note = note("Simpler version available in main tree. This filter will be removed in future from testing. PM me if you need this for some reason.")
#@gui : note = note("RGB sliders work only with manual selection")
#@gui : Red level = float(0.299,0,1)
#@gui : Red smoothness = float(0,0,10)
#@gui : Green level = float(0.587,0,1)
#@gui : Green smoothness = float(0,0,10)
#@gui : Blue level = float(0.114,0,1)
#@gui : Blue smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Gamma = float(1,0.01,5)
#@gui : Contrast = float(1,0,4)
#@gui : Brightness = float(0,-255,255)
#@gui : Hue = float(0,0,360)
#@gui : Saturation = float(0,0,1)
#@gui : sep = separator()
#@gui : Grain (shadows) = float(0,0,200)
#@gui : Grain (midtones) = float(0,0,200)
#@gui : Grain (highlights) = float(0,0,200)
#@gui : Grain tone fading = float(2,0,10)
#@gui : Grain scale = float(0,0,3)
#@gui : Grain type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : sep = separator()
#@gui : Local contrast = float(0,0,60)
#@gui : Radius = int(16,1,512)
#@gui : Contrast smoothness = float(4,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>David Tschumperl&#233, Arto Huotari;</i>.      Latest update : <i>2019/09/28</i>.</small>")
fx_bwfilmsimulate :
Choice=$1
P1=$2
P2=$3
P3=$4
P4=$5
P5=$6
P6=$7
P7=$8
P8=$9
P9=$10
P10=$11
P11=$12
P12=$13
P13=$14
P14=$15
P15=$16
P16=$17
P17=$18
P18=$19
P19=$20
P20=$21
-if {$Choice==1} P1={18/255} P3={41/255} P5={41/255} -endif
-if {$Choice==2} P1={25/255} P3={39/255} P5={36/255} -endif
-if {$Choice==3} P1={21/255} P3={40/255} P5={39/255} -endif
-if {$Choice==4} P1={20/255} P3={41/255} P5={39/255} -endif
-if {$Choice==5} P1={21/255} P3={42/255} P5={37/255} -endif
-if {$Choice==6} P1={22/255} P3={42/255} P5={36/255} -endif
-if {$Choice==7} P1={31/255} P3={36/255} P5={33/255} -endif
-if {$Choice==8} P1={28/255} P3={41/255} P5={31/255} -endif
-if {$Choice==9} P1={23/255} P3={37/255} P5={40/255} -endif
-if {$Choice==10} P1={33/255} P3={36/255} P5={31/255} -endif
-if {$Choice==11} P1={36/255} P3={31/255} P5={33/255} -endif
-if {$Choice==12} P1={21/255} P3={42/255} P5={37/255} -endif
-if {$Choice==13} P1={24/255} P3={37/255} P5={39/255} -endif
-if {$Choice==14} P1={37/255} P3={36/255} P5={37/255} -endif
-if {$Choice==15} P1={25/255} P3={35/255} P5={40/255} -endif


   -repeat $!
    -l[-1] -split_opacity -rv -to_rgb[-1] -s[-1] c          # Isolate opacity
    -*[-3] $P1 -b[-3] $P2%                                    # Red contrast + smoothness
    -*[-2] $P3 -b[-2] $P4%                                    # Green contrast + smoothness
    -*[-1] $P5 -b[-1] $P6%                                    # Blue contrast + smoothness
    -+[-3--1] -/[-1] {$P1+$P3+$P5} -c[-1] 0,255                # (R,G,B) -> B&W

    -apply_gamma[-1] $P7                                     # Gamma correction
    --[-1] 128 -*[-1] $P8 -+[-1] 128 -+[-1] $P9 -c[-1] 0,255  # B&W contrast and brightness.

    100%,100% [-1]x2                                        # Create noise for shadows, midtones and highlights.
    -noise[-3] 100,$P17 -b[-3] $P16% -n[-3] -$P12,$P12          # Scaled grain on shadows.
    -noise[-2] 100,$P17 -b[-2] $P16% -n[-2] -$P13,$P13          # Scaled grain on midtones.
    -noise[-1] 100,$P17 -b[-1] $P16% -n[-1] -$P14,$P14          # Scaled grain on highlights.

    --tones[-4] 3 -b[-3--1] $P15%                            # Get smoothed tones.
    -*[-6,-3] -*[-4,-2] -*[-2,-1]                           # Get noisy tones.
    -+[-4--1] -c[-1] 0,255                                  # Compose them with the B&W image.

    -if {$P10||$P11}
      -/[-1] 255
      -i[-2] 100%,100%,1,1,$P11
      -i[-3] 100%,100%,1,1,$P10
      -a[-3--1] c -hsv2rgb[-1]
    -endif

    -rv -a c -endl -mv[-1] 0 -done                          # Re-compose opacity and loop to next image.
  -normalize_local $P18,$P19,$P20,2%,1,0,255

fx_bwfilmsimulate_preview :
  -gui_split_preview "-fx_bwfilmsimulate ${1--2}",$-1


#****************************************
#Warp test
#****************************************
#@gui Warp test : fx_WarpTest, fx_WarpTest
#@gui : sep = separator()
#@gui : note=note("Two layers required if automap is not used. <b>Set input to active and below</b>. Filter offsetts image with a vector field map. Map is created from R and G channels so that R128,G128 becomes [0 0]. Experiment with solid 128,128,0 color layer and add hues of red and green. Angle shift rotates the vector field and Zero point offset moves the default 0 0 point. This is mainly for fun and testing.")
#@gui : sep = separator()
#@gui : Map type = choice("Automap","Layer Map")
#@gui : Angle shift = float(0,-180,180)
#@gui : Zero point offset = float(0,-128,128)
#@gui : Vector length multipler = float(1,0.1,128)
#@gui : sep = separator()
#@gui : note = note("Optional viewing of vector field")
#@gui : Show Quiver = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2012/02/28</i>.</small>")

fx_WarpTest :
#Variables
MapType=$1
fi={$2*3.1415/180}
ZeroOffset=$3
LMult=$4
ShowQuiver=$5

-if {$MapType==0}
	--fx_local_orientation 0.5,0,100,0,4,0
-endif

#Angles for rotation
cosfi={cos($fi)}
sinfi={sin($fi)}

-to_rgb[-2,-1]
#set origin 128,128 to 0,0
--[-1] {128+$ZeroOffset}
-split[-1] c #there were 2 images in the stack, now there are 4, 0,1,2,3, -1 was used in split
#Force blue channel to 0
-mul[3] 0
#Channel -3 = X values = image [1]
#Channel -2 = Y values = image [2]
#Channel -1 is zero = image [3]
#Rotation for X coord is x'=Xcosfi-Ysinfi
#Calculate first Xcosfi and Ycosfi to new image#
--mul[1] $cosfi #xcosfi this is now image 4
--mul[2] $sinfi #ysinfi this is now image 5
#Calculate new X coord
-sub[4] [5]
-rm[5]
#Calculate new Y coord x'=Xsinfi+Ycosfi
--mul[1] $sinfi #xsinfi this is now image 5
--mul[2] $cosfi #yxosfi this is now image 6
-add[5] [6]
-rm[6]
-rm[1,2] #Image 3 becomes 1, 4x' becomes 2 and 5y' becomes 3
-rm[1] 	#Image 1z deleted, 2x' becomes 1 and 3y' becomes 2
100%,100%,100%,1,0
-append[1,2,3] c
#Divide with 128 to "normalize" between -1 1 (not true for non zero offsets)
-/[-1] {128/$LMult}
-channels[-1] 0,1
-if {$ShowQuiver==0}
#	-vector2tensor[-1]
#	-smooth[-2] [-1],$Amplitude
	-warp[-2] [-1],1,1,0
-endif
-if {$ShowQuiver==1}
	-quiver[-2] [-1],10,{$LMult/100},1,0.8,255
-endif
-rm[-1]


#****************************************
#Dodge sketch
#****************************************
#@gui Dodge sketch : fx_dodgesketch, fx_dodgesketchpreview(0)
#@gui : note = note("Simple BW sketch"),note = link("Method is described here","http://www.gimpusers.com/tutorials/making-a-pencil-drawing-from-a-photo.html")
#@gui : note = note("in addition an option to color the sketch is included")
#@gui : sep = separator(), note = note("Power setting for sketch")
#@gui : Power = int(3,0,10)
#@gui : sep = separator(), note = note("Presmoothing settins of bilateral filter")
#@gui : Spatial variance = float(10,0,100)
#@gui : Value variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator()
#@gui : Colored? = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")

fx_dodgesketch:
#remove alpha channel
-to_rgb[0]
Power=$1
SpatialVariance=$2
ValueVariance=$3
Iterations=$4
Colored=$5

#Remove color, add as new incase org can be later used for "colored"
--fx_mix_hsv[0] 1,0,0,0,-1,0,1,0,0,0,2,0
#Smooth with bilateral filter
--fx_smooth_bilateral[-1] $SpatialVariance,$ValueVariance,$Iterations,0,0
#Invert colors of smoothed image
-negate[-1]
#Compose inverted image with 0.5 opacity to BW
-blend[-1,-2] alpha,0.5,0
#Take duplicate of previous
[-1]
#Make BW lines
--blend[-1,-2] dodge,1,0
#Clear mem
-keep[0,-1]

#Use repeat loop to multiply the sketch
-repeat $Power
	[-1]
	-blend[-1,-2] multiply
-done

-if {$Colored==1}
	--blend[-1,-2] hardlight #image -1 i.e. image 3
	-remove[-2]
	-fx_transfer_colors[-1,-2] 0,0
-endif

-keep[-1]

fx_dodgesketchpreview :
  -gui_split_preview "-fx_dodgesketch ${1--2}",$-1

#****************************************
#MappedSmoothing
#****************************************
#@gui Mapped Smoothing : fx_MappedSmooth, fx_MappedSmooth
#@gui : sep = separator()
#@gui : note=note("Two layers required if automap is not used. <b>Set input to active and below</b>. Filter Smooths image with a vector field map. Map is created from R and G channels so that R128,G128 becomes [0 0]. Experiment with solid 128,128,0 color layer and add hues of red and green. Angle shift rotates the vector field and Zero point offset moves the default 0 0 point. This is somewhat a development version, sample art is still missing.")
#@gui : sep = separator()
#@gui : Map type = choice("Automap","Layer Map")
#@gui : Angle shift = float(0,-180,180)
#@gui : Zero point offset = float(0,-128,128)
#@gui : Amplitude = float(300,10,10000)
#@gui : Vector length multipler = float(1,0.1,5)
#@gui : sep = separator()
#@gui : note = note("Optional viewing of vector field")
#@gui : Show Quiver = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2012/02/25</i>.</small>")

fx_MappedSmooth :
#Variables
MapType=$1
fi={$2*3.1415/180}
ZeroOffset=$3
Amplitude=$4
LMult=$5
ShowQuiver=$6

-if {$MapType==0}
	--fx_local_orientation 0.5,0,100,0,4,0
-endif

#Angles for rotation
cosfi={cos($fi)}
sinfi={sin($fi)}

-to_rgb[-2,-1]
#set origin 128,128 to 0,0
--[-1] {128+$ZeroOffset}

-split[-1] c #there were 2 images in the stack, now there are 4, 0,1,2,3, -1 was used in split
#Force blue channel to 0
-mul[3] 0
#Channel -3 = X values = image [1]
#Channel -2 = Y values = image [2]
#Channel -1 is zero = image [3]
#Rotation for X coord is x'=Xcosfi-Ysinfi
#Calculate first Xcosfi and Ycosfi to new image#
--mul[1] $cosfi #xcosfi this is now image 4
--mul[2] $sinfi #ysinfi this is now image 5
#Calculate new X coord
-sub[4] [5]
-rm[5]
#Calculate new Y coord y'=Xsinfi+Ycosfi
--mul[1] $sinfi #xsinfi this is now image 5
--mul[2] $cosfi #yxosfi this is now image 6
-add[5] [6]
-rm[6]
-rm[1,2] #Image 3 becomes 1, 4x' becomes 2 and 5y' becomes 3
-rm[1] 	#Image 1z deleted, 2x' becomes 1 and 3y' becomes 2
100%,100%,100%,1,0
-append[1,2,3] c
#Divide with 128 to "normalize" between -1 1 (not true for non zero offsets)
-/[-1] {128/$LMult}
-channels[-1] 0,1
-if {$ShowQuiver==0}
	-vector2tensor[-1]
	-smooth[-2] [-1],$Amplitude
-endif
-if {$ShowQuiver==1}
	-quiver[-2] [-1],10,{$Amplitude/20},1,0.8,255
-endif
-rm[-1]

#****************************************
#Gimp Rotation Demo
#****************************************
#@gui Vector Field Rotation Demo : fx_DemoVecRot, fx_DemoVecRot
#@gui : note=note("Vector field rotation and quiver sample")
#@gui : Angle shift = float(0,-180,180)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i> with help from <i>David Tschumperl&#233;</i>.     Latest update : <i>2012/02/25</i>.</small>")
fx_DemoVecRot :
angle=$1
#Force to RGB (remove possible alpha channel)
-to_rgb[0]
#Take a copy of the input to work on
[0]
#Force the copy to RGB just in case. This is not actually needed and just takes time.
-to_rgb[-1]
#Split image along channels
-split[-1] c
#Subtract 128 from red and green channels
--[-2] 128
--[-3] 128
#Append channels back to one image
-append[-3,-2,-1] c
#Drop third channel from the field
#other vise matrix multiplication at rotation and quiver will not work
-channels[-1] 0,1
#Divide by 128 to scale length
-/[-1] 128
#Rotation code from David
	#200,200,1,2 200x200x1 px only two channels
	-rotation3d 0,0,1,$angle #It seems this creates a new image "a rotation matrix"
	-z[-1] 0,0,1,1 #This crops the rotation matrix, I do not know why
	-mix_channels[-2] ({@0-1};{@2-3}) #Channel mixer is used here with the rotation matrix
	-rm[-1] #remove rotation matrix
#End rotation code
#Quiver takes only two channels in. It will give an error othervise
-quiver[-2] [-1],10,10,1,0.8,255
-keep[-2]


#****************************************
#Structure tensors
#****************************************
#@gui GMic Structure Tensors : fx_StructureTensors, fx_StructureTensorsPreview(0)
#@gui : sep = separator()
#@gui : note = note("Structure tensors calculation for Gimp plugin. This is just an interface to built in GMic Structure tensors command")
#@gui : Power = float(0.1,0.1,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2011/12/06</i>.</small>")
##@gui : note = link("Filter Explained here","http://gmic.sourceforge.net/reference.shtml")

fx_StructureTensors:
-structuretensors -abs -pow $1
-normalize 0,255

fx_StructureTensorsPreview :
  -gui_split_preview "-fx_StructureTensors ${1--2}",$-1

#************END OF FILTER*************


#****************************************
#Old Make Squiggly
#****************************************
#@gui Make Old Squiggly : fx_OldSquiggly, fx_OldSquiggly
#@gui : note = note("Development version. This version will be removed in future from sources so if you prefer this then copy and save the source to your local .gmic file")
#@gui : Spread noise amount  = float(2,0,20)
#@gui : Segmentation Edge threshold = float(12,0,15)
#@gui : Segmentation Smoothness = float(0.8,0,5)
#@gui : GradienNormSmoothness = float(0,0,10)
#@gui : GradienNormLinearity = float(0.5,0,1.5)
#@gui : IncreaseChroma1 = float(3,1,4)
#@gui : Tone threshold = float(0.2,0,1)
#@gui : Tone gamma = float(0.4,0,1)
#@gui : Paper Grayness = int(50,0,255)
#@gui : Paper whiteness = int(245,0,255)
#@gui : Squiggle Gamma = int(45,1,128)
#@gui : Squiggle Multiplier = float(0.5,0,1)

fx_OldSquiggly :
--fx_spread[0] $1,$1,0,0  #Spread noise (image1)
-fx_segment_watershed[1] $2,$3,0,0   #Segmentation (image1)
--fx_gradient_norm[1] $4,$5,0,100,0,0 #Gradient norm (image2)

#Create colorized squiggle
--blend[2,1] multiply #image 3
#Increase chroma threes have been modified from 1 and
-fx_mix_ycbcr[3] 1,0,0,$6,0,0,$6,0,0,0,2,0 #image 3

#Tonemap original
-fx_map_tones[0] $7,$8,0.1,30,0,0 #image 0
#-fx_apply_curve[0] 0,30,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
#Compose Squigglies to original
-blend[0,3] darken #it seems image 3 is destroyed in this op.

-remove[1,2] #remove extra images to save memory 3->0

#Create paper
#--fx_plasma 0.5,10 #Image 1
--fx_plasma 0.5,10,8,0 #Image 1
-fx_blackandwhite[1] 0.299,0,0.587,0,0.114,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0
#adjust paper lightness, 7 and 215 need to be parameters
-fx_apply_curve[1] $9,-1,128,-1,128,-1,128,-1,128,-1,128,$10,1,3,0,0,0

#Adjust squiggly
-fx_apply_curve[0] 0,$11,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0

#Combine paper and squiggly
-mul[0] {0.5*(1+$12)}
-mul[1] {0.5*(1-$12)}

--add[0] [1] #image 2

--blend[0,2] softlight #image 3
-remove[0,1,2]


#************END OF FILTER*************
#***********************************
#AbstractFlood
#************************************
#@gui Abstract Flood : fx_AbstractFlood, fx_AbstractFlood_Preview(1)
#@gui : sep = separator()
#@gui : note = note("Warning: Really really slow filter especially with Cubism enabled. Use a maximum of 1 megapixel image. Random walk algorihm is used to select new areas to flood. If Cubism is enabled the filter has to run cubims for every succesful repeat defined in the flood settings section.")
#@gui : Preprocess with bilateral filtering = bool(1)
#@gui : Spatial variance = float(10,0,100)
#@gui : Value variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator()
#@gui : note = note("Flood settings")
#@gui : Activate Flood = bool(0)
#@gui : Repeats = int(10,1,1000)
#@gui : Flood Tolerance = int(5,0,100)
#@gui : Flood base step = int(3,1,10)
#@gui : Canvas Color = color(255,255,255,255)
#@gui : sep = separator()
#@gui : note = note("Abstraction setting, Consider disabling preview if using high flood repeats!")
#@gui : Activate Cubism = bool(0)
#@gui : Cubism Iterations = int(300,1,2000)
#@gui : Bloc size = float(10,0,40)
#@gui : Angle = float(90,0,360)
#@gui : Opacity = float(0.7,0.01,1)
#@gui : Smoothness = float(0,0,5)
#@gui : note = note("Opacity threshold used to make decision about flooding. Use 0 if Cubism is not enabled.")
#@gui : Opacity tolerance = int(0,0,254)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6243715666")

fx_AbstractFlood :

#Parameters from input
Prep=$1
SpatialVariance=$2
ValueVariance=$3
Iterations=$4
ActivateFlood=$5
Repeats=$6
Tolerance=$7
FloodBaseStep=$8
CanvasR=$9
CanvasG=$10
CanvasB=$11
Opacity=$12
ActivateCubism=$13
CubismIterations=$14
Blocsize=$15
Angle=$16
CubismOpacity=$17
Smoothness=$18
StepThreshold={$19+0.1} #Threshold for opacity, has pixel been flooded or not

Step=$FloodBaseStep
Delta=1 #Base step addition i.e. how much the bug step is increased if the pixel was not good place to make flood
#Save delta org for later use
DeltaOrg=$Delta

#add alpha channel to original just in case
-to_rgba[0]

#Preprocess with bilateral filtering
-if {$Prep==1}
-fx_smooth_bilateral[0] $SpatialVariance,$ValueVariance,$Iterations,0,0 #image 0
-endif
#Make bg for composing. Bg is transparent so that alpha can be used to
#determine if operation should be done.
({$CanvasR}^{$CanvasG}^{$CanvasB}^0) #image 1

-to_rgba[1] #force to RGBA just in case
-r[1] [0] #resize to image size

#Start pattern from centre and proceed
#with random walk. start/centre point is
X={(w)/2}
Y={(h)/2}
#Grab image h and w for later use
ImageH={(h)}
ImageW={(w)}

#Set DoLoop decision parameters for later use
DoLoop=0
IsGood=0

#Go to loop if ActivateFlood = 1
-if {$ActivateFlood==1}

	#A comment here is needed
	-repeat $Repeats

		#The actual flood is done by this
		#-ellipse {100*$X/w}%,{100*$Y/h}%,{1},{1},{0},1,255,0,255
		-flood[0] {100*$X/w}%,{100*$Y/h}%,0,$Tolerance,0,1,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)} #Img0

		#Select the color that was flooded + others pixels of same color
		--fx_select_color[0] 0,1,0,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)},0,0 #image2

		-if {$ActivateCubism==1}
			#Treat color with Cubism
			-cubism[2] $CubismIterations,$Blocsize,$Angle,$CubismOpacity,$Smoothness
		-endif

		#Compose with alpha blending mode
		-blend[1,2] alpha

		#Calculate new coordinate in do while loop until
		#new coordinate has opacity lower than threshold
		#and new coordinate is whitin image boundary

		-do
			#Random step length is minimum step + delta which is dependent on how many attempts have been made
			Rstep={$Step+$Delta}
			#Random direction to go to
			theta={u(360)}
			#Add to previous coordinate to get new coord

			Xnew={int($X+$Rstep*cos($theta))}
			Ynew={int($Y+$Rstep*sin($theta))}

			#Check if new coordinate is good ie whitin image
			-if {{$Xnew>0}" && "{$Xnew<$ImageW}" && "{$Ynew>0}" && "{$Ynew<$ImageH}}
				#If coord was good set as new 'bug' location
				X=$Xnew
				Y=$Ynew
				#Check the alpha of new coord. If above threshold increase delta
				-if {1,i($X,$Y,0,3)>$StepThreshold}
					#Increase delta if no suitable pixel could be found on previous step
					#Delta is smaller of the previous
					#Base step size + do while loop number #or# one tenth of maximum image dimension
					Delta={min({$Delta+$Delta*2},{max($ImageW,$ImageH)/5})}
				-endif

				#Check the alpha of new coord,
				#if below threshold exit do-while and flood
				-if {1,i($X,$Y,0,3)<$StepThreshold}
					IsGood=10
				-endif
					#make sure that loop will be eventuall exited, run a max of 100 do-while loops
				-if {$DoLoop>100}
					IsGood=10
				-endif
			-endif
			#Increase do loop counter
			DoLoop=$DoLoop+1
		#Continue until IsGood has been set to 10
		-while {$IsGood<1}

		#Set trigger to bad i.e 0
		IsGood=0
		DoLoop=0
		Delta=$DeltaOrg
	-done

-endif

#Create specified color BG and Compose
({$CanvasR}^{$CanvasG}^{$CanvasB}^{$Opacity}) #image 2
-r[2] [0]
-reverse[1,2]
-blend[1,2] alpha

#Keep only result
-if {$ActivateFlood==1}
	-keep[1]
-elif  {$ActivateFlood==0}
	-keep[0]
-endif

fx_AbstractFlood_Preview :
  -gui_split_preview "-fx_AbstractFlood ${1--2}",$-1

#**********EndOfFilter*************

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
