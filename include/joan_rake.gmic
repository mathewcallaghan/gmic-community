#@gmic
#
#  File        : joan_rake.gmic
#                ( G'MIC commands file )
#
#  Description : The author of these filters ('Joan Rake', not her real
#                name) describes them as a gritty and overloaded series of
#                mistakes which will probably be frowned upon by hordes of
#                snobbish graphic designers. Good for them, Joan doesn't care.
#                At least not until they start overusing her filters to the
#                extent that everyone gets tired of them.
#
#  Copyright   : David Tschumperle
#                ( http://tschumperle.users.greyc.fr/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#@gui Vibrato Texture : fx_vibrato_texture, fx_vibrato_texture_preview(0)
#@gui : note = note("This filter is inspired by the Paint.NET plugin named Vibrato authored by MadJik for Paint.NET.")
#@gui : sep = separator()
#@gui : 1. X-Orientation = bool(1)
#@gui : 2. Y-Orientation = bool(1)
#@gui : 3. U- Factor = float(.85,.1,15)
#@gui : 4. V- Factor = float(.85,.1,15)
#@gui : 5. X-Scale Factor = float(1,.1,15)
#@gui : 6. Y-Scale Factor = float(1,.1,15)
#@gui : 7. XY-Scale Factor = float(1,.1,3)
#@gui : 8. Percentage-Based X Pixel Shift = float(0,-200,200)
#@gui : 9. Percentage-Based Y Pixel Shift = float(0,-200,200)
#@gui : 10. Elevation = float(.7,-1,1)
#@gui : 11. Z 0-1 Multiplier = float(.5,0.1,1)
#@gui : 12. Z Exponential Multiplier = float(1,1,15)
#@gui : 13. Apply Inversion Factor = bool(0)
#@gui : 14. Inversion Factor = float(1,-1,10)
#@gui : 15. Final Mod Factor = float(1,1,32)
#@gui : 16. Invert Vibrato = bool(0)
#@gui : sep = separator(), 17. Image Influence Factor = float(1,-8,8)
#@gui : sep = separator(), Channel(s) = choice{"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]"}
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>.      Latest update : <i>2018/09/26</i>.</small>")
fx_vibrato_texture:
ac "_fx_vibrato_texture ${1-18}",$18

_fx_vibrato_texture:
repeat $! l[$>]
#if {x+$1}
n 0,255 f "q=($8/100)*w; 
l=($9/100)*h; 
X=(($1?w-x+q:x+q)/w-.5) * 2 * 1/$5 * 1/$7; 
Y=(($2?h-y+l:y+l)/h-.5) * 2 * 1/$6 * 1/$7; 
g=1*13^(-$14); 
U=sqrt($3); 
V=sqrt($4);
Z=((X-Y) * (X-U) * (X+U) * (Y-V) * (Y+V))+ $10; 
D=$13?(1-(Z>g?Z:1-Z * -1)):Z;
C=(D+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$17)*(D+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$17)*$11*$12*$12;
F=abs(C)>1?C-int(C):C;
$16?F:1-F;
" n 0,255 mul $15 mod 256
# fi
endl done

fx_vibrato_texture_preview :
gui_split_preview "fx_vibrato_texture ${1--2}",$-1


#@cli invert_rgb
#@cli : Inverts images in the RGB colour space.
invert_rgb:
repeat $! split_opacity
l[0] c 0,255 *[$>] -1 +[$>] 255 endl
a c
done

#@cli invert_alpha
#@cli : Inverts the alpha channel of images.
invert_alpha:
repeat $! split_opacity
l[1] c 0,255 *[$>] -1 +[$>] 255 endl
a c
done

#@gui _<b>Testing</b>
#@gui <i>Joan Rake</i>

#@gui Mesh blend : fx_mesh_blend, fx_mesh_blend_preview(1)
#@gui : note = note("Universal blending algorithm. Resizes an RGB&#40;A&#41; image to a 256x256 image and uses it as an RGBA LUT 'transfer function mesh' to blend two other images together. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : sep = separator(), note = note("<small>[0] is bottom layer, [1] is top layer, [2] is mesh. Mesh origin is at bottom-left. Plugin GUI preview does not accurately show mesh.</small>")
#@gui : Process as = choice(0,"Three-by-three","Self-mesh and self-blend for each layer")
#@gui : Resize interpolation = choice(3,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Reverse blending layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Blend alpha channels = bool(0)
#@gui : Keep mesh = bool(0)
_fx_mesh_blend :
r. 256,256,100%,100%,$1
if $4 to_rgba else to_rgb fi
if $2 rv[0,1] fi
f[$3] "i(#2,i(#0),256-i(#1))"
if {!$5} rm[2] fi
if $3 rm[0] else rm[1] fi
fx_mesh_blend :
if {$1==0} repeat {int($!/3)} l[$>-{$>+2}] rv _fx_mesh_blend ${2-6} endl done 
elif {$1==1} repeat $! l[$>] [0]x2 _fx_mesh_blend ${2-6} endl done fi
fx_mesh_blend_preview :
fx_mesh_blend $*


#@gui <b>Artistic</b>

#@gui Whirling lines : fx_whirling_lines, fx_whirling_lines_preview()
#@gui : note = note("Creates fingerprint-like lines out of images by blurring and rounding their values. Works best with single-channel images.")
#@gui : 1. Blur = float(30,0,100)
#@gui : 2. Round = float(6,0,255)
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 3. Norm mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient")
#@gui : 4. Smoothness = float(0,0,10)
#@gui : 5. Contrast = float(0.45,0,1.5)
#@gui : 6. Min threshold = float(40,0,100)
#@gui : 7. Max threshold = float(60,0,100)
#@gui : 8. Dilate or erode = int(0,-5,20)
#@gui : 9. Negative = bool(0)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 10. Amplitude = float(30,0,100)
#@gui : 11. Edge threshold (%) = float(0,0,100)
#@gui : 12. Smoothness = float(3,0,10)
#@gui : 13. Value action = choice(3,"None","Cut","Normalize","Cut then normalize")
fx_whirling_lines :
b $1 f "round(i,$2)"
if {$3==1}
b $4
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1] b $4
s={s} s. c +[-$s--1] sqrt.
elif {$3==2}
b $4 laplacian abs to_gray to_rgb
elif {$3==3}
b $4 gradient xyz abs blend add to_gray to_rgb
else
b $4 gradient_norm
fi
c 0,255
^ $5
c $6%,$7%
n 0,255
if {$8>=0}
dilate_circ $8 
elif {$8<=0}
erode {-$8}
fi
if $9 negate fi
if {$10!=0||$11!=100}
fx_smooth_antialias ${10-12}
fi
if {$13==1} c 0,255 elif {$13==2} n 0,255 elif {$13==3} c 0,255 n 0,255 fi
fx_whirling_lines_preview :
fx_whirling_lines $*

#@gui Dreamy Watercolour : fx_dreamy_watercolour, fx_dreamy_watercolour(0)
#@gui : note = note("Creates abstract watercolour images.")
#@gui : sep = separator(), note = note("<b>Gradient norm</b>")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.3,0,2)
#@gui : 3. Min threshold = float(40,0,100)
#@gui : 4. Max threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 7. Amplitude = float(50,0,200)
#@gui : 8. Edge threshold (%) = float(0,0,100)
#@gui : 9. Smoothness = float(10,0,20)
#@gui : sep = separator(), note = note("<b>Dreamy abstraction</b>")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 10. Edge threshold = float(2,0,30)
#@gui : 11. Smoothness = float(1,0,10)
#@gui : 12. Blend mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 13. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 14. Noise amplitude = float(10,0,100)
#@gui : 15. Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 16. Noise channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 17. Blend mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 18. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 19. Blur strength = float(3,0,20)
#@gui : 20. Sharpen radius factor = float(1,0,5)
#@gui : 21. Amount factor = float(1,0,5)
#@gui : 22. Threshold = float(1,0,5)
#@gui : 23. Constraint radius factor = float(1,0,5)
#@gui : 24. Overshoot factor = float(1,0,20)
#@gui : 25. Sharpen channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 26. Value action = choice(1,"None","Cut","Normalize")
#@gui : 27. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("<b>Plasma</b>")
#@gui : 28. Alpha = float(0.5,0,5)
#@gui : 29. Beta = float(0,0,100)
#@gui : 30. Scale = float(8,1,20)
#@gui : 31. Randomize = bool(1)
#@gui : 32. Transparency = bool(0)
#@gui : 33-35. Color balance = color(128,128,128)
#@gui : 36. Fix edges = float(0.5,0,1)
#@gui : sep = separator(), note = note("<b>Transfer colours</b>")
#@gui : 37. Enable = bool(1)
#@gui : 38. Regularization = int(8,0,32)
#@gui : 39. Preserve luminance = float(0.2,0,1)
#@gui : 40. Precision = _choice(1,"Low","Normal","High","Very high")
#@gui : 41. Reference colors = choice(1,"Plasma","Painting")
#@gui : 42. Add user-defined constraints (interactive) = _bool(0)
#@gui : 43. Blend mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 44. Opacity = float(0.75,0,1)
#@gui : 45. Reverse order = bool(0)
#@gui : sep = separator(), note = note("<b>Local normalisation</b>")
#@gui : 46. Amplitude = float(1,0,80)
#@gui : 47. Radius = int(20,1,96)
#@gui : 48. Neighborhood smoothness = float(40,0,60)
#@gui : 49. Average smoothness = float(40,0,60)
#@gui : 50. Constrain values = bool(1)
#@gui : 51. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<b>Noise</b>")
#@gui : 52. Power = float(1.25,0,5)
#@gui : 53. Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : 54. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 55. Value action = choice(1,"None","Cut","Normalize")
#@gui : 56. Blend mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 57. Opacity = float(1,0,1)
fx_dreamy_watercolour :
repeat $! l[$>]
to_rgb
if $6
+b $1
l[1] gradient_norm c 0,255 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255
if {$9!=0||$10!=100}
fx_smooth_antialias ${7-9}
fi
endl
fi
fx_dreamy_abstraction[0] ${10-27}
n[1] 0,255 negate[1] blend[0,1] multiply,$6
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
100%,100%,1,3 
CF={$30*20*$36}
 l[1] if {$36} z {-$CF},{-$CF},{w+$CF},{h+$CF} fi fx_plasma ${28-35} if {$36} z {$CF},{$CF},{w-$CF},{h-$CF} fi endl
if $37 fx_transfer_rgb ${38-42} fi
if $45 rv fi
blend ${_mode{$43+1}},$44
endl done
fx_normalize_local ${46-51}
if $52
100%,100%,1,3 fc[1] 127,127,127 jr_fx_noise[1] {(2^($52/5))*($52*20)},${53-55}
blend ${_mode{$56+1}},$57
fi
fx_dreamy_watercolour_preview :
fx_dreamy_watercolour $*

#@gui Hard painting : fx_hard_painting, fx_hard_painting_preview(0)+
#@gui : note = note("Modular filter which can be used to apply an extremely-glossy paint effect.")
#@gui : sep = separator(), note = note("<small>Painting authors: <i>Lyle Kroll</i>, <i>Angelo Lama</i> and <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.\nLatest update: <i>2011/28/02</i>.</small>")
#@gui : 1. abstraction = int(1,0,20)
#@gui : 2. details scale = float(2.5,0,100)
#@gui : 3. color = float(4,0,25)
#@gui : 4. smoothness = float(50,0,2000)
#@gui : 5. sharpen shades = bool(1)
#@gui : sep = separator (), note = note("<small>Graphic novel author: <i>PhotoComiX</i>. Latest update : <i>2011/13/11</i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=1582")
#@gui : 6. graphic novel iterations = int(1,0,10)
#@gui : sep = separator ()
#@gui : note = note("Apply Local Normalization")
#@gui : 7. skip this step = bool(false)
#@gui : sep = separator ()
#@gui : note = note("Local Normalization Controls")
#@gui : 8. ln amplititude = float(2,0,60)
#@gui : 9. ln size = float(6,0,64)
#@gui : 10. ln neightborhood-smoothness = float(5,0,40)
#@gui : 11. ln average-smoothness = float(20,0,40)
#@gui : sep = separator()
#@gui : 12. skip all other steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note(" Pencil Options")
#@gui : 13. pencil size = float(0.62,0,4)
#@gui : 14. pencil amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : 15. skip all other steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : 16. activate "pencil smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : sep = separator()
#@gui : 17. pencil smoother sharpness = float(0.5,0,2)
#@gui : 18. pencil smoother edge protection = float(0.78,0,1)
#@gui : 19. pencil smoother smoothness = float(1.92,0,10)
#@gui : sep = separator()
#@gui : 20. skip all other steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator()
#@gui : note = note ("Boost Merging Options")
#@gui : 21. swap layers = bool (false)
#@gui : 22. mixer = choice("Overlay","Multiply","Soft light","Color Burn","Darken","Stamp","Hard Light","Value","Grain Merge","Freeze","Lightness", "Luminance","*Colors Doping","*Comix Colors*" ,"Graphic Colours","*Graphix Colors","*Vivid Edges*","*Dark Edges*","*Dark Screen*","*Vivid Screen*","Interpolate")
#@gui : 23. opacity = float(1,0,1)
#@gui : 24. intensity = float(1,0,1)
#@gui : sep = separator ()
#@gui : 25. add painter's touch = bool(true)
#@gui : sep = separator ()
#@gui : 26. painter's touch sharpness = float(0.5,0,2)
#@gui : 27. painter's edge protection flow = float(0.8,0,1)
#@gui : 28. painter's smoothness = float(1.28,0,10)
#@gui : sep = separator(), 29-31. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_hard_painting : skip ${4=0},${5=0}
repeat $! l[$>]
to_colormode {max(3,s)} split_opacity -rv
repeat $1 fx_normalize_local. 10,6,5,20,1,11 done
fx_smooth_anisotropic. {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
fx_mix_lab. 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
if $5 fx_segment_watershed. 10,1,0 fi
smooth. $4,0,1,1,1
endl done
rv a c
-split_opacity -l[0]
-repeat {max(0,$6)}
-if {$7==0} -fx_normalize_local $8,$9,$10,$11,1,3,0 -endif
-if {$12==0} --fx_pencilbw $13,$14,0,0,0 -endif
-if {$15==1} -keep[-1] -break -endif
-if {$16==1} -fx_smooth_anisotropic[-1] 60,$17,$18,$19,1.1,0.8,30,2,0,1,1,0 -endif
-if {$20==1} -keep[-1] -break -endif
-if {$21==1} -reverse -endif
-if {$22==0} -fx_compose_overlay $23,0
-elif {$22==1} -fx_compose_multiply $23,0
-elif {$22==2} -fx_compose_softlight $23,0
-elif {$22==3} -fx_compose_colorburn $23,0
-elif {$22==4} -fx_compose_darken $23,0
-elif {$22==5} -fx_compose_stamp $23,0
-elif {$22==6} -fx_compose_hardlight $23,0
-elif {$22==7} -fx_compose_value $23,1
-elif {$22==8} -fx_compose_grainmerge $23,0
-elif {$22==9} -fx_compose_freeze $23,0
-elif {$22==10} -fx_compose_lightness $23,1
-elif {$22==11} -fx_compose_luminance $23,1
-elif {$22==12} -fx_compose_colordoping $23,0
-elif {$22==13} -fx_compose_comix_color $23,0,$24
-elif {$22==14} -fx_compose_graphicolor $23,0,$24
-elif {$22==15} -fx_compose_graphixcolor $23,0
-elif {$22==16} -fx_compose_vividedges $23,0.50,0,$24
-elif {$22==17} -fx_compose_darkedges $23,0.50,0,$24
-elif {$22==18} -fx_compose_vividscreen $23,0,$24
-elif {$22==19} -fx_compose_darkscreen $23,0,$24
-elif {$22==20} -fx_compose_interpolation $23,0 -endif
-if {$25==1} -fx_smooth_anisotropic 60,$26,$27,$28,1.1,0.8,30,2,0,1,1,0 -endif
-done
endl
fx_hard_painting_preview :
gui_split_preview "-fx_hard_painting $*",${-3--1}

#@gui Neon : fx_neon, fx_neon_preview(0)
#@gui : note = note("Turns bright image outlines into bright, neon-like lines.")
#@gui : sep = separator(), note = note("Lines")
#@gui : 1. Norm mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient")
#@gui : 2. Smoothness = float(0,0,10)
#@gui : 3. Contrast = float(0.45,0,1.5)
#@gui : 4. Min threshold = float(40,0,100)
#@gui : 5. Max threshold = float(60,0,100)
#@gui : 6. Negative = bool(0)
#@gui : 7. Opacity = float(1,0,1)
#@gui : 8. Saturation = float(1.15,0,4)
#@gui : 9. Blur original = float(2,0,20)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 10. Amplitude = float(3,0,100)
#@gui : 11. Edge threshold (%) = float(0,0,100)
#@gui : 12. Smoothness = float(3,0,5)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 13. Size = float(20,0,100)
#@gui : 14. Intensity = float(0.4,0,3)
#@gui : 15. Darken = float(0.1,0,1)
#@gui : 16. Saturation = float(1.5,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 17. Size = float(5,0,100)
#@gui : 18. Intensity = float(0.2,0,3)
#@gui : 19. Darken = float(0.1,0,1)
#@gui : 20. Saturation = float(1,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 21. Size = float(2,0,5)
#@gui : 22. Intensity = float(1,0,2)
#@gui : sep = separator()
#@gui : 23. Smooth hues = float(0,0,20)
#@gui : sep = separator()
#@gui : 24. Alpha = bool(0)
#@gui : 25. Alpha power = float(1,0,5)
#@gui : 26. Alpha multiplier = float(1,0,5)
#@gui : sep = separator(), 27-29. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_neon :
repeat $! l[$>]
if $9
b $9
fi
+fc 0,0,0 rv blend alpha
to_rgb rgb2hsl s c 
*.. {$8^2.5}
a[0-2] c hsl2rgb
if $7
[0] l[1]
if {$1==1}
b $2
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1] b $2
s={s} s. c +[-$s--1] sqrt.
elif {$1==2}
b $2 laplacian abs to_gray to_rgb
elif {$1==3}
b $2 gradient xyz abs blend add to_gray to_rgb
else
b $2 gradient_norm
fi
c 0,255
^ $3
c $4%,$5%
if $6 negate fi
n 0,255
if {$10!=0||$11!=100}
fx_smooth_antialias ${10-12}
fi
endl
if $9
b.. $9
fi
blend multiply,$7
fi
+b[0] {$13%*100},1 *[1] {$14*sqrt($13%)*10} -[1] {(($14*sqrt($13%)*128)-1)^(sqrt($15))}
+b[0] {$17%*100},1 *[2] {$18*sqrt($17%)*10} -[2] {(($18*sqrt($17%)*128)-1)^(sqrt($19))}
+b[0] $21,1 *[3] {($14+$18)*$21*$22}
rgb2hsl[1-3] s[1-3] c 
*[2] {$16^2.5}
*[5] {$20^2.5}
*[8] 0
a[1-3] c a[2-4] c a[3-5] c hsl2rgb[1-3]
blend add,$7
if $23
rgb2ycbcr s c b[1,2] {$23%*100} a c ycbcr2rgb
fi
if $24
rgb2hsv8 100%,100%,1,1 f[1] "((j(#0,0,0,0,2)/255)^(1/$25))*255*$26" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
fi
endl done
fx_neon_preview :
gui_split_preview "-fx_neon ${1-26}",${-3--1}
#@gui Neon alpha: fx_neon_alpha, fx_neon_alpha_preview(0)
#@gui : note = note("An attempt to make the Neon filter work with alpha channels. Low-quality, comes with some artefacts.")
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.45,0,1.5)
#@gui : 3. Min threshold = float(40,0,100)
#@gui : 4. Max threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Blur original = float(2,0,20)
#@gui : 7. Saturation = float(1.15,0,4)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 8. Size = float(20,0,100)
#@gui : 9. Intensity = float(0.4,0,3)
#@gui : 10. Darken = float(0.1,0,1)
#@gui : 11. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 12. Size = float(5,0,100)
#@gui : 13. Intensity = float(0.2,0,3)
#@gui : 14. Darken = float(0.1,0,1)
#@gui : 15. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 16. Size = float(2,0,5)
#@gui : 17. Intensity = float(1,0,2)
fx_neon_alpha :
repeat $! l[$>]
to_rgba
+split_opacity 
rm[1]
fx_solidify_td[0] 100,0,10,2,0 +invert_rgb[0]
blend[1,2] difference
fx_gradient_norm[1] ${1-4},0
if {$7!=1}
l[0] to_rgb[0] rgb2hsl[0] s[0] c 
*[1] {$7^2.5}
a[0-2] c hsl2rgb[0]
endl fi
if $6
b[0] $6
fi



[0] [1] a[2,3] c b[2] $8,1 *[2] {$9*sqrt($8)} -[2] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
[0] [1] a[3,4] c b[3] $12,1 *[3] {$13*sqrt($12)} -[3] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
split_opacity[2,3]

l[2] to_rgb[0] rgb2hsv[0] s[0] c 
*[1] {$11^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] endl
l[4] to_rgb[0] rgb2hsv[0] s[0] c 
*[1] {$15^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] endl




blend[3,5] average
blend[2,4] add


b[2] {$9*13}

+blend[0,2] add rm[0] mv[3] 0
[1]
a[0,1] c a[1,2] c [1] mv[3] 0
blend[0,1] alpha blend[0,1] add

#a[0,1] c









#+b[1] $16,1 *[2] {($9+$13)*$16*$17}
#+b[1] $8,1 *[3] {$9*sqrt($8)} -[3] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
#+b[1] $12,1 *[4] {$13*sqrt($12)} -[4] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
#+b[0] {$12+$8}
#blend[3,4] add
#+a[0,3] c 
#a[0,1] c rm[2]

#blend[0,1] add













#+b[2] $8,1 *[3] {$9*sqrt($8)} -[3] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
#+b[1] $16,1 *[2] {($9+$13)*$16*$17}
#blend[1,3] add


#rgb2hsl[1] s[1] c *[2] $11 a[1-3] c  hsl2rgb[1] a[1-2] c *[1]

#[1] rv[0,1] blend[0,1] alpha blend[0,1] add
#+a[0,1] c

#+b[1] $12,1 *[3] {$13*sqrt($12)} -[3] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
#+b[0] $16,1 *[2] {($9+$13)*$16*$17}
#blend[0,2] add
#c 0,255
#+a[0,1] c
#blend[0-1] 
#rv[1-4] blend[1-4] add


#a[0,1] c
endl done
fx_neon_alpha_preview :
fx_neon_alpha $*


#@gui Dreamy abstraction : fx_dreamy_abstraction, fx_dreamy_abstraction_preview()
#@gui : note = note("A less-aggressive alternative to the Painting filter. Yes, 'Joan Rake' made a filter that isn't aggressive! What kind of digital paint has she been sniffing?")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 1. Edge threshold = float(2,0,30)
#@gui : 2. Smoothness = float(1,0,10)
#@gui : 3. Blend mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 4. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 5. Noise amplitude = float(10,0,100)
#@gui : 6. Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 7. Noise channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 8. Blend mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 9. Opacity = float(1,0,1)
#@gui : 10. sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 11. Blur strength = float(3,0,20)
#@gui : 12. Sharpen radius factor = float(1,0,5)
#@gui : 13. Amount factor = float(1,0,5)
#@gui : 14. Threshold = float(1,0,5)
#@gui : 15. Constraint radius factor = float(1,0,5)
#@gui : 16. Overshoot factor = float(1,0,20)
#@gui : 17. Sharpen channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 18. Value action = choice(1,"None","Cut","Normalize")
#@gui : 19. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("Glow")
#@gui : 20. Size = float(5,0,50)
#@gui : 21. Intensity = float(1,0,3)
#@gui : 22. Darken = float(0,0,1)
#@gui : 23. Saturation = float(1.5,0,4)
#@gui : sep = separator(), 24-26. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_dreamy_abstraction :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption1=$3
Opacity1=$4
MergingOption2=$8
Opacity2=$9
if {$4>=0}
+fx_segment_watershed $1,$2,1,1 blend ${_mode{$MergingOption1+1}},$Opacity1
fi
if {$5>=0}
+fc 0,0,0 -to_rgb
if {$6==5}
ac. "spread {([$5,$5]/100)*max(w,h)}",$7,1
else
ac. "_jr_fx_noise {255*$5/100},$6",$7,1
fi
blend ${_mode{$MergingOption2+1}},$Opacity2
if {$10>=0}
_fx_gaussian_blur $10,0,0,1
fi
fi
radius={$10*$11*2}
amount={$10*$12*2}
cradius={$10*$14*2}
overshoot={$10*$15/10}
iain_constrained_sharpen $radius,$amount,$13,$cradius,$overshoot,$16,$17
if {$18>=0}
fx_smooth_antialias {$18+(5*$10)},0,{($18+(5*$10))/20}
fi
fx_dreamy_abstraction_preview:
gui_split_preview "-fx_dreamy_abstraction $*",${-3--1}

#@gui Otsu-Hessian Blend: fx_otsu_hessian_blend, fx_otsu_hessian_blend_preview(1)
#@gui : note = note("Expansion of <a href="https://discuss.pixls.us/t/one-liner-challenge/8785/7?u=joan_rake1">a one-line filter by Afre</a>.")
#@gui : Otsu levels = int(4,1,32)
#@gui : Norm 1 = float(0,-5,5)
#@gui : Norm 2 = float(1,-5,5)
#@gui : Merging option = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Opacity = float(1,0,1)
#@gui : Reverse Order = bool(0)
fx_otsu_hessian_blend :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption=$4
Opacity=$5
ReverseOrder={!$6}
+l otsu $1 af_hnorm n $2,$3 endl +* blend ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
fx_otsu_hessian_blend_preview :
repeat {max(0,l)}
fx_otsu_hessian_blend[$>] $*
done

#@gui _<b>Rendering</b>

#@gui Rectexture : fx_rectexture, fx_rectexture(1)
#@gui : note = note("Generates textures from rectangles, difference blending and warping.")
#@gui : Recompute = button()
#@gui : Iterations = int(10,0,500)
#@gui : Colours = choice(3,"Random colours &#40;difference blending&#41;","Random colours &#40;diffblend &#43; sine mapping&#41;","Random colours &#40;diffblend &#43; sinemap &#43; random HSV mixing&#41;","Black and white")
#@gui : Warp Multiplier = float(1,0,5)
#@gui : Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value action = choice("None","Cut","Normalize")

rectexture:
  -split_opacity -l[0]

  -if {$3==0}
    -fill_color[-1] ${-RGB}
  -elif {$3==1}
    -fill_color[-1] ${-RGB}
  -elif {$3==2}
    -fill_color[-1] ${-RGB}
  -else
    rr={255*round(u)}
    -fill_color[-1] $rr,$rr,$rr
  -endif
  -repeat {max(0,$2)}
    +fill_color 0,0,0
    -if {$3==0}
      -rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      -blend[-1,-2] difference
    -elif {$3==1}
      -rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      -blend[-1,-2] difference
    -elif {$3==2}
      -rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      -blend[-1,-2] difference
    -else
      -rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,255,255,255
      -blend[-1,-2] difference
    -fi
  -done
  -if {$5==0}
    f={u(0,3)}
  -elif {$5==1}
    f={u(0,2)+1}
  -else
    f={($5)-2}
  -fi
  -fx_warp_by_intensity {$4*(u(2)-1)},{$4*(u(2)-1)},{w*$4*(u(2)-1)},{h*$3*(u(2)-1)},0,0,{$f},0,0
  -if {$3==1}
       -normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
  -fi
  -if {$3==2}
      -normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
      mults=u(0,2.5)
      multv=u(0,2.5)
      -fx_mix_hsv {(2^u(0,2.5))-1},{u(-180,180)},0,{(2^$mults)-1},{max(0,2-(2^$mults))*u(-1,1)},0,{(2^$multv)-1},{max(0,2-(2^$multv))*u(-1,1)},0,0,2,0
  -fi
  -endl a c

fx_rectexture:
  -repeat {max(0,l)}
    -ac[$>] "-rectexture $*",$-2,$-1
  -done

#@gui Crazy texture: fx_crazy_texture, fx_crazy_texture_preview(1)
#@gui : note = note("Generates black and white textures from deformed edge offsets around Poisson-disk noise.")
#@gui : Recompute = button()
#@gui : sep = separator(), note = note("Poisson-Disk Noise")
#@gui : Radius = float(75,1,1000)
#@gui : Max sampling attempts = int(30,1,200)
#@gui : sep = separator(), note = note("Edge Offsets")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Scale = int(6,0,32)
#@gui : Thickness = int(3,0,16)
#@gui : Negative colors = bool(0)
#@gui : sep = separator(), note = note("Deform 1")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;coarse&#41;</small>")
#@gui : Strength = float(15,0,30)
#@gui : Interpolation = choice("none","bilinear","bicubic")
#@gui : Matrix density &#40;&#37;&#41; = float(1,1,100)
#@gui : Matrix interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : Matrix contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("Deform 2")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;fine&#41;</small>")
#@gui : Strength = float(1.5,0,30)

#@gui : Matrix density &#40;&#37;&#41; = float(1,1,100)
#@gui : Matrix interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : Matrix contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("This can slow things down a lot if both deform strengths are high!")
#@gui : Accurate boundaries = bool(1)
#@gui : Crop strength = float(1,0,1)
fx_crazy_texture :
to_rgb fc 0,0,0
ms1=0 if {$11==1} ms1={0.125*max(w,h)/($2^0.375)} else ms1=$11 fi
ms2=0 if {$16==1} ms2={0.625*max(w,h)/($2^0.25)} else ms2=$16 fi
CF={$9*$14*$20}
if {$19} z {-$CF},{-$CF},{w+$CF},{h+$CF} fi
noise_poissondisk $2,$3
fx_edge_offsets $4,$5,$6,$7,$8
jr_deform $9,$10,$ms1,$12,$13
jr_deform $14,$15,$ms2,$17,$18
if {$19} z {$CF},{$CF},{w-$CF},{h-$CF} fi
fx_crazy_texture_preview :
fx_crazy_texture $*

#@gui CubeHelix: fx_cubehelix, fx_cubehelix_preview(1)
#@gui : Convert to grayscale = bool(1)
#@gui : Min threshold = float(0,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Pre-normalise = bool(0)
#@gui : Start colour = color(0,0,0)
#@gui : End colour = color(255,255,255)
#@gui : Start hue = float(1,0,3)
#@gui : Rotations = float(-1.5,-20,20)
#@gui : Hue intensity = float(1,0,5)
#@gui : Gamma power = float(0,-4,4)
#@gui : sep = separator()
#@gui : Scale hues = float(-0.5,-2,2)
#@gui : note = note("-2 = hyper, -1 = normal, 0 = flattened, 1 = anti, 2 = hyper-anti)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_cubehelix :
repeat $! l[$>]
if $1 to_gray fi to_rgb abs c 0,255 c $2%,$3% if $4 n 0,255 fi *. {1/255}
f "angle=(2*pi*(($11/3)+1+$12*I));fract=(I^(2^($14^2)));amp=($13*fract*(1-fract)/2);
helix=(amp*[-0.14861*cos(angle[0])+1.78277*sin(angle[0]),-0.29227*cos(angle[1])-0.90649*sin(angle[1]),1.97294*cos(angle[2])]);
scale=([${8-10}]-[${5-7}])/255;
([${5-7}]/255)-$15*(fract*scale+helix)+(1+$15)*(fract+(helix*sign(scale)))*scale"
c 0,1
*. 255
endl done
fx_cubehelix_preview :
gui_split_preview "fx_cubehelix $*",${-3--1}

#@gui _<b>Degradations</b>

#@gui Blur [bloom_glare] : fx_blur_bloom_glare, fx_blur_bloom_glare_preview(0)
#@gui : Amplitude = float(1,0,10)
#@gui : Ratio = float(2,0,5)
#@gui : Iterations = int(5,0,100)
#@gui : Operator = choice("Add","Max","Min")
#@gui : Kernel = choice("Quasi-gaussian","Gaussian","Box","Triangle","Quadratic")
#@gui : Normalize scales = bool(0)
#@gui : Anisotropy = bool(0,0,1)
#@gui : Angle = float(0,0,180)
#@gui : Axis = int(1,1,10)
#@gui : Opacity = float(0.5,0,1)
#@gui : note = note("Parameters <i>Angle</i>, <i>Axis</i> and <i>Opacity</i> are only active when <i>Anisotropy</i> is checked")
#@gui : sep = separator()
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator() 
#@gui : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
#@gui : sep = separator(), note = note("<small>Author: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest update: <i>2015/03/02</i>.</small>")
fx_blur_bloom_glare :
op=${"arg 1+$4,+,max,min"}
if {!$7} 
	ac "blur_bloom ${1-3},"$op",${5-6},xy",$11
else
	wh={[w,h]}
	repeat $9
		ang={(180/$9)*($>)+$8}
		+rotate[0] $ang,2,1
		ac. "blur_bloom ${1-3},"$op",${5-6},x",$11
		rotate. {-$ang},2,1
		r. $wh,1,100%,0,0,0.5,0.5 
		c. 0,255
	done
	repeat {$9}								
		blend[0,-1] screen,$10
	done
fi
fx_blur_bloom_glare_preview :
gui_split_preview "fx_blur_bloom_glare $*",$-1

#@gui Bomb blend : fx_blend_bomb, fx_blend_bomb_preview()
#@gui : note = note("Creates a random transfer function 'mesh' and then blends images accordingly. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : Recompute = button(0)
#@gui : Process as = choice(1,"Two-by-two","Self-blend for each layer")
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh smoothness = float(2,0,10)
#@gui : Contrast scheme = choice("Arctan","Clip","Power")
#@gui : Mesh contrast = float(50,0,100)
#@gui : Reverse blending layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Alpha = bool(0)
#@gui : Normalise = bool(0)
#@gui : Output mesh = bool(0)
_fx_blend_bomb :
to_rgba
$1,$2,1,4 noise. 255
if $8 ac. "noise 255",rgba_a fi
r. 256,256 n. 0,255 blur. {$3^2}%
l. if {$4==0}
f "val = i/255; (val-0.5+(atan((val-0.5)*($5/10)^3)/pi)+0.5)*255" n 0,255
elif {$4==1}
c {($5-1/255)/2}%,{100-($5-1/255)/2}% n 0,255
elif {$4==2}
f "val = (2*i/255)-1; (val*(abs(val)^(0-($5/100)))+1)*255/2"
fi endl
rv
fx_mesh_blend 0,1,$6,$7,$8,$10
if $9 ac "n 0,255",rgba fi
fx_blend_bomb :
if {$2==0} repeat {int($!/2)} l[$>,{$>+1}] _fx_blend_bomb ${3-12} endl done
elif {$2==1} repeat $! l[$>] [0] _fx_blend_bomb ${3-12} endl done fi
fx_blend_bomb_preview :
fx_blend_bomb $*

#@gui JIFF [JPEG] self-bomb : fx_jiff_bomb, fx_jiff_bomb_preview()
#@gui : note = note("OI! TRY SMOOTHING THIS!")
#@gui : note = note("<small>Adds JPEG artefacts and then self-bomb-blends. Use grid interpolation with scale factors above 1 to destroy the results even more.</small>")
#@gui : Recompute = button(0)
#@gui : sep = separator()
#@gui : Quality (%) = int(50,1,100)
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh smoothness = float(0.5,0,10)
#@gui : Contrast scheme = choice(1,"Arctan","Clip","Power)
#@gui : Mesh contrast = float(75,0,100)
#@gui : Scale X = float(1,0.05,16)
#@gui : Scale Y = float(1,0.05,16)
#@gui : Interpolation = choice(0,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Normalise = bool(0)
#@gui : Output mesh = bool(0)
#@gui : sep = separator()
#@gui : Solidify alpha = bool(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-oriented","Edge-oriented")
#@gui : Regularization iterations = int(20,0,100)
#@gui : Dilation / erosion = int(0,-20,20)
#@gui : Colorspace = choice(1,"sRGB","Linear RGB")
fx_jiff_bomb :
repeat $! l[$>]
if $13
+fx_solidify_td ${14-18}
negate. rv blend alpha
fi
ww={w}
hh={h}
r {$8*100}%,{$9*100}%,100%,100%,$10
fx_jpeg_artefacts $2
fx_blend_bomb 0,1,${3-7},0,0,0,${11-12}
r $ww,$hh,100%,100%,$10
endl done
fx_jiff_bomb_preview :
fx_jiff_bomb $*

#@gui Noise [additive] : fx_noise, fx_noise_preview(0)
#@gui : Amplitude = float(10,0,200)
#@gui : Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
jr_fx_noise :
ac "_fx_noise $1,$2",$3,$4
_jr_fx_noise :
repeat $! l[$>] split_opacity l[0] noise $1,$2 endl a c endl done
jr_fx_noise_preview :
gui_split_preview "jr_fx_noise $*",${-3--1}

#@gui Quick Desaturate: jr_desaturate, jr_desaturate_preview(1)
#@gui : note = note("Generates greyscale images, allowing for different &#40;s&#47;&#41;RGB channel intensities before merging. A smaller counterpart to the 'Black &#38; White' filter intended for generating intensity maps.")
#@gui : Colour space = choice("RGB","sRGB")
#@gui : Channel 1 = float(1,0,3)
#@gui : Channel 2 = float(1,0,3)
#@gui : Channel 3 = float(1,0,3)
#@gui : Normalise = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
jr_desaturate :
repeat $! l[$>] split_opacity l[0] to_rgb if $1 srgb2rgb fi
f "avg(i0*$2,i1*$3,i2*$4)" if $5 n 0,255 fi c 0,255
endl a c endl done
jr_desaturate_preview :
gui_split_preview "jr_desaturate $*",${-3--1}


#@cli rgb2ycbcrglic : convert from rgb to ycbcrglic
#see https://github.com/GlitchCodec/GLIC/blob/master/colorspaces.pde
rgb2ycbcrglic :
split_opacity l[0] to_rgb 
f "R=i0;G=i1;B=i2;
  [0.2988390*R+0.5868110*G+0.1143500*B,-0.168736*R-0.3312640*G+0.5000000*B+127.5,0.5000000*R-0.4186880*G-0.0813120*B+127.5]"
endl a c
#@cli ycbcrglic2rgb : convert from ycbcrglic to rgb
ycbcrglic2rgb :
split_opacity l[0] to_rgb
 f "Y=i0;Cb=i1-127.5;Cr=i2-127.5;
# original GLIC implementation added 1 to each channel to correct the transformation
  [Y+1.402*Cr,Y-0.344136*Cb-0.714136*Cr,Y+1.772000*Cb]"
endl a c

#@gui Colour Space Swap: csswap, csswap_preview()
#@gui : To RGB from = choice("RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : Multiply = float(1,-10,10)
#@gui : Add = float(0,-360,360)
#@gui : From RGB to = choice("RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
csswap:
repeat $! l[$>] split_opacity l[0] to_rgb
cs=$1
sc=$4
if {$cs==1} srgb2rgb
elif {$cs==2} cmyk2rgb
elif {$cs==3} cmy2rgb
elif {$cs==4} hsv82rgb
elif {$cs==5} hsv2rgb
elif {$cs==6} hsl82rgb
elif {$cs==7} hsl2rgb
elif {$cs==8} hsi82rgb
elif {$cs==9} hsi2rgb
elif {$cs==10} lch82rgb
elif {$cs==11} lch2rgb
elif {$cs==12} lab82rgb
elif {$cs==13} ycbcr2rgb
elif {$cs==14} ycbcrglic2rgb
elif {$cs==15} yiq82rgb
elif {$cs==16} yiq2rgb
elif {$cs==17} yuv82rgb
elif {$cs==18} yuv2rgb
elif {$cs==19} bayer2rgb 0,0,0
elif {$cs==20} hcy2rgb
elif {$cs==21} xyz82rgb
elif {$cs==22} xyz2rgb
fi
f "(i*$2)+$3"
if {$sc==1} rgb2srgb
elif {$sc==2} rgb2cmyk
elif {$sc==3} rgb2cmy
elif {$sc==4} rgb2hsv8
elif {$sc==5} rgb2hsv
elif {$sc==6} rgb2hsl8
elif {$sc==7} rgb2hsl
elif {$sc==8} rgb2hsi8
elif {$sc==9} rgb2hsi
elif {$sc==10} rgb2lch8
elif {$sc==11} rgb2lch
elif {$sc==12} rgb2lab8
elif {$sc==13} rgb2ycbcr
elif {$sc==14} rgb2ycbcrglic
elif {$sc==15} rgb2yiq8
elif {$sc==16} rgb2yiq
elif {$sc==17} rgb2yuv8
elif {$sc==18} rgb2yuv
elif {$sc==19} rgb2bayer 0
elif {$sc==20} rgb2hcy
elif {$sc==21} rgb2xyz8
elif {$sc==22} rgb2xyz
fi
to_rgb endl a c endl done
csswap_preview :
gui_split_preview "csswap $*",${-3--1}


#@gui Cascading self glitching: fx_self_glitching_cascade, fx_self_glitching_cascade_preview(1)
#@gui : note = note("Shifts images in a cascading fashion but computes values based on shifted and original images.")
#@gui : note = note("<small>This filter has many channel options and many operation options allowing for extremely-distorted images. Don't always trust the preview!</small>"), sep = separator()
#@gui : 1. Shift channels = choice("RGB&#47;sRGB","CMYK&#47;CMY","HSV&#47;HSV8","HSL&#47;HSL8","HSI&#47;HSI8","LCH&#47;LCH8","Lab&#47;Lab8","YCbCr&#47;YCbCrGLIC","YIQ&#47;YIQ8","YUV&#47;YUV8","Bayer&#47;HCY","XYZ&#47;XYZ8")
#@gui : 2. Alt choice = bool(0)
#@gui : 3. Process Alpha = bool(0)
#@gui : 4,5. Zeroth shift = point(50,50,0,1,255,255,255,175)
#@gui : 6. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : sep = separator()
#@gui : 7. Iterations = int(3,1,64)
#@gui : 8. Repeat post-shift operations = bool(1)
#@gui : sep = separator()
#@gui : 9,10. Shift target = point(55,55,0,1,255,0,0,175)
#@gui : 11. Target for final &#40;rather than first&#41; shift = bool(0)
#@gui : 12,13. Cascade centre point = point(45,45,0,1,0,255,0,175)
#@gui : 14. Shift randomness = float(0.75,0,4)
#@gui : 15. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : 16. Power = float(0,-5,5)
#@gui : 17. Bias = float(0,-256,256)
#@gui : 18. Negation = bool(0)
#@gui : 19. Shift Operator = choice("Add","Multiply","Bitwise And","Bitwise Or","Bitwise Xor","Power","Reverse Power",
#@gui : "Modulo","Reverse Modulo","Divide","Reverse Divide","Subtract","Reverse Subtract",
#@gui : "Left Bitwise Shift","Reverse LBS","Right Bitwise Shift","Reverse RBS","Left Bitwise Rotation","Reverse LBR","Right Bitwise Rotation","Reverse RBR",
#@gui : "Average","Round","Reverse Round","Sine","Reverse Sine","Cosine","Reverse Cosine","Tangent","Reverse Tangent &#40;CPU-intensive&#41;",
#@gui : "Cosecant","Reverse Cosecant","Secant","Reverse Secant","Cotangent","Reverse Cotangent","Variance","Difference","Minimum","Maximum",
#@gui : "Interference &#40;Add&#41;","Reverse Interference &#40;Add&#41;","Interference &#40;Multiply&#41;",
#@gui : "Interference &#40;Divide&#41;","Reverse Interference &#40;Div&#41;",
#@gui : "Interference &#40;Subtract&#41;","Reverse Interference &#40;Subt&#41;","Interference &#40;Rev Subt&#41;","Reverse Interference &#40;Rev Subt&#41;",
#@gui : "Interference &#40;Difference&#41;","Reverse Interference &#40;Diff&#41;","Interference &#40;Variance&#41;",
#@gui : "Screen","Colour Dodge","Reverse Colour Dodge","Colour Burn","Reverse Colour Burn","Soft Light &#40;illusions&#46;hu&#41;","Reverse Soft Light &#40;illusions&#46;hu&#41;",
#@gui : "Geometric Mean","Bright Hard Mix","Dark Hard Mix")
#@gui : 20. Multiplier 1 = float(1,-10,10)
#@gui : 21. Addition 1 = int(0,-1024,1024)
#@gui : 22. Post-Shift Modulo = int(256,0,1024)
#@gui : 23. Multiplier 2 = float(1,-10,10)
#@gui : 24. Addition 2 = int(0,-1024,1024)
#@gui : sep = separator(), 25. Run on channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
# #@gui : sep = separator(), 26. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Original author: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>&#59; extended by some nobody who calls themselves 'Joan Rake' or something.<p>Latest update: <i>2018/08/24</i>.</small>")
fx_self_glitching_cascade :
skip "${25=-skip ,}","${26=-skip ,}"
shift {$4-50}%,{$5-50}%,0,0,$6,0
repeat $! l[$>] if {!$3} split_opacity fi l[0] to_rgb
if {$2}
if {$1==0} rgb2srgb
elif {$1==1} rgb2cmy
elif {$1==2} rgb2hsv8
elif {$1==3} rgb2hsl8
elif {$1==4} rgb2hsi8
elif {$1==5} rgb2lch8
elif {$1==6} rgb2lab8
elif {$1==7} rgb2ycbcrglic
elif {$1==8} rgb2yiq8
elif {$1==9} rgb2yuv8
elif {$1==10} rgb2hcy
elif {$1==11} rgb2xyz8
fi else
if {$1==1} rgb2cmyk
elif {$1==2} rgb2hsv
elif {$1==3} rgb2hsl
elif {$1==4} rgb2hsi
elif {$1==5} rgb2lch
elif {$1==6} rgb2lab
elif {$1==7} rgb2ycbcr
elif {$1==8} rgb2yiq
elif {$1==9} rgb2yuv
elif {$1==10} rgb2bayer 0
elif {$1==11} rgb2xyz
fi fi
if $11 stype=$7 else stype=1 fi
repeat $7
+shift[0] {((([w,h]-1)*([$12,$13]-[$9,$10]+[u(-1,1),u(-1,1)]*sqrt((($12-$9)^2)+(($13-$10)^2))*($14^3)))/$stype)/100},0,0,$15
f.. "begin(
const sign = $18?-1:1;
);
operate(mode,s1,s2,mult,power) = 
(mode==0?(s1 + s2):
mode==1?(s1 * s2):
mode==2?(s1 & s2):
mode==3?(s1 | s2):
mode==4?xor(s1,s2):
mode==5?(s1^(s2*0.01)):
mode==6?(s2^(s1*0.01)):
mode==7?(s1%s2):
mode==8?(s2%s1):
mode==9?(s1 / s2):
mode==10?(s2 / s1):
mode==11?(s2 - s1):
mode==12?(s1 - s2):
mode==13?(s1 << s2):
mode==14?(s2 << s1):
mode==15?(s1 >> s2):
mode==16?(s2 >> s1):
mode==17?for(n=0,n<(s2%32),n++,rol(s1)):
mode==18?for(n=0,n<(s1%32),n++,rol(s2)):
mode==19?for(n=0,n<(s2%32),n++,ror(s1)):
mode==20?for(n=0,n<(s1%32),n++,ror(s2)):
mode==21?avg(s2,s1):
mode==22?round(s1,s2,0):
mode==23?round(s2,s1,0):
mode==24?s2*sin(s1*2*pi/mult):
mode==25?s1*sin(s2*2*pi/mult):
mode==26?sign*s2*cos(s1*2*pi/mult):
mode==27?sign*s1*cos(s2*2*pi/mult):
mode==28?s2*tan(s1*pi/mult):
mode==29?s1*tan(s2*pi/mult):
mode==30?s2*sin(mult/(s1*2*pi)):
mode==31?s1*sin(mult/(s2*2*pi)):
mode==32?sign*s2*cos(mult/(s1*2*pi)):
mode==33?sign*s1*cos(mult/(s2*2*pi)):
mode==34?s2*tan(mult/(s1*pi)):
mode==35?s1*tan(mult/(s2*pi)):
mode==36?mult*var(s1,s2):
mode==37?abs(s2 - s1):
mode==38?min(s2,s1):
mode==39?max(s2,s1):
mode==40?0.005*s2*(((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power))+s1):
mode==41?0.005*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)+s2):
mode==42?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)*s1:
mode==43?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s1:
mode==44?0.1*s1*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s2:
mode==45?0.001*s2*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==46?0.001*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==47?0.001*s2*(s1-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==48?0.001*s1*(s2-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==49?0.001*s2*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==50?0.001*s1*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==51?0.00001*mult*var(s1,s2,(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==52?(255-((255-s1)*(255-s2))):
mode==53?(s1/(255-s2)):
mode==54?(s2/(255-s1)):
mode==55?((255-s2)/s1*255):
mode==56?((255-s1)/s2*255):
mode==57?((((s1)/255)^2)^(2*(0.5-(s2/255))))*255:
mode==58?((((s2)/255)^2)^(2*(0.5-(s1/255))))*255:
mode==59?sqrt(abs(s1*s2)):
mode==60?(if((s1+s2)>=255,255,0)):
(if((s1+s2)<=255,0,255)));
val = sign*((2^$16)*j(#-1) + $17);operate($19,val,i,$20,$16);
" rm.
if {$8}
*. $20 +. $21 if $22 %. $22 fi *. $23 +. $24
fi
done
if {!$8}
*. $20 +. $21 if $22 %. $22 fi *. $23 +. $24
fi
if {$2}
if {$1==0} srgb2rgb
elif {$1==1} cmy2rgb
elif {$1==2} hsv82rgb
elif {$1==3} hsl82rgb
elif {$1==4} hsi82rgb
elif {$1==5} lch82rgb
elif {$1==6} lab82rgb
elif {$1==7} ycbcrglic2rgb
elif {$1==8} yiq82rgb
elif {$1==9} yuv82rgb
elif {$1==10} hcy2rgb
elif {$1==11} xyz82rgb
fi else
if {$1==1} cmyk2rgb
elif {$1==2} hsv2rgb
elif {$1==3} hsl2rgb
elif {$1==4} hsi2rgb
elif {$1==5} lch2rgb
elif {$1==6} lab2rgb
elif {$1==7} ycbcr2rgb
elif {$1==8} yiq2rgb
elif {$1==9} yuv2rgb
elif {$1==10} bayer2rgb 0,0,0
elif {$1==11} xyz2rgb
fi fi
  endl a c endl done 
fx_self_glitching_cascade_preview :
#fx_self_glitching_cascade $*
repeat {max(0,l)}
ac[$>] "-fx_self_glitching_cascade $*",$25
done

#@gui Sawtoother [CMY(/K)] : sawtoother_cmy_k, sawtoother_cmy_k_preview(1)+
#@gui : note = note("Splits image into CMY or CMYK channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Cyan</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Magenta</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Yellow</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Key</b>")
#@gui : Include channel = bool(0)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_cmy_k :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $26,$27
if $19 rgb2cmyk. else rgb2cmy. fi s. c
index=0
if {$19} index=-1 if {$23} b[-1] $22% +[-1] $25 %[-1] {256/$20} *[-1] $20 %[-1] 256 *[-1] $24 +[-1] $21 else *[-1] $20 +[-1] {$21*$20} b[-1] $22% fi fi
if {$4} b[{$index-3}] $3% +[{$index-3}] $6 %[{$index-3}] {256/$1} *[{$index-3}] $1 %[{$index-3}] 256 *[{$index-3}] $5 +[{$index-3}] $2 else *[{$index-3}] $1 +[{$index-3}] {$2*$1} b[{$index-3}] $3% fi
if {$10} b[{$index-2}] $9% +[{$index-2}] $12 %[{$index-2}] {256/$7} *[{$index-2}] $7 %[{$index-2}] 256 *[{$index-2}] $11 +[{$index-2}] $8 else *[{$index-2}] $7 +[{$index-2}] {$8*$7} b[{$index-2}] $9% fi
if {$16} b[{$index-1}] $15% +[{$index-1}] $18 %[{$index-1}] {256/$13} *[{$index-1}] $13 %[{$index-1}] 256 *[{$index-1}] $17 +[{$index-1}] $14 else *[{$index-1}] $13 +[{$index-1}] {$14*$13} b[{$index-1}] $15% fi
c 0,255 a[{$index-3}--1] c
if $19 cmyk2rgb. else cmy2rgb. fi
fx_end_mix $26
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_cmy_k_preview :
sawtoother_cmy_k $*
#gui_split_preview "sawtoother_cmy_k $*",$-1

#@gui Sawtoother [HSX] : sawtoother_hsx, sawtoother_hsx_preview(1)+
#@gui : note = note("Splits image into HSV, HSI or HSL channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-180,180)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-180,180)
#@gui : sep = separator(), note = note("<b>Saturation</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-1,1)
#@gui : sep = separator(), note = note("<b>Value&#47;Intensity&#47;Lightness</b>")
#@gui : Channel = choice("Value","Intensity","Lightness)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-1,1)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_hsx :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $20,$21
if {$13==1} rgb2hsi. elif {$13==2} rgb2hsl. else rgb2hsv. fi
s. c
if {$4} +[-3] $6 %[-3] {360/($1)^2} *[-3] $1 %[-3] 360 *[-3] {$5*$1} +[-3] {$2} else *[-3] $1 +[-3] {$2*$1} fi %[-3] 360
if {$10} b[-2] $9% +[-2] $12 %[-2] {(1+(1/255))/$7} *[-2] {$7} %[-2] {(1+(1/255))} *[-2] $11 +[-2] {$8} else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$17} b[-1] $16% +[-1] $19 %[-1] {(1+(1/255))/$14} *[-1] {$14} %[-1] {(1+(1/255))} *[-1] $18 +[-1] {$15} else *[-1] $14 +[-1] {$15*$14} b[-1] $16% fi
c[-2,-1] 0,1 a[-3--1] c
if {$13==1} hsi2rgb. elif {$13==2} hsl2rgb. else hsv2rgb. fi
if $3 l[-1] +b $3% rgb2hsv[0,1] f.. "[i0(#1),i1,i2]" rm. hsv2rgb endl fi
fx_end_mix $20
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_hsx_preview :
gui_split_preview "sawtoother_hsx $*",$-1

#@gui Sawtoother [LCH8] : sawtoother_lch8, sawtoother_lch8_preview(1)+
#@gui : note = note("Splits image into LCH8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chroma</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_lch8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lch8.
s. c
if {$4} +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/($13)^2} *[-1] $13 %[-1] 256 *[-1] {$17*$13} +[-1] {$14} else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi %[-1] 256
a[-3--1] c c. 0,255 lch82rgb.
if $3 l[-1] +b $3% rgb2lch8[0,1] f.. "[i0,i1,i2(#1)]" rm. lch82rgb endl fi
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_lch8_preview :
sawtoother_lch8 $*
#gui_split_preview "sawtoother_lch8 $*",$-1

#@gui Sawtoother [YIQ8] : sawtoother_yiq8, sawtoother_yiq8_preview(1)+
#@gui : note = note("Splits image into YIQ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_yiq8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yiq8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yiq82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_yiq8_preview :
gui_split_preview "sawtoother_yiq8 $*",$-1

#@gui Sawtoother [XYZ8] : sawtoother_xyz8, sawtoother_xyz8_preview(1)+
#@gui : note = note("Splits image into XYZ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>X</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Y</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Z</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_xyz8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2xyz8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 xyz82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_xyz8_preview :
gui_split_preview "sawtoother_xyz8 $*",$-1

#@gui Sawtoother [YUV8] : sawtoother_yuv8, sawtoother_yuv8_preview(1)+
#@gui : note = note("Splits image into YUV8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_yuv8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yuv8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yuv82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_yuv8_preview :
gui_split_preview "sawtoother_yuv8 $*",$-1

#@gui Sawtoother [YCbCr] : sawtoother_ycbcr, sawtoother_ycbcr_preview(1)+
#@gui : note = note("Splits image into YCbCr channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Red Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_ycbcr :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2ycbcr. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 ycbcr2rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_ycbcr_preview :
gui_split_preview "sawtoother_ycbcr $*",$-1

#@gui Sawtoother [YCbCrGLIC] : sawtoother_ycbcrglic, sawtoother_ycbcrglic_preview(1)+
#@gui : note = note("Splits image into YCbCr channels &#40;<a href="https://web.archive.org/web/20180906062556/https://github.com/GlitchCodec/GLIC/blob/master/colorspaces.pde">using GLIC version</a>&#41; and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Red Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_ycbcrglic :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2ycbcr. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yuv82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_ycbcrglic_preview :
gui_split_preview "sawtoother_ycbcrglic $*",$-1

#@gui Sawtoother [RGB] : sawtoother_rgb, sawtoother_rgb_preview(1)+
#@gui : note = note("Splits image into RGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_rgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c. 0,255
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_rgb_preview :
gui_split_preview "sawtoother_rgb $*",$-1

#@gui Sawtoother [sRGB] : sawtoother_srgb, sawtoother_srgb_preview(1)+
#@gui : note = note("Splits image into sRGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_srgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2srgb. s. c 
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 srgb2rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_srgb_preview :
sawtoother_srgb $*
#gui_split_preview "sawtoother_srgb $*",$-1

#@gui Sawtoother [Lab8] : sawtoother_lab8, sawtoother_lab8_preview(1)+
#@gui : note = note("Splits image into Lab8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance a</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance b</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_lab8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lab8. s. c
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c lab82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_lab8_preview :
sawtoother_lab8 $*
#gui_split_preview "sawtoother_lab8 $*",$-1

#@gui _<b>Deformations</b>

#@cli jr_deform : _amplitude>=0,_interpolation,_matrix_density[%]>=0,_matrix_interpolation,_mode,-100<=_character<=100
#@cli : Apply random smooth deformation on selected images. An upgrade to the existing deform command.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'matrix_interpolation' can be { 0=linear | 1=bicubic }.
#@cli : 'mode' can be { 0=noise | 1=spread_noise }.
#@cli : 'boundary' can be  { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
jr_deform : skip ${1=10},${2=1},${3=2%},${4=1},${5=0},${6=0}
e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
v - repeat $! l[$>]
S={${"is_percent $3"}?max(w,h)*$3:$3}
P={$4==0?3:5}
if {$5==1} +r. $3,$3,1,4 spread. {max(w,h)*($6+100)/200},{max(w,h)*($6+100)/200} else
$3,$3,1,4 noise. $1
fi
ac. "adjust_colors 0,$6,0,0,0",rgba r. ..,..,1,4,$P warp.. .,1,$2,$7 rm.
endl done v +

#@gui Layer cake : fx_layer_cake, fx_layer_cake_preview(1)
#@gui : note = note("Splits image into annular or circular layers and rotates each layer. Based on <a href="https://forums.getpaint.net/topic/26566-layer-cake-plugin/">the Paint.NET plugin</a>.")
#@gui : Iterations = int(4,1,32)
#@gui : Angle at centre = float(360,-1440,1440)
#@gui : Angle times iteration = bool(0)
#@gui : Size = float(75,0,200)
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Boundary = choice(3,"None","Nearest","Periodic","Mirror")
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Blur = float(0,0,200)
#@gui : sep = separator()
#@gui : Anti-alias amplitude = float(30,0,100)
#@gui : Edge threshold (%) = float(0,0,100)
#@gui : Smoothness = float(3,0,10)
#@gui : Output layers = choice("Off","Hollow","Filled")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_layer_cake :
repeat $! l[$>]
iter=$1
angle=$2
if $3 angle*=$iter fi
size=$4/2
to_rgba split_opacity to_rgb
repeat 2
part={1-$>}
l[$part]
repeat $iter
[0] rotate[-1] {$angle/$iter*($>+1)},$8,$7,$5%,$6%
100%,100%,1,1 ellipse. $5%,$6%,{$size/$iter*($iter-$>)}%,{$size/$iter*($iter-$>)}%,0,1,255
if {$13!=2} ellipse. $5%,$6%,{$size/$iter*($iter-1-$>)}%,{$size/$iter*($iter-1-$>)}%,0,1,1 fi
blur. {$9/$iter}
fx_smooth_antialias. ${10-12}
blend[-1,-2] multiply
done
if {!$13} blend[^0] add fi
if {$13!=2} 100%,100%,1,1 fc. 255,255,255 ellipse. $5%,$6%,{$size}%,{$size}%,0,1,0
blur. {$9/$iter}
fx_smooth_antialias. ${9-11}
blend[-1,0] multiply fi
if {!$13} blend add fi
if $part to_gray fi
endl
done
list={int($!/2)}
repeat {$list} a[$>,$list] c done
endl
done
fx_layer_cake_preview:
if {!$13} gui_split_preview "fx_layer_cake $*",${-3--1} else fx_layer_cake $* fi

#@cli jr_deform : _amplitude>=0,_interpolation,_matrix_density[%]>=0,_matrix_interpolation,_mode,-100<=_character<=100
#@cli : Apply random smooth deformation on selected images. An upgrade to the existing deform command.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'matrix_interpolation' can be { 0=linear | 1=bicubic }.
#@cli : 'mode' can be { 0=noise | 1=spread_noise }.
#@cli : 'boundary' can be  { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
jr_deform : skip ${1=10},${2=1},${3=2%},${4=1},${5=0},${6=0}
e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
v - repeat $! l[$>]
S={${"is_percent $3"}?max(w,h)*$3:$3}
P={$4==0?3:5}
if {$5==1} +r. $3,$3,1,4 spread. {max(w,h)*($6+100)/200},{max(w,h)*($6+100)/200} else
$3,$3,1,4 noise. $1
fi
ac. "adjust_colors 0,$6,0,0,0",rgba r. ..,..,1,4,$P warp.. .,1,$2,$7 rm.
endl done v +

#@gui Random deformations (JR's mod) : fx_jr_deform, fx_jr_deform_preview(1)
#@gui : Recompute = button(0)
#@gui : Amplitude = float(5,0,50)
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Matrix density = float(10,1,100)
#@gui : Matrix interpolation = choice(1,"Linear","Bicubic")
#@gui : Mode = choice("Noise","Spread noise")
#@gui : Character = float(0,-100,100)
#@gui : Boundary = choice(1,"Dirichlet","Neumann","Periodic","Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
fx_jr_deform :
repeat $! l[$>]
jr_deform ${2-8}
endl done
fx_jr_deform_preview :
gui_split_preview "fx_jr_deform $*",${-3--1}

#@gui Custom box : fx_custom_box, fx_custom_box_preview()
#@gui : Float 1 = float(0,-2,2)
#@gui : Box 2 = text(1,"\n")
fx_custom_box :
skip ${2="-skip skip"}
m "_fx_custom_box_start : $2"
_fx_custom_box_start
uncommand _fx_custom_box_start
fx_custom_box_preview:
skip ${2="-skip skip"}

_gcp_arg="$2"

fx_custom_box $_gcp_arg

#@gui UltraWarp 2 : fx_ultrawarptwo, fx_ultrawarptwo_preview(1)
#@gui : 1. Recompute = button(0)
#@gui : sep = separator(), note = note("<b>Warping</b>")
#@gui : 2. Iterations = int(3,1,30)
#@gui : 3. From RGB to = choice(1,"Random","RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : 4. X-factor centre = float(0,-30,30)
#@gui : 5. X-factor range = float(3,0,30)
#@gui : 6. Y-factor centre = float(0,-30,30)
#@gui : 7. Y-factor range = float(3,0,30)
#@gui : 8. X-offset centre = float(0,-30,30)
#@gui : 9. X-offset range = float(3,0,30)
#@gui : 10. Y-offset centre = float(0,-30,30)
#@gui : 11. Y-offset range = float(3,0,30)
#@gui : 12. Correlated channels = choice(2,"On","Off","Random")
#@gui : 13. Interpolation = choice(2,"Nearest","Linear","Random")
#@gui : 14. Boundary = choice(5,"Transparent","Nearest","Periodic","Mirror","Random","Random &#40;non-transparent&#41;")
#@gui : 15. Warp Channel(s) = choice(3,"None","Random","All","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 16. Include alpha = bool(0)
#@gui : 17. To RGB from = choice(1,"Random","RGB","sRGB","CMYK","CMY","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YIQ8","YIQ","YUV8","YUV","Bayer","HCY","XYZ8","XYZ")
#@gui : 18. Random negation = bool(1)
#@gui : sep = separator(), note = note("<b>Post-warping HSX8 mixing</b>")
#@gui : 19. Repeat for each iteration = bool(1)
#@gui : 20. X channel = choice("Value","Intensity","Lightness")
#@gui : 21. Hue factor centre = float(1,-20,20)
#@gui : 22. Hue factor range = float(0.5,0,20)
#@gui : 23. Saturation factor centre = float(2.5,-20,20)
#@gui : 24. Saturation factor range = float(5,0,20)
#@gui : 25. X channel factor centre = float(1,-20,20)
#@gui : 26. X channel factor range = float(0,0,20)
#@gui : 27. Alpha factor centre = float(1,-20,20)
#@gui : 28. Alpha factor range = float(0,0,20)
#@gui : 29. Hue shift centre = float(0,-255,255)
#@gui : 30. Hue shift range = float(255,0,255)
#@gui : 31. Saturation shift centre = float(0,-255,255)
#@gui : 32. Saturation shift range = float(255,0,255)
#@gui : 33. X channel shift centre = float(0,-255,255)
#@gui : 34. X channel shift range = float(0,0,255)
#@gui : 35. Alpha shift centre = float(0,-255,255)
#@gui : 36. Alpha shift range = float(0,0,255)
#@gui : sep = separator(), note = note("<b>Custom code</b>")
fx_ultrawarptwo :

repeat $! l[$>] to_rgba split_opacity



iter=$2
sc=$3
xfc=$4
xfr=$5
yfc=$6
yfr=$7
xoffc=$8
xoffr=$9
yoffc=$10
yoffr=$11
corr=$12
inter=$13
bound=$14
chann=$15
alpha=$16
cs=$17
rn=$18

rpo=$19
vil=$20
hfc=$21
hfr=$22
sfc=$23
sfr=$24
vilfc=$25
vilfr=$26
afc=$27
afr=$28
hoffc=$29
hoffr=$30
soffc=$31
soffr=$32
viloffc=$33
viloffr=$34
aoffc=$35
aoffr=$36

repeat $iter
if $alpha

opacity=2
else
opacity=1
fi
repeat $opacity
if {$sc==0}
frgbt={floor(u(0,23))}
else
frgbt={$sc-1}
fi
if {$cs==0}
trgbf={floor(u(0,23))}
else
trgbf={$cs-1}
fi
if {$>==0}
csswap[$>] 0,1,0,$frgbt
fi
if {$>==1||$chann!=0}
if {$chann==1}
channel={floor(u(2,37))}
else
channel=$chann
fi
if {$channel==0}
channels=0
elif {$channel>=2}
channels={$channel-1}
elif {$channel>=6}
channels=$channel
else
channels={$channel-2}
fi
if {$corr==2}
correl=round(u)
else
correl=$corr
fi
if {$inter==2}
interp=round(u)
else
interp=$inter
fi
if {$bound==4}
bounds={floor(u(4))}
elif {$bound==5}
bounds={floor(u(3))+1}
else
bounds=$bound
fi
xf={($xfc+u(-$xfr,$xfr))}
yf={($yfc+u(-$yfr,$yfr))}
xoff={($xoffc+u(-$xoffr,$xoffr))}
yoff={($yoffc+u(-$yoffr,$yoffr))}
xff={sign($xf)*w*0.00002*(abs($xf)^2)}
yff={sign($yf)*h*0.00002*(abs($yf)^2)}
xofff={sign($xoff)*w*0.00002*(abs($xoff)^2)}
yofff={sign($yoff)*w*0.00002*(abs($yoff)^2)}
fx_warp_by_intensity[$>] $xff,$yff,$xofff,$yofff,$correl,$interp,$bounds,$channels,0
fi
if {$>==0}
csswap[$>] $trgbf,1,0,0
fi
if $rn
if {round(u)}
negate[$>]
fi
fi
done
if {$>==($iter-1)||$rpo}
hf={$hfc+u(-$hfr,$hfr)}
sf={$sfc+u(-$sfr,$sfr)}
vilf={$vilfc+u(-$vilfr,$vilfr)}
af={$afc+u(-$afr,$afr)}
hoff={$hoffc+u(-$hoffr,$hoffr)}
soff={$soffc+u(-$soffr,$soffr)}
viloff={$viloffc+u(-$viloffr,$viloffr)}
aoff={$aoffc+u(-$aoffr,$aoffr)}
l[0] if {$vil==1} rgb2hsi8 elif {$vil==2} rgb2hsl8 else rgb2hsv8 fi
s c
*[0] $hf +[0] {$hoff*max(1,abs($hf))} %[0] 255
*[1] $sf +[1] {$soff*max(1,abs($sf))}
*[2] $vilf +[2] {$viloff*max(1,abs($vilf))}
a c
if {$vil==1} hsi82rgb elif {$vil==2} hsl82rgb else hsv82rgb fi
endl
*[1] $af +[1] {$aoff*max(1,abs($af))}
fi

done
to_rgb[0]
to_gray[1]
a c
endl
done


fx_ultrawarptwo_preview:
fx_ultrawarptwo $*


#@gui UltraWarp++++ : fx_ultrawarpplusplusplusplus, fx_ultrawarpplusplusplusplus(1)
#@gui : note = note("Sequence of multiple partially-randomised texture generation and image deformation filters with multi-iteration warping")
#@gui : note = note("<small>This modular filter is extremely complex and its logic may not follow that which you expect. Left on its default settings, it is very likely to munge your image beyond recognition.</small>"), sep = separator()
#@gui : 1.  Quick Refresh Button = button(0)
#@gui : sep = separator()
#@gui : 2.  Plasma Texture [Discards input image] = bool(0)
#@gui : 3.  Plasma Scale = float(3.3,0,20)
#@gui : 4.  Plasma Alpha Channel = bool(0)
#@gui : sep = separator()
#@gui : 5.  Segmentation [no alpha channel] = bool(0)
#@gui : 6.  Edge Threshold = float (5,0.01,60)
#@gui : 7.  Smoothness = float (0,0,60)
#@gui : sep = separator()
#@gui : 8.  Blur = float (0,0,30)
#@gui : sep = separator()
#@gui : 9.  Quadtree Pixelisation [no alpha channel] = bool(0)
#@gui : 10.  Quadtree Min Precision = int(4,2,8192)
#@gui : 11.  Quadtree Max Precision = int(256,0,8192)
#@gui : 12.  Quadtree Min Homogeneity = float(4.8,0,5)
#@gui : 13.  Quadtree Max Homogeneity = float(5,0,5)
#@gui : sep = separator()
#@gui : 14. Noise Type = choice(2,"Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : 15. Minimum Noise = float(0,0,8)
#@gui : 16. Maximum Noise = float(0,0,8)
#@gui : 17. Noise Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Warping</small>")
#@gui : 18. Warp Iterations = int(3,0,30)
#@gui : 19. Warp Intensity = float(3,0,10)
#@gui : 20. Warp Offset = float(20,0,2000)
#@gui : 21. Scale to Width = bool(1)
#@gui : 22. Scale to Height = bool(1)
#@gui : 23. Correlated Channels = choice("Random","Off","On")
#@gui : 24. Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : 25. Warp Channel(s) = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 26. Random Negation = bool(1)
#@gui : 27. Random Negation Channel(s) = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 28. Gamma Offset = float(0.25,0,1)
#@gui : 29. Hue Offset = float(1,0,1)
#@gui : 30. Normalise = bool(1)
#@gui : sep = separator(), note = note("<small>Final HSV Scaling</small>")
#@gui : 31. Minimum Hue = float(0,0,20)
#@gui : 32. Maximum Hue = float(5,0,20)
#@gui : 33. Minimum Saturation = float(0,0,20)
#@gui : 34. Maximum Saturation = float(3,0,20)
#@gui : 35. Minimum Value = float(0.5,0,20)
#@gui : 36. Maximum Value = float(2,0,20)
#@gui : note = note("<small>Set these to their minimum values for randomisation</small>")
#@gui : 37. Hue Offset = float(-180.01, -180.01, 180)
#@gui : 38. Saturation Offset = float(0, -1.01, 1)
#@gui : 39. Value Offset = float(0,-20.01,20)
#@gui : sep = separator(),
#@gui : -4. Normalise = bool(1)
#@gui : -3. Normalisation Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(),
#@gui : -2. UltraWarp++++ Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : -1. Value action = choice("None","Cut","Normalize")

ultrawarpplusplusplusplus:
hue_min={$31}
hue_max={$32}
sat_min={$33}
sat_max={$34}
val_min={$35}
val_max={$36}
j={min($hue_min,$hue_max)+(u*(max($hue_min,$hue_max)-min($hue_min,$hue_max)))}
k={min($sat_min,$sat_max)+(u*(max($sat_min,$sat_max)-min($sat_min,$sat_max)))}
l={min($val_min,$val_max)+(u*(max($val_min,$val_max)-min($val_min,$val_max)))}
-if {$2}
-if {$4} ch=0 -else ch=2 -endif
-ac  "rr={round(u*255)}
gg={round(u*255)}
bb={round(u*255)}
-fx_plasma 0.5,0,{$3},1,1,{$rr},{$gg},{$bb}
-if {$4} -to_rgba -else ch=2 -to_rgb -endif",{$ch}
-endif
-fx_gaussian_blur {$8},0,0,1,2,0,0
n_min={$15}
n_max={$16}
-if {$n_min > $n_max}
n_min = {$n_min + $n_max}
n_max = {$n_min - $n_max}
n_min = {$n_min - $n_max}
-endif
noise_exp={max(0,$n_min+(u*($n_max-$n_min)))}
n_amt={(2^($noise_exp-3))*$noise_exp}
-if {$5}
-fx_segment_watershed {$6},{$7},0,2,0
-endif
-if {$9}
p_min={$10}
p_max={$11}
h_min={$12}
h_max={$13}
-if {$p_min > $p_max}
p_min = {$p_min + $p_max}
p_max = {$p_min - $p_max}
p_min = {$p_min - $p_max}
-endif
-if {$h_min > $h_max}
h_min = {$h_min + $h_max}
h_max = {$h_min - $h_max}
h_min = {$h_min - $h_max}
-endif
-fx_noise {$n_amt},{$14},{$17},1,0
-fx_quadtree 0,{max(2,round($p_min+(u*($p_max-$p_min))))},{max(0,round($h_min+(u*($h_max-$h_min))))},0,3,1.5,1,1,0
-endif
-fx_noise {$n_amt},{$14},{$17},1,0
f={$18}
i={$19}
m={$20}
s={$28}
v={$29}
-repeat {max(0,$f)}
-if {$21}
scale_x=w/10
a={((2^($19-5))*$19)*(u-0.5)*$scale_x*0.025}
-else
scale_x=1
a={((2^($19-5))*$19)*(u-0.5)}
-endif
-if {$22}
scale_y=h/10
b={((2^($19-5))*$19)*(u-0.5)*$scale_y*0.025}
-else
scale_y=1
b={((2^($19-5))*$19)*(u-0.5)}
-endif
c=(u-0.5)*$m*sign($m)*$scale_x
d=(u-0.5)*$m*sign($m)*$scale_y
g={round((u*33.98)-0.49)}
h={(u-0.5)*$s*200}
o={(u-0.5)*$v*200}
-if {$23==1}
e=0
-elif {$23==2}
e=1
-else
e={round(u)}
-endif
-if {$24==0}
f={round((u*2.98)-0.49)}
-elif {$24==1}
f={round((u*2.98)+0.51)}
-else
f={($24)-2}
-endif
-if {$25==0}
-fx_warp_by_intensity {$a},{$b},{$c},{$d},{$e},0,{$f},{$g},0
-else
-ac  "-if {$21}
scale_x=w/10
a={((2^($19-5))*$19)*(u-0.5)*$scale_x*0.025}
-else
scale_x=1
a={((2^($19-5))*$19)*(u-0.5)}
-endif
-if {$22}
scale_y=h/10
b={((2^($19-5))*$19)*(u-0.5)*$scale_y*0.025}
-else
scale_y=1
b={((2^($19-5))*$19)*(u-0.5)}
-endif
c={(u-0.5)*$20*sign($20)*$scale_x}
d={(u-0.5)*$20*sign($20)*$scale_y}
-if {$23==1}
e=0
-elif {$23==2}
e=1
-else
e={round(u)}
-endif
-if {$24==0}
f={round((u*2.98)-0.49)}
-elif {$24==1}
f={round((u*2.98)+0.51)}
-else
f={($24)-2}
-endif
-_fx_warp_by_intensity {$a},{$b},{$c},{$d},{$e},0,{$f}",{$25},0
-endif
-if {$26}
nn={round(u)}
-if {$nn}
-if {$27==0}
nch={round((u*33.98)-0.49)}
-ac "-negate",{$nch}
-else
-ac "-negate",{$27}
-endif
-endif
-endif
-fx_adjust_colors 0,0,{$h},{$o},0,0
-if {$30}
-ac "-n 0,255",3
-endif
-done
-if {$37==-180.1}
hh=((u-0.5)*360)
-else
hh={$37}
-endif
-if {$38==-8.01}
ss=((u-0.5)*2)
-else
ss={$38}
-endif
-if {$39==-20.01}
vv=((u-0.5)*2)
-else
vv={$39}
-endif
-fx_mix_hsv {$j},{$hh},0,{$k},{$ss},0,{$l},{$vv},0,0,2,0
-if {$-4}
-ac "-n 0,255",{$-3}
-endif

fx_ultrawarpplusplusplusplus:
-repeat {max(0,l)}
-ac[$>] "-ultrawarpplusplusplusplus $*",$-2,$-1
-fx_adjust_colors[$>] 0,0,0,{(u-0.5)*200},0,0
-done

#@gui Rays from image : fx_rays_from_image, fx_rays_from_image(1)
#@gui : Power = float (5,0,10)
#@gui : X-center (%) = float(50,-100,200)
#@gui : Y-center (%) = float(50,-100,200)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value action = choice("None","Cut","Normalize")

rays_from_image:

-fx_transform_polar 0,$2,$3,"(R-a)*(4^(($1)-5))*$1/5","a",3

fx_rays_from_image:

-repeat {max(0,l)}
  -ac[$>] "-rays_from_image $*",$-2,$-1
-done

#@gui _<b>Contours</b>

#@gui Gradient norm [JR's mod] : fx_jr_gradient_norm, fx_jr_gradient_norm_preview(1)
#@gui : Smoothness = float(0,0,10)
#@gui : Contrast = float(0.45,0,1.5)
#@gui : Min threshold = float(40,0,100)
#@gui : Max threshold = float(60,0,100)
#@gui : Negative = bool(0)
#@gui : Include orientation = choice("Off","On","On &#40;extrapolate if negative&#41;")
#@gui : Scale X = float(1,0,5)
#@gui : Scale Y = float(1,0,5)
#@gui : Interpolation = choice(2,"Nearest","Average","Bilinear","Bicubic")
#@gui : Alpha = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")

jr_dir2rgb :
v - channels 0,1 repeat $! l[$>] nm={0,n}
s c complex2polar round.. 0.001
*. {180/pi} %. 360 100%,100%,1,1,1 mv... $!
c 0,360 if {im!=iM} n. 0,1 else f. 1  fi
a c hsv2rgb
nm $nm endl done v +

jr_gradient_norm :
b $1 gradient_norm c 0,255 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255

fx_jr_gradient_norm :
repeat $! l[$>]
if {$9==3}
inter=5
else 
inter={1+$9}
fi
if {$7!=1||$8!=1}
ww={w}
hh={h}
shift -0.5,-0.5,0,0,1
r {max(1,$7*w)},{max(1,$8*h)},100%,100%,$inter
fi
if $6
+l luminance gradient append c
blur $1 orientation +jr_dir2rgb
endl rm[1]
if $5
l[1]
rgb2hsv8 100%,100%,1,1 f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
if {$6==2}
fx_solidify_td 100,0,10,2,0
fi
rgb2hsv8 f "[i0,i1,255]" hsv82rgb
endl
fi
fi
jr_gradient_norm[0] ${1-5}
if {$7!=1||$8!=1}
r $ww,$hh,100%,100%,$inter
fi
if $6 blend multiply fi
if {$6==1} c 0,255 f "I==[255,255,255]?[0,0,0]:I" fi
if $10 rgb2hsv8 100%,100%,1,1 if {$6} [1] f[2] "j(#0,0,0,0,1)" f[0] "[i0,255,i2]" fi f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0] if {$6} blend[1,2] multiply fi a c fi
endl done
fx_jr_gradient_norm_preview : 
gui_split_preview "fx_jr_gradient_norm $*",${-3--1}

######################

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
