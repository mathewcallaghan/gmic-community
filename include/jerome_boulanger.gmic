#@gmic
#
#  File        : jerome_boulanger.gmic
#                ( G'MIC commands file )
#
#  Description : Define a set of gmic commands (mostly useful for bioimage analysis)
#
#  Copyright   : Jerome Boulanger
#
#  Licenses        : This file is 'dual-licensed', you have to choose one
#                    of the two licenses below to apply.
#
#                    CeCILL-C
#                    The CeCILL-C license is close to the GNU LGPL.
#                    ( http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html )
#
#                or  CeCILL v2.1
#                    The CeCILL license is compatible with the GNU GPL.
#                    ( http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html )
#
#  This software is governed either by the CeCILL or the CeCILL-C license
#  under French law and abiding by the rules of distribution of free software.
#  You can  use, modify and or redistribute the software under the terms of
#  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
#  at the following URL: "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
#

#---------------------------------
#
#@cli :: Input/Output
#
#---------------------------------

#@cli tiff3d
#@cli : Input a 3D tif as a 3D image
#@cli : Note: This is useful for loading several 3D image stack
tiff3d : -e[^-1] "Load the file $1 as a 3D image"
-v - n=$!
-i $1 -a[{$n}--1] z
-v +

#@cli toff3d
#@cli : Output a 3D tif as a 3D image
toff3d : -e[^-1] "Save the 3D image as a tiff file"
-v -
-repeat $!
-o[$>] ${"-filename \"$1\","$>}
-done
-v +

#---------------------------------
#
#@cli :: 3D Rendering
#
#---------------------------------

#@cli boundingbox3d : _separation
#@cli : Bounding box of a 3D volume
#@cli : $ 100,100,100 -boundingbox3d
boundingbox3d : -skip ${1=10}
-e[^-1] "3D Bounding box"
-v - -repeat $! -l[$>]
  -box3d {0,w},{0,h},{0,d} -primitives3d[-1] 1  -opacity3d[-1] 1
  -if {$1>0}
     -plane3d {0,w},{0,h},$1,{round({0,h}/{0,w}*$1)} -primitives3d[-1] 1 -opacity3d[-1] .1
  -endif
  -rm[0] -+3d
-endl -done -v +

#@cli render_volume  : _size,_quality,_opacity
#@cli : Pseudo volumic rendering
#@cli : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -render_volume
render_volume: -check "${1=8}>3&${2=5}>2&${3=.1}>0"
-v - -repeat $! -l[$>]
-mirror x
--tones {$2+1} -rm[1,2] -r[1--1] 100%,100%,100%,{0,s} -*[1--1] [0] -rm[0]
-reverse
-repeat $! i=$< -l[$<]
  -if {im!=iM}
    -pointcloud3d -gaussians3d $1,{$3*($i+1)/$2}
  -else
    -rm
  -endif
-endl -done
-+3d -md3d -1 -+3d {.5},{.5},{.5}
-endl -done -v +

#@cli display_volume : _size,_quality,_opacity
#@cli : Display the volume with black background, a bounding box
#@cli : and a volumic rendering of the data.
#@cli : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 -f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -display_volume 8,5,.1
display_volume: -check "${1=8}>3&${2=5}>2&${3=.1}>0"
-e[^-1] "display_volume with size $1 quality $2 and opactiy $3"
-v - -repeat $! -l[$>]
  --boundingbox3d 20
  -render_volume[0] $1,$2,$3
  -+3d
-endl -done -v +

d3d_black : 1 -d3d[0--2] [-1] -rm[-1]

#@cli view3d : _angle1,_angle2
#@cli : Apply a 3D view defined by two angles
#@cli : $ 50,50,50,3 -noise 10 -blur 5 -max 0 -n 0,255 -display_volume 32,5,1 -view3d
view3d : -skip ${1=25},${2=-120}
-e[^-1] "Apply 3D view"
-v - -repeat $! -l[$>]
  -rotate3d 0,0,1,$1 -rotate3d 1,0,0,$2
-endl -done -v +

#@cli colordepth
#@cli : Color depth coding
#@cli : $ 100,100,100 -noise 1 -blur 10,0 -max 0 -colordepth 5
colordepth: -skip ${1=5}
-e "colordepth coding with lut $1"
-v - -repeat $! -l[$>]
  -colordepth_volume $1 -s z -+
-endl -done -v +

#@cli colordepth_volume
#@cli : Make a 3D volume of the same size, color it, resize orignal in color and multiply
colordepth_volume: -skip ${1=5}
-v - -repeat $! -l[$>]
  -i [0] -f[-1] 'z/(d-1)*255' -map[-1] $1 -resize[0] 100%,100%,100%,3 -*
-endl -done -v +

colordepth_scale: -skip ${1=5}
10,{0,h-10} -f[-1] '(h-y)/(h-1)*255' -map[-1] $1 -frame[-1] 5,5,0,0,0

#@cli make_axis: _xmin,_xmax,_ymin,_ymax
#@cli : Display an axis around an image
#@cli : $ image.jpg -make_axis 0,1,0,1
make_axis:
-e[^-1] "Add axis"
-v - -repeat $! -l[$>]
  -frame 1,1,0
  100%,24,1,3,255 -axes[-1] $1,$2,{-1},{-1}
  24,{0,h},1,3,255 -axes[-1] {w},{w},$4,$3 24,24,1,3,255 -a[-1,-2] y
  -a[0,1] y -reverse -a[0,1] x
  -frame 12,12,255 100%,5,1,3,255,255,255 -reverse -a y
-endl -done -v +

#@cli xlabel: _label
#@cli : Add a label to the x-axis (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -xlabel "x-axis"
xlabel:
-e[^-1] "Add a x label"
-v - -repeat $! -l[$>]
  0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1] --lt[-1] 90%
  -image[0] [-2],{{0,w}/2+12-{1,w}/2},{{0,h}-{1,h}},0,0,1,[-1] -k[0]
-endl -done -v +

#@cli ylabel: _label
#@cli : Add a label to the y-axis (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -ylabel "y-axis"
ylabel:
-e[^-1] "Add a y label"
-v - -repeat $! -l[$>]
  0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1]
  -rotate[-1] -90 --lt[-1] 90%
  -image[0] [-2],0,{{0,h}/2-12-{1,h/2}},0,0,1,[-1] -k[0]
-endl -done -v +

#@cli title: _label
#@cli : Add a title (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -title "title"
title:
-e[^-1] "Add a title"
-v - -repeat $! -l[$>]
  0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1] --lt[-1] 90%
  -image[0] [-2],{{0,w}/2-{1,w}/2},0,0,0,1,[-1] -k[0]
-endl -done -v +

#---------------------------------
#
#@cli :: Feature detections
#
#---------------------------------

#@cli quiver2d
#@cli : Display a sequence 2D vector field on a 2D image sequence
#@cli : both being represented az a 3D stack
quiver2d:
-e[^-1] "Cumulative sum along z-axis"
-s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1],10,1,1,1,255 -endl -done -rm[{$!/2}--1] -a z

#@cli warp2d : [field]
#@cli : Warp a 2D image stack using a vector field
#@cli : $ movie.cimg  -a z -resize 50%,50% --l[0] --lucas_kanade 5,1 -cumulate[-1] z -frame 30,30,0 -warp2d -endl -frame[0] 30,30,0 -a x
warp2d:
  -e[^-1] "Warp a 3d stack using a displacement field"
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
    -s z -repeat {$!/2} -l[$>,{$>+$!/2}]
      -warp[0] [1],1,1,1
    -endl -done -rm[{$!/2}--1] -a z
  -endl -done -v +

#@cli lucas_kanade: scale,smoothing
#@cli : Motion estimation using lucas and kanade approach
#@cli : Works on 2D+t image stacks/ has side effect
#@cli : [vx vy] = [Ixx Ixy; Ixy Iyy]^-1 [Ixt Iyt]
#@cli : $ image.jpg -repeat 20 --shift[-1] 1,0,0,0,2 -done -a z --lucas_kanade 2 -n 0,255 -frame 2 -a x
#@cli : $ image.jpg -repeat 20 --shift[-1] 1,1,0,0,2 -done -a z --lucas_kanade 2  -s z -repeat {$!/2} -l[$>,{$>+$!/2}] -quiver[0] [1] -endl -done -rm[{$!/2}--1] -a z
lucas_kanade: -skip ${1=2},${2=1}
  -e[^-1] "Motion estimation with Lucas et Kanade algorithm"
  -v - -repeat $! -l[$>]
     -blur_xy $2 -structuretensors 0 -blur_xy $1,$1,0 # abcdef
     --l -s c -rm[0,-1] -*[1,2] -*[0,2] -reverse -- -endl  # dc-be
     --l[0] -s c -rm[3,5] -*[0,3] -*[1,2] -- -endl # ae-bc
     -l[0] -s c -rm[2,4,5] -*[0,2] -sqr[1] -- -endl # ad-b2
     -/[1,2] [0]  -rm[0] -a c
  -endl -done -v +

#@cli unwarp2d : iteration,scales,smoothness,keep_field
#@cli : Unwarp a 2D+T volume
#@cli :
#@cli : $ image.jpg -repeat 20 --shift[-1] 1,0,0,0,2 -done -a z -unwarp 10,20
unwarp2d: -skip ${1=5},${2=5},${3=1},${4=0}
  -e[^-1] "Unwarp a 2D+t volume with $1 iterations,
           $2 scales and smoothing $3"
  -v - -repeat $! -l[$>]
  # [1] warped [2] field
  [0] 100%,100%,100%,2,0
  -repeat $1
    k=$>
    -repeat $2
    # compute scale
    -if {$>==($2-1)} s=1 -else  s={($>+1)/$2} -endif scale={$s*100}%
    -echo_stdout $k" "$>" "$s" "$scale" "{1/$s}" "{$3*$s}
    # compute displacement field
    --l[1]
      -norm
      -r $scale,$scale,100%,1
      -lucas_kanade {max(.75,$3*$s)}
      -* {1/$s} -cumulate z
    -endl
    # scale & update the displacement field
    -r[-1] [-2],5 -+[-1,-2]
    # warp the original image
    --warp2d[0] [2] -rm[1] -reverse[-1,-2]
    -done -done
  -if {$4==0} -rm[0,2] -else -rm[0,1] -endif
  -endl -done -v +

#@cli estimate_shift_core [image]
#@cli : Estimate a translation with a reference images with sub-pixel accuray
#@cli : image.jpg  -luminance --shift {u},{u},0,0,2 -estimate_shift[1] [0]
estimate_shift_core:
-e[^-1] "Translation estimation with Lucas et Kanade algorithm"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
  -blur_xy 1 --gradient[0] xy,0 --[0,1] --sqr[1,2] --*[1,2] [0] -*[1,2] -rm[0]
  Ixy={0,ia} Ixx={1,ia} Iyy={2,ia} Ixt={3,ia} Iyt={4,ia}
  vx={-($Iyy*$Ixt-$Ixy*$Iyt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
  vy={-($Ixx*$Iyt-$Ixy*$Ixt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
  -rm 1,2,1,1,$vx,$vy
-endl -done -v +

#@cli multi_resolution_pyramide : _number_of_scales
#@cli : Build a multi-resolution pyramid
multi_resolution_pyramide:
-v - -repeat $! -l[$<]
  -repeat {$1-1} --resize[-1] 50%,50%,50%,100%,2 -done -reverse
-endl -done -v +

#@cli shift_subpixel : [image]
#@cli : Shift an image with subpixel translation
#@cli : $ image.jpg 1,2,1,1,5,10.1 --shift_subpixel[0] [1]
shift_subpixel :
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
   {0,w},{0,h},1,2 -f[-1] 'if(c==0,{1,i(0)},{1,i(0,1)})'
   -warp[0] [2],1,2,1 -rm[1,2]
-endl -done -v +

#@cli estimate_shift [image]
#@cli : Estimate a translations between image and ref image [image]
#@cli : using a multi-resolution scheme
#@cli : $ image.jpg -luminance --shift 2,3 -crop 5%,5%,95%,95% -estimate_shift[1] [0],3
estimate_shift:
-e[^-1] "Estimate translation between images and image [$1]"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
  N={round(log2(min({0,w},{0,h}))-2,1,-1)}
  -multi_resolution_pyramide $N
  1,2
  -repeat 3 -repeat $N
    # shift at current scale
    --*[-1] {-2.0^(-($N-$>-1))} --shift_subpixel[{$N+$>}] [-1] -rm[-2]
    # compute new correction
    -estimate_shift_core[-1] [$>]
    # convert correction to image scale
    -*[-1] {2.0^($N-$>-1)}
    # add the correction
    -+[-1,-2]
  -done -done
 -k[-1] -*[-1] -1
-endl -done -v +

#@cli unshift : iterations,number_of_scales
#@cli : Correct drift along Z in a 3D volume (video stabilization)
#@cli : $ image.jpg  -luminance -repeat  10 --shift[-1] {2*u},{2*u},0,0,2 -done -a z --unshift 1 -a x
unshift: -skip ${1=1}
-e[^-1] "unshift image stack"
-v - -repeat $! -l[$>]
  -repeat $1
    -s z -repeat {$!-1} -l[$>,{$>+1}]
      --estimate_shift[1] [0] -*[-1] -1
      -shift_subpixel[1] [-1] -rm[-1]
    -endl -done -a z
  -done
-endl -done -v +

#@cli register_lucas_kanade : _iterations, _scale
#@cli : Register images using lucas kanade motion estimation
#@cli : $ movie.cimg -luminance -resize 50%,50% -a z -register_lucas_kanade 5,10
register_lucas_kanade : -skip ${1=10},${2=10}
--lucas_kanade $2 -cumulate[-1] z --warp2d
-repeat $1
-lucas_kanade[-1] $2 -cumulate[-1] z -+[-1,-2] --warp2d
-done

#@cli detect_events : _scale_xy,_scale_t,_threshold
#@cli : Detect space time events using space time interest points
#@cli : $ 100,100,100 -noise 1 -blur 2 --detect_events , -pointscoordinates[-1] -resize[0] 100%,100%,100%,3,1 -n[0] 0,255 -circles[0] [1] -k[0]
detect_events : -skip ${1=1},${2=1},${3=9}
  -e[^-1] "detect events with scale_xy $1 scale_z $2 and threshold $3"
  -v - -repeat $! -l[$>]
    -blur_xy $1 -blur_z $2 -structuretensors -blur_xy $1 -blur_z $2
    -s z -apply_parallel "-eigen -k[0] -s c -k[2]" -a z
    -sqrt
    thres={{0,ia}+$3*sqrt({0,iv})}
    --max_patch[0] 8 -threshold[0] $thres -*
  -endl -done -v +

#@cli detect_spots : _scale,_threshold
#@cli : Detect spots in the image
#@cli : $ 100,100 -noise .2,2 -blur 1 -n 0,255 -noise 5 --detect_spots , -pointscoordinates[-1] -resize[0] 100%,100%,1,3,1 -circles[0] [1] -k[0]
detect_spots : -skip ${1=1},${2=4}
  -e[^-1] "detect events with scale $1 and threshold $2"
  -v - -repeat $! -l[$>]
    -blur $1 --blur $1 -- thres={$2*${-mad[0]}}
    --max_patch[0] 3 --threshold[0] $thres -*
  -endl -done -v +

#@cli measure_colocalization:
#@cli : Colocalization analysis
#@cli : Overlap RG/R RG/G RG/R+G MOC M1 and M2
#@cli : $ 256,256,1,2 -noise 3 -blur 5 -measure_colocalization
measure_colocalization:
-v - -repeat $! -l[$>]
  -if {{0,s}==2}
   # r,g,r>0,g>0,r.r,g.g,r.g,(r>0).(g>0)
   -s c --gt 0 --sqr[0,1] --*[0] [1] --*[2] [3] --or[2] [3]
   O1={{7,is}/{2,is}}
   O2={{7,is}/{3,is}}
   O={{7,is}/{8,is}}
   # r,g,(r>0).g,(g>0).r,r.r,g.g,r.g,(r>0).(g>0)
   -*[2] [1] -*[3] [0]
   MOC={{6,is}/sqrt({4,is}*{5,is})}
   M1={{3,is}/{0,is}}
   M2={{2,is}/{1,is}}
   -rm  1,6,1,1,$O1,$O2,$O,$MOC,$M1,$M2
  -else
   -echo "needs images with two channels"
   1,6,1,1,0,0
  -endif
-endl -done -v +

#@cli measure_colocalization_object:
#@cli : Compute the number of intersecting objects
#@cli : in each channels versus the number of objects
#@cli : $ 256,256,1,2 -noise 3 -blur 5 -gt 0 -measure_object_colocalization
measure_object_colocalization:
-v - -repeat $! -l[$>]
  -if {{0,s}==2}
    -gt 0 -s c -label_fg .1
    n1=0 -repeat {0,iM}
      --eq[0] {$>+1} -*[-1] [1]
      -if  {iM>0} n1={$n1+1} -endif
      -rm[-1]
    -done
    n1={0,100*$n1/iM}
    n2=0 -repeat {1,iM}
    --eq[1] {$>+1} -*[-1] [0]
      -if  {iM>0} n2={$n2+1} -endif
      -rm[-1]
    -done
    n2={1,100*$n2/iM}
    -rm
    1,2,1,1,$n1,$n2
  -else
    -echo "needs images with two channels"
    1,6,1,1,0,0
  -endif
-endl -done -v +

#@cli local_moments : _scale
#@cli : Compute local second order moments tensor
#@cli : http://en.wikipedia.org/wiki/Image_moment
#@cli : $ image.jpg --local_moments 1
local_moments : -skip ${1=1}
-v - -repeat $! -l[$>]
-norm
-if {d==1}
  --mul[0] 'x'   --mul[0] 'y'   --mul[0] 'x*x'
  --mul[0] 'x*y' --mul[0] 'y*y' -blur $1
  --sqr[1] -/[-1] [0] --[3,-1] -/[3] [0]
  --*[1,2] -/[-1] [0] --[4,-1] -/[4] [0]
  --sqr[2] -/[-1] [0] --[5,-1] -/[5] [0]
  -k[3-5] -a c
-else
  --mul[0] 'x'   --mul[0] 'y'   --mul[0] 'z'   --mul[0] 'x*x'
  --mul[0] 'x*y' --mul[0] 'x*z' --mul[0] 'y*y' --mul[0] 'y*z'
  --mul[0] 'z*z' -blur $1
  --sqr[1] -/[-1] [0] --[4,-1] -/[4] [0]
  --*[1,2] -/[-1] [0] --[5,-1] -/[5] [0]
  --*[1,3] -/[-1] [0] --[6,-1] -/[6] [0]
  --sqr[2] -/[-1] [0] --[7,-1] -/[7] [0]
  --*[2,3] -/[-1] [0] --[8,-1] -/[8] [0]
  --sqr[3] -/[-1] [0] --[9,-1] -/[9] [0]
  -k[4-9] -a c
-endif
-endl -done -v +

#@cli smooth_moments : _scale,_iterations,_dt
#@cli : Anisotropic diffusion using local moment tensors
#@cli : $ image.jpg --noise 10 --smooth_moments[-1] 1,10,1 -print_psnr
smooth_moments: -check "${1=1}>0&${2=100}>0&${3=1}>0"
-v - -repeat $! -l[$>]
  --local_moments[-1] $1 -smooth[0] [1],$2,$3,0 -k[0]
-endl -done -v +

#@cli pointscoordinates
#@cli : Return the list of points in the image as 3xN or 2xN columns vector
#@cli : $ 100,100 -noise .1,2 ==. 1 --pointscoordinates
pointscoordinates :
  -e[^-1] "return the list of points in the image"
  -v - -repeat $! -l[$>]
    -if {d>1}
      -if {iM>0} -pointcloud3d -s3d -k[2] -split y,{h/3} -a x -else 0 -endif
    -else
      -if {iM>0} -pointcloud3d -s3d -k[2] -split y,{h/3} -a x -else 0 -endif
      -rows 0,1
    -endif
  -endl -done -v +

#@cli circles : [x,y,radius,opacity,color,..] ||  [x,y,z,radius,opacity,color,..]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 -circles[0] [1] -k[0]
circles: -skip ${2=3},${3=1}
-e[^-1] "Draw circles on the image."
-v -  -pass$1 0 -repeat {$!-1} -l[$>,-1]
    -if {{0,d}>1} # 3D case
    -if {1,h<4} -r[1] 100%,{5+{0,s}},1,1,0 -l[1] -s y -f[3] $2 -f[4] $3 -f[5--1] 255 -a y -endl -endif
    -repeat {1,w}
      x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} o={1,i($>,4)} i=$>
      -repeat {0,s}
        -if {$z>=0&$z<{0,d}-1}
          -sh[0] $z,$z,$> -ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,5+$>)}
          -rm[-1]
	-endif
      -done
      -done
    -else # 2D case
      -if {1,h<3} -r[1] 100%,{4+{0,s}},1,1,0 -l[1] -s y -f[2] $2 -f[3] $3 -f[4--1] 255 -a y -endl -endif
    -repeat {1,w}
      x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} o={1,i($>,3)} i=$> col={1,i($>,4)}
      -repeat {0,s}
        -sh[0] 0,0,$> -ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,{4+$>})}
        -rm[-1]
      -done
     -done
    -endif
-endl -done -rm[-1] -v +

#@cli labels: [image]
#@cli : Draw labels on the image
#@cli : The labels are defined by image as
#@cli : in 2D [x,y,label,font_size,opacity,color]
#@cli : in 3D [x,y,z,label,font_size,opacity,color]
#@cli : $ 512,512,1,3 10,2 -noise[-1] 1 -n[-1] 0,512 -labels[0] [1]
labels:
-e[^-1] "Draw labels on the image."
-v -  -pass$1 0 -repeat {$!-1} -l[$>,-1]
    -if {{0,d}>1} # 3D case
    -if {1,h<4}
      -r[1] 100%,{6+{0,s}},1,1,0
      -l[1] -s y -f[3] 'x' -f[4] 13 -f[5] 1 -f[6--1] 255 -a y -endl
    -endif
    -repeat {1,w}
      x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} f={1,i($>,4)} o={1,i($>,5)} i=$>
      -repeat {0,s}
        -if {$z>=0&$z<{0,d}}
          -sh[0] $z,$z,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,6+$>)}
          -rm[-1]
	-endif
      -done
      -done
    -else # 2D case
      -if {1,h<3}
        -r[1] 100%,{5+{0,s}},1,1,0 -l[1] -s y -f[2] 'x' -f[3] 13 -f[4] 1 -f[5--1] 255 -a y -endl
      -endif
      -repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} f={1,i($>,3)} o={1,i($>,4)} i=$>
	-repeat {0,s}
          -sh[0] 0,0,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,5+$>)}
          -rm[-1]
        -done
      -done
    -endif
   -rm[-1]
-endl -done -v +

#@cli : croparound : [x,y,dx,dy] || [x,y,z,dx,dy,dz]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 -circles[0] [1] -k[0]
croparound: -skip ${2=3},${3=3},${4=3}
  -e[^-1] "Crop image at coordinates "
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
    -if {0,d>1} # 3D case
      -if {1,h<6}
        -r[1] 100%,6,1,1,0
        -l[1] -s y -f[3] $2 -f[4] $3 -f[5] $4 -a y -endl
       -endif
      -repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} dx={1,i($>,3)} dy={1,i($>,4)} dz={1,i($>,5)} i=$>
        --crop[0] {$x-$dx},{$y-$dy},{$z-$dz},{$x+$dx},{$y+$dy},{$z+$dz}
        -done
    -else # 2D case
      -if {1,h<4} -r[1] 100%,4,1,1,0 -l[1] -s y -f[2] $2 -f[3] $3 -a y -endl -endif
      -repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} dx={1,i($>,2)} dy={1,i($>,3)} i=$>
        --crop[0] {$x-$dx},{$y-$dy},{$x+$dx},{$y+$dy}
     -done
    -endif
  -endl -done -rm[0,1] -v +

#@cli random_walks : width,height,length,number,speed
#@cli : Generate random walks tracks (list of coordinates x,y,t as a Nx3 image.)
#@cli : $ 100,100,20 -random_walks 100,100,20,5,1 -circles[0] [1] -k[0] -blur_xy 1 -s z -max
#@cli : $ 100,100,20 -random_walks 100,100,20,10,1 -circles[0] [1] -k[0] -blur 1 -n 0,255 -display_volume 8,10,1 -rotate3d 0,0,1,25 -rotate3d 1,0,0,-120 -snapshot3d 600,1,0,0,0 -autocrop
random_walks :
number=$4 width=$1 height=$2 length=$3 speed=$5
$number,3
-l[-1]
  -noise 1,1
  -sh 0,0,0,0 -n[-1] 1,{$width-1} -rm[-1]
  -sh 1,1,0,0 -n[-1] 1,{$height-1} -rm[-1]
  -sh 2,2,0,0 -f[-1] 0 -rm[-1]
  -repeat {$length-1} --l[-1]
    -noise 1
    -sh 0,0,0,0 -c[-1] 1,{$width-2} -rm[-1]
    -sh 1,1,0,0 -c[-1] 1,{$height-2} -rm[-1]
    -sh 2,2,0,0 -f[-1] '$>+1' -rm[-1]
  -endl -done -a x
-endl

#@cli fibers: number,length,curvature
#@cli : Draw a serie of fibers in 2D or 3D
#@cli : $ 600,400 -pelotte 10,200,10
fibers :
-repeat $! -l[$>]
   $2,$1,1,{if(d>1,3,2)}
   -l[-1] -noise[-1] 10 -blur_x[-1] $3 --norm -/ -endl
   -if {0,d>1} -s[-1] c -*[3] {0,2*d/(w+h)} -a[1--1] c -endif
   -cumulate[-1] x -s[-1] y
   -repeat {$!-1}
     -l[0,{$>+1}]
        -s c
        -+[1] {0,w/2}
	-+[2] {0,h/2}
	-if {$!>3} -+[3] {0,d/2} -endif
	-a[1--1] y
       -circles[0] [1],0,-1
     -endl
   -done
   -k[0]
   -endl -done


#---------------------------------
#
#@cli :: Filtering and deconvolution
#
#---------------------------------

#@cli movavg : _size>=1
#@cli : moving average of image list with a box filter of size _size
#@cli : $ 11 -f 'x>w/2' --l[-1] -s x -movavg 9 -a x -endl  --blur[0] 1.2 -a c -display_graph
movavg : -check "$1>=1"
-e[^-1] "moving average with size "$1 -v -
n={$1-1}
-repeat $n
  -repeat {{$!}-1} --+[{$>},{$>+1}] -*[-1] .5 -rm[$>] -mv[-1] $> -done
  -reverse
-done
-if {$n%2!=0} -reverse -endif
-v +

#@cli zmean
#@cli : average along z-axis
zmean :
-v - -repeat $! -l[$>]
n={0,d} -s z -+ -/ $n
-endl -done -v +

#@cli zstd
#@cli : standard deviation along z-axis
zstd :
-v - -repeat $! -l[$>]
--zmean -sqr[-1]
-l[0] -sqr -zmean -endl
-- -sqrt
-endl -done -v +

#@cli zmax
#@cli : maximum along z-axis
zmax :
-v - -repeat $! -l[$>] -s z -max -endl -done -v +

#@cli zmin
#@cli : maximum along z-axis
zmin :
-v - -repeat $! -l[$>]  -s z -min -endl -done -v +

#@cli kymoline:
#@cli : interactively select a line and extract a line profile
kymoline:
--select 1
x1={i(0,0)} y1={i(0,1)} x2={i(0,3)} y2={i(0,4)}
d={sqrt(($x2-$x1)^2+($y2-$y1)^2)}
u={($x2-$x1)/$d} v={($y2-$y1)/$d}
-rm[-1]
-f 'if(x<=$d&&y==0,i($x1+x*$u,$y1+x*$v,z,c,1),5)'
-crop 0,0,{int($d-1)},0

#@cli fftshift
#@cli : Shift a image so that the fft has it center in the middle
#@cli : $ image.jpg -fftshift
fftshift :
  -v - -repeat $! -l[$>]
    -shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
  -endl -done -v +

#@cli whiten_frequency : _alpha
#@cli : Whitening filter (equalize the frequency of the image; nothing todo with color)
#@cli : $ image.jpg -whiten_frequency
whiten_frequency : -check "${1=.25}>=0"
-e[^-1] "Whiten the frequency with parameter "$1
-v - -repeat $! -l[$>]
#E={0,sqrt(iv)}
-fft --a c -norm[-1] -pow[-1] $1 -max[-1] 1e-12 -/[-1] {ia} -/[0-1] [2] -rm[2] -ifft -k[0]
#-* {$E/sqrt(iv)}
-endl -done -v +

#@cli deblur_goldmeinel2 : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur and zoom x2 selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg --blur 1 --deblur_goldmeinel2[-1] 1
deblur_goldmeinel2 : -check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1} -skip ${5=1}
  -e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${-arg\ 1+!$4,"",quasi-}"gaussian kernel."
  -v - -repeat $! -l[$>]
    [0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
      --b[-1] $1,1,$4 -r[-1] 50%,50%,50% --/[0,-1] -rm[-2] -^[-1] $3 -r[-1] 200%,200%,200%,100%,5 -*[-1,-2] # u *= f / Hu

    -done -rm[0]
  -endl -done -v +


#@cli deblur_richardsonlucy2 : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@cli : Deblur and zoom selected images using Richardson-Lucy algorithm.
#@cli : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@cli : $ image.jpg --blur 1 --deblur_richardsonlucy2[-1] 1
deblur_richardsonlucy2 : -check "$1>=0 && ${2=50}>=0" -skip ${3=1} -skip ${4=1}
  -e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${-arg\ 1+!$3,"",quasi-}"gaussian kernel."
    -v - -repeat $! -l[$>]
    [0] -r[-1] 200%,200%,200%,100%,5 -repeat $2
    --b[-1] $1,1,{$3!=0} -r[-1] 50%,50%,50%,100%,5 --/[0,-1] -rm[-2] -r[-1] 200%,200%,200%,100%,5 -b[-1] $1,1,{$3!=0}  -*[-1,-2] # u *= H ( f / Hu )
    -done -rm[0]
  -endl -done -v +

#@cli correlate_fft
#@cli : Convolve selected images with image [$1]
#@cli : $ image.jpg 100%,100% -gaussian[-1] 20,1,45 --correlate_fft[0] [1]
correlate_fft :
  -e[^-1] "Correlate image with image [$1]"
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
    w2={int({0,w}/2)} h2={int({0,h}/2)} d2={int({0,d}/2)}
    -r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5  -shift[1] -$w2,-$h2,-$d2,0,2
    -fft[0] -fft[2] -*[3] -1
    --*[-4] [-1] --*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    -ifft -rm[-1]
  -endl -done -v +

#@cli deconvolve_richardsonlucy : filter,nb_iter>=1, acceletation>=0
#@cli : Deconvolve images using the first one as a blur operator (PSF)
#@cli : $ image.jpg 16,16 -gaussian[-1] 2,1,45 --convolve_fft[0] [1] -deconvolve_richardsonlucy[-1] [1],100
deconvolve_richardsonlucy : -check ${-is_image_arg\ $1}" && ${2=5}>=1"
 -e[^-1] "Deblur image using Richardson-Lucy algorithm with filter [$1]."
 -v - -pass$1 0
 -repeat {$!-1} -l[$>,-1]
   -r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1] [0]
   -repeat $2
     --convolve_fft[-1] [1] -max[-1] 1e-6 --/[0] [-1] -rm[-2]
     -correlate_fft[-1] [1] -*[-1,-2]   # u *= H ( f / Hu )
   -done -rm[0,1]
 -endl -done -v +

#@cli deconvolve_goldmeinel : filter,nb_iter>=1,acceleration>=0
#@cli : Deblur and zoom selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg 100%,100% -gaussian[-1] 5,1,45 --convolve_fft[0] [1] --deconvolve_goldmeinel[-1] [2],5
deconvolve_goldmeinel : -check ${-is_image_arg\ $1}" && ${2=5}>=1 && ${3=1}>=1"
 -e[^-1] "Deblur image using Gold-Meinel algorithm with filter $1, $2 iterationsand acceleration $3."
 -v - -pass$1 0
  -repeat {$!-1} -l[$>,-1]
    -r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1]
    --blur[0] 1
    -repeat $2
      --convolve_fft[-1] [1] -max[-1] 1e-6 --/[0] [-1] -rm[-2]
      -^[-1] $3 -*[-1,-2] # u *= (f / Hu)^$3
    -done -rm[0,1]
 -endl -done -v +

#@cli blend_sharpness
#@cli : Blend images in the list according to their sharpness
blend_sharpness:
  -e[^-1] "Blend images according to their sharpness"
  -v -
    N=$! --gradient_norm
    --+[$N--1] -max[$N--1] .01 -/[$N--2] [-1] -rm[-1] -a[$N--1] z -d[-1] -s[-1] z
    -a[0-{$N-1}] x -a[1--1] x -* -s x,$N -+
  -v +

#@cli reconstruct_laplacian : param
#@cli : Reconstruct an image from its laplacian
#@cli : $ image.jpg --laplacian -reconstruct_laplacian[-1] ,
reconstruct_laplacian: -skip ${1=0}
  -e[^-1] "Reconstruct an image from its laplacian"
    -v - -repeat $! -l[$>]
    -s c -repeat $! -l[$>]
      -fft a={0,i(0,0)} b={1,i(0,0)}
      100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
      -=[-1] 1 -+[-1] $1
      -/[0,1] [-1] -k[0,1] -=[0] $a -=[1] $b -ifft -k[0]
    -endl -done -a c
  -endl -done -v +

#@cli local_variance : _radius,_robust
#@cli : Local variance filter
#@cli : $ image.jpg  --local_variance
local_variance: -skip ${1=2},${2=0}
  -e[^-1] "Estimate local variance with scale "$1" and robustness "$2
  -v - -repeat $! -l[$>]
    -if {$2==0}
      --blur $1,1,1 -- -sqr -blur $1,1,1
    -else
       --median {2*$1+1} -- -abs -median {2*$1+1} -* 1.4826 -sqr
    -endif
  -endl -done -v +

#@cli local_noise_variance : _radius,_robust
#@cli : Local noise variance filter
#@cli : $ image.jpg  --local_variance
local_noise_variance: -skip ${1=2},${2=0}
  -e[^-1] "Estimate local variance with scale "$1" and robustness "$2
  -v - -repeat $! -l[$>]
    -laplacian -if {d==1} -* {1/sqrt(20)} -else -* {1/sqrt(42)} -endif -local_variance $1,$2
  -endl -done -v +

#@cli normalize_local_variance : _amplitude,_radius,_threshold,_repeat
#@cli : Local variance normalization
#@cli : $ image.jpg  --normalize_local_variance
normalize_local_variance: -skip ${1=50},${2=2},${3=25},${4=1}
  -e[^-1] "Normalize local variance with amplitude $1, scale $2, threshold $3 (x$4 times)."
  -v - -repeat $! -l[$>]
  -repeat $4
   --local_variance $2 -sqrt[-1] -max[-1] $3 # compute local standard deviation
   --blur[0] $2,1,1 ---[0,-1] -/[-1] [1] -*[-1] $1 -+[-2,-1] -k[-1] # x = <x> + alpha * (x-<x>)/<x'x>
  -done
  -endl -done -v +

#@cli local_wiener : _radius
#@cli : Local Wiener filtering
#@cli : http://en.wikipedia.org/wiki/Wiener_filter
#@cli : $ image.jpg --noise 10 --local_wiener[-1] 1 -print_psnr
local_wiener : -skip ${1=2}
  -e[^-1] "Local Wiener filtering"
  -v - -repeat $! -l[$>]
    sigma=${-noise_std}
    --blur $1 # mean
    --local_variance[0] $1 ---[-1] {$sigma*$sigma} -reverse[-1,-2] -/[-1,-2] # variance
    ---[0,1] # img-mean
    -*[-1,-2] -+[-1,-2] -k[-1]
  -endl -done -v +

#@cli periodize
#@cli : Periodization of the image
#@cli : $ image.jpg -periodize
periodize :
-e[^-1] "periodize"
-v - -repeat $! -l[$>]
-if {w>1} --mirror x -a x -endif
-if {h>1} --mirror y -a y -endif
-if {d>1} --mirror z -a z -endif
-endl -done -v +

#@cli tape
#@cli : Apply a Hann window (e.g. to compute a power spectrum)
#@cli : $ image.jpg -tape
tape :
  -e[^-1] "apply a Hann tapering window"
  -v - -repeat $! -l[$>]
    -if {w>1} -f 'i*sin(pi*x/(w-1))^2' -endif
    -if {h>1} -f 'i*sin(pi*y/(h-1))^2' -endif
    -if {d>1} -f 'i*sin(pi*z/(d-1))^2' -endif
  -endl -done -v +

#@cli powerspectrum :
#@cli : Compute power spectrum
#@cli : $ image.jpg -powerspectrum
powerspectrum :
  -e[^-1] "Compute power spectrum"
  -v - -repeat $! -l[$>] -display_fft -k[0] -endl -done -v +

#@cli fouriermix : [image],_cut_of_frequency
#@cli :  Mix two images using their respectives low and high frequencies
#@cli : $ image1.jpg image2.jpg  --fouriermix .5
fouriermix : -skip ${2=10%}
  -e[^-1] "fourier mix images."
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
  -fft[0] -fft[2] -fftshift
    # make a mask
    100%,100% -circle[-1] 50%,50%,$2,1,1 -blur[-1] 1,1,1 -n[-1] 0,1 -d
    -*[0,1] [-1] -negate[-1] -*[2,3] [-1] -rm[-1] -+[0,2] -+[1,2] -fftshift
    -ifft
  -endl -done -rm[-1] -v +

#@cli blend_fft: [image]
#@cli : blend images using strongest frequencies
blend_fft : -skip ${2=2}
  -v - -pass$1 0
  --l[-1]
    -tape -powerspectrum -blur 1 --blur 2 --
    -max '{ia+$2*sqrt(iv)}' -circle 50%,50%,20,1,@{0,im} -n 0,1 -d
    -fftshift
  -endl -fft[-2] -*[-2,-3] [-1] -negate[-1]
  -repeat {$!-3} -l[$>,-1,-2,-3]
    -fft[0] -*[0,1] [-1] -+[0] [2] -+[1] [3] -ifft[0,1] -rm[1]
  -endl -done -rm[-1,-2,-3] -v +

#@cli denoise_fft : _threshold
#@cli : Illustrate the thresholding of Fourier coefficients
#@cli : $ 256,256 -f '128+128*sin(x+y)' --noise 50 --denoise_fft[-1] 70%
denoise_fft : -skip ${1=1}
  -e[^-1] "Threshold Fourier coefficients with threshold "$1"."
  -v - -repeat $! -l[$>]
    --l[-1] -tape -powerspectrum -threshold $1 -fftshift -endl
    -fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft -k[0]
    -n 0,255
  -endl -done -v +

#@cli unstrip : _smoothness,_scale,_threshold
#@cli : Remove stripes in an image
#@cli : $ image.jpg -f '.5*i*(1+.25*sin(x))' --unstrip
unstrip : -skip ${1=25},${2=20},${3=4}
  -e[^-1] "Remove stripes"
  -v - -repeat $! -l[$>]
  # create a mask
    --l[-1]
     -tape -powerspectrum -norm -detect_spots 1,$3 -dilate_circ $2 -gt 0
     -n 0,1 -negate -circle 50%,50%,$2,1,1
     -if {im<.9} # check if some spots have been detected
       active=1 -blur $1 -n 0,1 -fftshift -if {iM==0} -f 1 -endif
     -else
       active=0
     -endif
    -endl
    #apply the mask
    -if {$active==1}
      -fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] -ifft
    -endif
    -k[0]
  -endl -done -v +

#@cli autocorrelate
#@cli : Autocorrelation using fourier transform
#@cli : $ image.jpg -autocorrelate
autocorrelate :
  -e[^-1] "Compute autocorrelation"
  -v - -repeat $! -l[$>] -fft -sqr -+ -sqrt -ifft -k[0] -fftshift -endl -done -v +

#@cli spotify : _scale>0,_nb_iter>0,
#@cli : Make everything look like a spot
#@cli : Default values '_nb_iter=1, _scale=1'
#@cli : $ image.jpg --spotify 1,10
#@cli : $ image.jpg --spotify 1,20 -norm[-1] -gt[-1] 5% -blur 1 -*
spotify : -check "${1=1}>0 && ${2=1}>0"
-e[^-1] "Spotify with scale $1 with $2 iterations"
-v - -repeat $! -l[$>]
  -if {0,im!=iM}
    s={0,ia}
    -repeat $2
      -b $1 --b {2*$1} -- -max 0 -* '{0,$s/ia}'
    -done
  -endif
-endl -done -v +

#@cli mapblur : _levels
#@cli : Blur the image with a map
#@cli : $ image.jpg --f '10*x/w' -mapblur
mapblur: -check "${1=10}>0"
-e[^-1] "Blur images using a blur map (works using pairs of images)."
-v - -repeat {$!/2} -l[{2*$>},{2*$>+1}]
  smin={1,im} smax={1,iM}
  -l[0] -repeat $1 --blur[0] {$smin+$>*($smax-$smin)/($1)} -done -rm[0] -a z -endl
  -l[1] -tones $1 -gt 0 -blur 1 -a z -endl
  -* -s z -+
-endl -done -v +

#@cli vesselness : _scale>0,coefA,coefB,coefC
#@cli : Frangi's vesselness filter based on the eigen value of the Hessian
#@cli : Reference:
#@cli : A. F. Frangi, W. J. Niessen, K. . L. Vincken, M. A. Viergever,
#@cli : "Multiscale vessel enhancement filtering"
#@cli : Medical Image Computing and Computer Assisted Intervention MICCAI'98,
#@cli : vol. 1496, pp. 130 137, 1998.
#@cli : $ vessel.png --negate -vesselness[-1] 3
vesselness : -skip ${1=1},${2=1},${3=1},${4=1}
-e[^-1] "Tubeness with scale $1."
-v - -repeat $! -l[$>]
  -blur $1
  -s c -repeat $! -l[$>]
    # Hessian eigen values sorted by absolute value
    -hessian -a c -eigen -k[0] --sign -abs[-2] -sort[-2] +,c -* --norm -a c
    -if {d>1}
      -f 'if(i(x,y,z,1)<0&&i(x,y,z,2)<0,exp(-0.5/$2^2*(i(x,y,z,1)/i(x,y,z,2))^2)*exp(-0.5/$3^2*(i(x,y,z,0)^2/abs(i(x,y,z,1)*i(x,y,z,2))))*(1-exp(-0.5/$4^2*i(x,y,z,3)^2)),0)'
    -else
      -f 'if(i(x,y,z,1)<0,exp(-0.5/($2)^2*(i(x,y,z,0)/i(x,y,z,1))^2)*(1-exp(-0.5/($3)^2*i(x,y,z,2)^2)),0)'
    -endif
  -endl -done -a c
-endl -done -v +


#@cli bgsubstract : _length>0
#@cli : Substract the background using a temporal top-hat filter
#@cli : $ 100,100,100 -noise 1 -blur 1 --bgsubstract 10
bgsubstract:  -check "${1=5}>0"
  -e[^-1] "Temporal background substraction with length $1."
  -v - -repeat $! -l[$>]
    1,1,$1 -f[-1] 1 --erode[0] [1] --[0] [-1] -rm[1,-1]
  -endl -done -v +

#@cli schizo : _amplitude,_amplitude_normal,_nb_iterations,_strength
#@cli : Schizo filter gives either a furry image or a smoothed image
#@cli : Default values '_amplitude=100,amplitude_normal=-50 _nb_iter=5,_strength=.75'
#@cli : $ image.jpg --schizo 100,-50 --schizo[0] -50,100 -max 0
schizo : -skip ${1=100},${2=-50},${3=5},${4=.75}
  -e[^-1] "Schizo filter smoothing with // $1 and T $2 and $3 iterations."
  -v - -repeat $! -l[$>]
  [0]
  -repeat $3
   -l[-1]
     --iee -*[-1] {$1/(0.0001+max(abs(im),abs(iM)))}
     --inn[0] -*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}
     -+
   -endl
   -*[-1] $4  --*[0] {1-$4} -+[-1,-2]
   -done -rm[0]
 -endl -done -v +

#@cli scandoc : _smooth,_background,_black,_white
#@cli : improve scanned document
#@cli : $ image.jpg -scandoc
scandoc: -skip ${1=3},${2=100},${3=10%},${4=90%}
  -v - -repeat $! -l[$>] -split_opacity -l[0]
    -median $1 --blur $2 -- -min 0
    -s c -n 0,1 -a c -c $3,$4 -n 0,255
  -endl -a c -endl -done -v +

#@cli warp_affine [3x3 affine matrix]
#@cli : Warp the image [0] using an 2D affine field defined by a 3x3 matrix
#@cli : $ image.jpg 3,1,1,1,1 -diagonal[-1] -noise[-1] .1 --warp_affine[0] [1]
warp_affine :
  -e[^-1] "Warp image using affine transform defined by 3x3 image ["$1"]"
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
    params=({1,i(0,0)},{1,i(1,0)},{1,i(2,0)};\
           {1,i(0,1)},{1,i(1,1)},{1,i(2,1)};\
           {1,i(0,2)},{1,i(1,2)},{1,i(2,2)})
    {0,w},{0,h},1,1,1 --f[-1] x --f[-1] y -a[-3--1] c
    -mix_channels[-1] $params
    -channels[-1] 1,2
    -warp[0] [-1],0,2,0 -rm[-1]
  -endl -done -rm[-1] -v +

#@cli solve_least_square: X
#@cli : Solves $|Ax-b|^2$
#@cli : $  (1,1,1,1;1,2,1,2;1,1,2,2) (-1,1,0;-2,0,1) -mmul[1] [0] -solve_least_square[0] [1]
solve_least_square:
  -e[^-1] "Solves least square"
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
    --transpose --mmul[0,2] --mmul[0,3]
    -k[-1,-2] -invert[0] -mmul -transpose
  -endl -done -v +

#@cli calibrate_affine_transform : image
calibrate_affine_transform :
-e[] "Interactive affine transformation calibration between image and image $1"
-e[] "- Use mouse button 1 to select matching points on the two images."
-e[] "- Use mouse button 2 to remove points in the list"
-e[] "- Press Space to re-init the list of points"
-e[] "- Close the window to finish\n"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1] -reverse
 0 0 (1,0,0;0,1,0;0,0,1) Z=0
  -do
    x1={*1,x} y1={*1,y}
    x2={*2,x} y2={*2,y}
    -if {$x1>=0}
      -if {{*1,b}&1} # if button 1 on window 1: add pts
        (1;{$x1/{*1,w}*{0,w}};{$y1/{*1,h}*{0,h}})
	-if {2,h>1} -a[2,-1] x -else -rm[2] -mv[-1] 2 -endif
      -else
        -if {{*1,b}&2} # if button 2 on window 1: rm pts
	  -if {2,w>1} -columns[2] 0,{2,w-2} -else -rm[2] 0 -mv[-1] 2 -endif
        -endif
      -endif
    -endif
    -if {$x2>=0}
      -if {{*2,b}&1}  # if button 1 on window 2: add pts
        (1;{$x2/{*2,w}*{1,w}};{$y2/{*2,h}*{1,h}})
	-if {3,h>1} -a[3,-1] x -else -rm[3] -mv[-1] 3 -endif
      -else
        -if {{*2,b}&2} # if button 2 on window 2: rm pts
          -if {3,w>1} -columns[3] 0,{3,w-2} -else -rm[3] 0 -mv[-1] 3 -endif
        -endif
      -endif
    -endif
    # if space bar is pressed : reinitialize
    -if {{*0,SPACE}" || "{*1,SPACE}" || "{*2,SPACE}} -rm[2,3,4] 0 0 (1,0,0;0,1,0;0,0,1) -endif
    -if {*1,o} Z={max(0,min({0,d}-1,$Z+{*1,o}))} -wait -1 -endif
    -if {*2,o} Z={max(0,min({0,d}-1,$Z+{*2,o}))} -wait -1 -endif
    -if {*3,o} Z={max(0,min({0,d}-1,$Z+{*3,o}))} -wait -1 -endif
    # number of paired points
    N={min({2,w},{3,w})}
    # if each list has at least one pts
    -if {{2,h}>1" && "{3,h}>1}
      -if {$N<=3} # translation
        -rm[4] --l[2,3]
          -rows 1,2 -columns 0,{$N-1} -- -s x -+ -/ $N
    	  (1,0,0;{-i(0,0)},1,0;{-i(0,1)},0,1) -rm[-2]
        -endl
      -else # affine
        -rm[4] --l[2,3] -columns 0,{$N-1} -solve_least_square[0] [1] -rm[1] -endl
      -endif
    -endif
    # Display first image
    --l[0,2]
      -if {{0,d}>1} -slices[0] $Z -endif
      -r[0] 200%,200%,1,1,5
      -r[0] 100%,100%,1,3,0 -grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
      -if {1,h>1} -rows[1] 1,2  -*[1] 2
      1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  -circles[0] [1]
      -labels[0] [1] -endif -w1[0] -1,-1,-1,-1,"First image (n="{1,w}")" -rm
    -endl
    # Display second image
    --l[1,3]
      -if {{0,d}>1} -slices[0] $Z -endif
      -r[0] 200%,200%,1,1,5
      -r[0] 100%,100%,1,3,0  -shift[0] 0,0,0,1 -grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
      -if {1,h>1} -rows[1] 1,2 -*[1] 2
      1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  -circles[0] [1]
      -labels[0] [1] -endif -w2[0] -1,-1,-1,-1,"Second image (n="{1,w}")" -rm
    -endl
    # warp image 1 and display merge
    --l[0,1,4]
      -if {{0,d}>1} -slices[0,1] $Z -endif
      -warp_affine[1] [2] -rm[2] -a c
      -r[0] 200%,200%,1,100%,5
      -grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
      -w3 -1,-1,-1,-1,"merge "$N" Z="$Z -rm
    -endl
  -wait
  -while {{*1}" && "!{*1,Q}" && "!{*1,ESC}" && "{*2}}
  -w1[] 0 -w2[] 0 -w3[] 0
  -k[-1]
-endl -done -v +

#@cli vobs : _scale
#@cli : Motion quantity (Normal motion)  h * (|Ixy|^2 |It|/|Ixy|) / h * Ixy^2
#@cli : Irani, Michal and Rousso, Benny and Peleg, Shmuel, Detecting and tracking multiple moving objects using temporal integration, ECCV'92.
#@cli : $ 100,100,10 -noise 1 -blur 1 --vobs
vobs : -check "${1=1}>0 && ${2=3}>0"
  -e[^-1] "Motion quantity with scale $1"
  -v - -repeat $! -l[$>]
    -gradient -a[0,1] c -norm[0] -abs[1] -*[1] [0] -sqr[0] -blur $1,1,1 -reverse -max[1] 5% -/
  -endl -done -v +

#@cli display_vobs
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 -noise .7,2 ==. 1 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_vobs
display_vobs :
  --vobs 1 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
  -resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
  -l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
  -l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1] 100%,{0,h},1,3,5 -a x
  -frame 5,12,64 -shift 0,5,0,0,2
  -text "Vobs ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
  -a x

#@cli display_pseudocolor : predefined_palette
#@cli : Display an indexed image in pseudocolors using a palette
#@cli : $ image.jpg -luminance -display_pseudocolor
display_pseudocolor : -skip ${1=5}
  -e[^-1] "Display an indexed image in pseudocolors using map "$1
  -v - -repeat $! -l[$>]
    A={round(im,0.0001)} B={round(iM,0.0001)}
    -n[-1] 0,255 -map[-1] $1
    -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
    -add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},$A,$B,6,255
  -endl -done -v +

#@cli display_colordepth : _dz
display_colordepth :
  -e[^-1] "display the 3D image with a depth color coded."
  -v - -repeat $! -l[$>]
    H={d*$1} -colordepth , -a z -min {ia+10*sqrt(iv)} -n 0,255 -s z
    -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
    -add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},0,$H,6,255
  -endl -done -v +

#@cli map_hilo
#@cli : Map a grascale image to a RGB with maw in red and min in blue
#@cli : This help to check if images are saturated
map_hilo:
-v - -repeat $! -l[$>]
  -round m={0,im} -- $m
  1,1,1,3,0,0,{0,iM} {0,iM-1},1,1,3,'x+1' 1,1,1,3,{0,iM},0,0 -a[1,2,3] x
  -map[0] [1]
  -+ $m -rm[1]
-endl -done -v +

#@cli add_colorbar : x0,y0,x1,y1,_min,_max,_ntics,color,colormap
#@cli : Add a colorbar
#@cli : $ image.jpg -luminance -map 5 -add_colorbar {w-40},20,{w-30},{h-20},0,255,6,255,5
add_colorbar : -skip ${5=0},${6=255},${7=6},${8=255},${9=""},${10=5}
  -e[^-1] "Add a colorbar"
  -v - -repeat $! -l[$>]
    {$3-$1},{$4-$2} -l[-1] -f 'h-y' -n 0,255 -map $10 -endl
    -frame[1] 1,1,$8 -image[0] [1],$1,$2,0,0,1 -k[0]
    -repeat $7
      val={round($5+$>/($7-1)*($6-$5),.001)}
       -text "- "$val" "$9,{$3+1},{$4-$>*($4-$2-5)/($7-1)-10},13,1,$8
    -done
  -endl -done -v -

#@cli local_diffusion_coefficient : _scale,_threshold
#@cli : Estimate local diffusion coefficient It - D (Ixx+Iyy)=0 using D=It/(Ixx+Iyy)
#@cli : $ 100,100 -noise .7,2 ==. 1 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -local_diffusion_coefficient 2,.5
local_diffusion_coefficient : -check "${1=2}>0 && ${2=.5}>=0"
-e[^-1] "Local diffusion coefficient estimation using scale $1 and threshold $2"
-v - -repeat $! -l[$>]
   --l[0] -s z -laplacian -a z -endl           # Ixx+Iyy
   --l[0] -s z -gradient_norm -a z -sqr -endl  # ||Ix+Iy||^2
   -gradient[0] z,1                            # It
   -l[0,1] # try to compute It/Ixx+Iyy as stably as possible
     R={1,ia+$2*sqrt(iv)}
     -a c -f 'b=i(x,y,z,0);a=i(x,y,z,1);if(abs(a)>abs(b),b/a,if(abs(b)>$R,1/(b/a),0))'
     -channels 0
   -endl
   -*[0] [1] -blur $1,1,1 -max[1] {1,ia+$2*sqrt(iv)}  -/
   -channels 0
-v + -endl -done

ldc :
-local_diffusion_coefficient $*

ldc_residuals :
--l[0] -s z -laplacian -a z -endl
-gradient[0] z,1
-*[1,2]
-- -abs -blur 1

#@cli display_ldc :
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 -noise .7,2 ==. 1 -blur 2,1,1 -repeat 20 --l[-1] --laplacian -*[-1] .05 -+ -endl -done  -a z -display_ldc
display_ldc :
--ldc 2,3 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 -apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z -frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 -a z -endl
-l[1] -s z -repeat $! -l[$>] 1,100% -f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 -frame[-1] 3,0,64  -resize[-1]
       100%,{0,h},1,3,5 -a x
-frame 5,12,64 -shift 0,5,0,0,2
-text "Local diffusion coefficient ["$A":"$B"]",5,0,13,1,255 -endl -done -a z -endl
-a x

#@cli print_psnr : _max_value
#@cli : Display the psnr on the image list taking the first one as a reference
#@cli : $ image.jpg --noise 20 --blur[-1] 1 -print_psnr
print_psnr : -skip ${1=255}
-e[^-1] "Compute PSNR with image 0 and print it on the other images."
-v - --psnr $1
-repeat {$!-2} -text_outline[{$>+1}] "PSNR:"{round(i(0,$>+1),.01)}"dB",5,5,30,1 -done
-rm[-1] -v +

#@cli noise_std
#@cli : Estimate the noise variance
#@cli : $ image.jpg -noise 10 sigma={round(${-noise_std},.1)} -text_outline "Noise std:"$sigma,5,5,30,1
noise_std :
-e[^-1] "Compute noise std."
-v - --laplacian -if {{0,d}==1}  -u {${-mad[-1]}/sqrt(20.0)} -else -u {${-mad[-1]}/sqrt(42.0)} -endif -rm[-1]
-v +

#@cli pca
#@cli : Principal component analysis
#@cli : $ image2.jpg --l -split_tiles 64,64 -y y -a x -pca -k[-1] -s x -r 8,8,1,1,-1 -n 0,255 -frame 1,1,255 -append_tiles , -r[-1] 400%,400% -frame 0,20 -title dictionary -endl
pca :
-e[^-1] "Principal component analysis"
-v - -repeat $! -l[$>]
  n={w} -- {ia} --transpose[-1] -m*[-2,-1] -/ $n -eigen
-endl -done -v +

spca: -skip ${2=20}
-v - -repeat $! -l[$>]
  -repeat $2
    p={sqrt(h)}
    --l --pca -k[0,-1]  -reverse -transpose[0] --m* -threshold[-1] $1,1 -rm[1] -transpose[0] -m* -endl
    -*[0] .25 -*[1] .75 -+
  -done
  -pca
-endl -done -v +

#@cli denoise_karmuen_loeve : _number_of_components
#@cli : Denoise with a bloc Karumen-Loeve transform
#@cli : http://en.wikipedia.org/wiki/Karhunen%E2%80%93Lo%C3%A8ve_theorem
#@cli : $ image2.jpg --noise 10 --denoise_karmuen_loeve[-1] 8 -print_psnr
denoise_karmuen_loeve:
  -v - -repeat $! -l[$>]
    -split_tiles 64,64 oW={0,w} oH={0,h} oS={0,s}
    -y y -a x --pca -k[0,-1] -reverse -crop[0] 0,$1
    -transpose[0] --m* -rm[1] -transpose[0] -m* -s x
    -resize $oW,$oH,1,$oS,-1 -append_tiles ,
  -endl -done -v +

#@cli denoise_patch_dict : _patch_size,_nb_of_shifts,_thres_comp,_thres_coef
#@cli : Denoising using a dictionnary of patches learned on the image
#@cli : $ image.jpg --noise 10 --denoise_patch_dict[1] , -print_psnr
denoise_patch_dict: -skip ${1=8},${2=8},${3=1.1},${4=1.1}
-e[^-1] "Denoising using a dictionnary of "$1"x"$1" patches with "$2" shifts, threshold $3x(noise std) for components and $4x(std) for coefficients."
-v - -repeat $! -l[$>]
  Sigma=${-noise_std[0]} # measure the noise level
  # mirror to prevent side effect
  --crop 0,0,$1,100% -mirror[-1] x -reverse --crop[-1] {w-$1-1},0,100%,100% -mirror[-1] x -a x
  --crop 0,0,100%,$1 -mirror[-1] y -reverse --crop[-1] 0,{h-$1-1},100%,100% -mirror[-1] y -a y
  # resize the image to get integer nb of tiles (using mirrored version)
  oW={0,w} oH={0,h} oS={0,s} nW={$1*round($oW/$1,1,1)} nH={$1*round($oH/$1,1,1)}
  --crop {2*$oW-$nW},0,100%,100% -mirror[-1] x -a x
  --crop 0,{2*$oH-$nH},100%,100% -mirror[-1] y -a y
  NtileX={round($nW/$1)}  NtileY={round($nH/$1)}
  # compute a dictionnary (use several shifts)
  --l[-1]
    -repeat $2
      -if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} -else dx=0 dy=0 -endif
      --shift[0] $dx,$dy,0,0,2
      -split_tiles[-1] $NtileX,$NtileY pW={1,w} pH={1,h} # split the image
    -done -rm[0]
    -y y -a x n={w} -- 'ia' --transpose[-1] -m*[-2,-1] -/ $n -eigen # PCA
    # select components based on noise level
    -l[-2] -unroll x -sqrt -gt {$3*$Sigma} -f 'abs(i(x+1)-i(x))'
    T={[xM,yM,zM,cM]} 4 -f[-1] $T T={i(0)} -endl
    -if {$T==0} T=100% -endif -k[-1] -columns 0,$T
  -endl
  # denoise the image using the dictionnary
  -repeat $2
    -if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} -else dx=0 dy=0 -endif
    --shift[0] $dx,$dy,0,0,2
    -l[1,-1]
      -l[1] -split_tiles $NtileX,$NtileY -unroll y -a x -endl
      -transpose[0] --m*                # project on the dictionnary
      t=${-mad[-1]}                     # estimate variance of coefficients
      -f[-1] 'if(abs(i)<$4*$t,0,i)'     # threshold the coefficients
      -rm[1] -transpose[0] --m* -rm[-2] # project back
    -endl
    -l[-1]
       -s x -resize $pW,$pH,1,$oS,-1
       -append_tiles $NtileX,$NtileY
       -shift {-$dx},{-$dy},0,0,2
     -endl
  -done
  -rm[0,1]
  -+ -/ $2
  -crop {$1+1},{$1+1},{$oW-$1-2},{$oH-$1-2}
-endl -done -v +

std_noise :
  -v - --laplacian[-1] -u {${-mad[-1]}/sqrt(if(d==1,20,42))} -rm[-1] -v +

#@cli iuwt : _nlevels>2,_spline>1
#@cli : Compute the "isotropic undecimated wavelet transform" using
#@cli : a trou algorithm for the B3-Spline wavelet.
#@cli : The inverse is obtained as the sum of all coefficients
#@cli : $ image.jpg -iuwt 4,1 -n 0,255 -append_tiles
#@cli : $ image.jpg -iuwt 3,1 -+
iuwt: -skip ${1=3},${2=3}
  -e[^-1] "Compute isotropic undecimated wavelet transform"
  -v - -repeat $! -l[$<]
  # Compute the Spline filter by succesive convolutions
  50
  -l[-1]
    -f 'if(x==w/2|x==w/2-1,1,0)' -i [0]
    -repeat $2 -convolve[-1] [0] -done
    -k[-1] -autocrop 0 -/ {ia*w}
  -endl
  # Compute the decomposition
   -repeat {$1-1}
     -l[-1,-2]
      --convolve[0] [1]
      -y[1] y -convolve[-1] [1]
      ---[0] [-1] -rm[0] -reverse
     -endl
     # add trou for the next scale
     -l[-1] -y y 100% -a x -s y -s x -rm[-1] -a x -endl
    -done
    -rm[-1] -reverse
  -endl -done -v +

#@cli iuwt_std : _nlevels>2,_spline>1
#@cli : Compute noise at each level of the iuwt
#@cli : $ image.jpg -iuwt_std 10,10
iuwt_std:
 -v - -repeat $! -l[$>]
   sigma=${-noise_std}
   -if 1 # experimental measure
     -f 1 -noise $sigma -iuwt $1,$2
     -repeat $! -l[$>]
        x={sqrt(iv)} -rm 1 -f $x
     -endl -done -a x
   -else -rm # try a theoritical formula (failed)
   50
   -l[-1]
   -f 'if(x==w/2|x==w/2-1,1,0)' -i [0]
   -repeat $2 -convolve[-1] [0] -done
   -k[-1] -autocrop 0 -/ {ia*w}
   -endl
   -sqr
   alpha={is} -rm
   $1,1,1,1,'$sigma*sqrt((1+$alpha)*$alpha^(w-x-1))'
   -endif
 -endl -done -v +

#@cli denoise_iuwt:_threshold>0,_nlevels>2,_spline>1
#@cli : Denoising by thresholding the coefficients of the
#@cli : "isotropic undecimated wavelet transform"
#@cli : $ image.jpg --noise 10 --denoise_iuwt[-1] , -print_psnr
denoise_iuwt: -check "${1=1.4}>0&&${2=4}>1&&${3=1}>0"
  -e[^-1] "Denoise using the isotropic undecimated B"$3" spline wavelet transform"
  -v - -repeat $! -l[$>]
    # Compute noise std at each level
    --iuwt_std[0] $2,$3 -reverse
    # compute the wavelet coefficient and threshold them
    -iuwt[-1] $2,$3
    -repeat {$!-2} -threshold[{$>+2}] {0,$1*i($>+1)},1 -done
    # reconstruct
    -+[1--1]
    -rm[0]
  -endl -done  -v +

#@cli noise_poisson_gaussian : gain,offset,noise_std
camera_noise:
-v - -repeat $! -l[$>]
 -noise 0,3 -* $1 -+ $2 -noise $3
-endl -done -v +

#@cli analyze_camera_noise :
analyze_camera_noise:
 -v - -repeat $! -l[$>]
   --local_noise_variance $1 -blur[0] $1 -y -a c
   -display_parametric 800,600,.0,1,1,0,signal,noise
 -endl -done -v +

#@cli dehaze : scale,gamma1,min_va,max_val,gamma2
#@cli : Dehaze an image using Dark Channel Prior appraoch
#@cli : return the dehazed image and a transmittance image
#@cli : $ http://media.lcpc.fr/ext/img/prod/frida/K080-000000.jpg -r 600,400,1,3,5 --dehaze
dehaze: -skip ${1=5},${2=1},${3=.2},${4=1},${5=0},${6=0},${7=0}
  -v - -repeat $! -l[$>]
   # Atmospheric light estimation
  --l
    --l -s c -min -blur 10 -erode_circ $1 -dilate_circ $1  -endl
    -gt[-1] 80% -*
    -s c aR={0,iM} aG={1,iM} aB={2,iM} -rm
  -endl
   # transmitance map estimation
   --l
    -s c -/[0] $aR -/[1] $aG -/[2] $aB
    -repeat 10 -median 3 -erode_circ $1 -dilate_circ $1 -done
    -min -f 'max($3,min($4,1-0.95*i))'
    -endl
   # correction
   -pow[1] $2
   -s[0] c --[0] $aR --[1] $aG --[2] $aB
   -/[0-2] [3]
   -+[0] $aR -+[1] $aG -+[2] $aB -a[0-2] c
   -c[0] 0,255
   -adjust_colors[0] $5,$6,$7
  -endl -done -v +

#---------------------------------
#
#@cli :: Segmentation
#
#---------------------------------

#@cli contour2d: _tolerance
#@cli : Draw a 2D contour of regions with tolerance _tolerance
#@cli : Default value _tolerance=.1
#@cli : $ image.jpg -norm -blur 1 -gt 50% --contour2d
contour2d: -skip ${1=.1}
-v - -f 'if(abs(i-j(1,1))>$1||abs(i-j(1,0))>$1,1,0)' -v +

#@cli segment_snake : _nb_iter,_time_step,_lambda,_threshold,_smoothness
#@cli : Segment an image using an adaptation of Chan and Vese's method.
#@cli : Default values _nb_iter=10,_time_step=1,_smoothness=100,_threshold=50%
#@cli : Reference Chan and L. Vese,Active contours without edges, IEEE transactions on image processing 10(2) (2001), pp. 266-277
#@cli : $ 256,128 -text "GMIC",40,10,100,1,255 -blur 1 -noise 20 --segment_snake , -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_snake: -skip ${1=100},${2=1},${3=.1},${4=.1},${5=10},${6=0}
-e[^-1] "Segment the image using active contours without edges using $1 iterations and time step $2, smoothness $3 and initialize with threshold of $4."
-v - -repeat $! -l[$>]
  -if {s>1} -luminance -endif
  --blur $5 -gt[-1] {ia+$4*sqrt(iv)}                                # initialization
  -l[-1] --distance 0 -negate[0] -distance[0] 0 -*[0] -1 -+ -endl # levelset
  -repeat $1
    # compute mean and variance of the two regions (original version is with mean only)
    # the molified step function is given by a blur of the sharp step function
    --lt[-1] 0 -blur[-1] 1 --*[0,-1] swx={ia} sw={-2,ia} M1={$swx/$sw}
    -sqr[-1] swx2={ia}  S1={max(1e-3,$swx2/$sw^2-$M1^2)} -rm[-1,-2]
    --gt[-1] 0 -blur[-1] 1 --*[0,-1] swx={ia} sw={-2,ia} M2={$swx/$sw}
    -sqr[-1] swx2={ia}  S2={max(1e-3,$swx2/$sw^2-$M2^2)} -rm[-1,-2]
    --iee[-1]                                                     # regularization
    --f[0] '(1.0/$3)*(((i(x,y)-$M1)^2)/$S1-((i(x,y)-$M2)^2)/$S2)' # data term
    -+[-2,-1]
    -*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}           # adaptive time step
    -+[-2,-1]
    -if {$6==1} # if display
    --l -gt[1] 0 -contour2d[1] , -n 0,1 -a c -text $>,0,0,13,1,{iM} -w -wait 10  -rm -endl
    -endif
    #-if {$>%10} -l[-1] -gt 0 --distance 0 -negate[0] -distance[0] 0 -*[0] -1 -+ -endl -endif
  -done
#  -echo_stdout "("$M1","{sqrt($S1)}");("$M2", "{sqrt($S2)}")"
  -blur[-1] 1 -gt[-1] 0 -rm[0]
-endl -done -v +

#@cli segment_cells: scale1,scale2,threshold,size_threshold
#@cli : Cell segmentation using watershed
#@cli : $ 256,256 -noise .05,2 ==. 1 -blur 10,1,1 -min 80% -noise 5% --segment_cells 2,10% -contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 -blend add
segment_cells: -skip ${1=3},${2=10},${3=1},${4=3}
  -e[^-1] "Cell segmentation using difference of Gaussians and watershed"
  -v - -repeat $! -l[$>]
    -blur $1 --blur $2 -- --gt {ia+$3*${-mad}} -area_fg 0 -gt $4 --distance[1] 0
    -max_patch[0] {round($4,1,1)} -*[0] [1] -label[0] 0 -watershed[0] [2] -rm[-1] -*
    -endl -done -v +

#@cli zernike:

zernike:
-skip  ${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=0},${12=0},${13=0},${14=0},${15=0},${16=0},${17=0},${18=0}
f 'r=sqrt((x-$1)^2+(y-$2)^2);if(r<$3,a=atan2(y-$2,x-$1);$4+$5*2*r*sin(a)+$6*r*cos(a)+$7*sqrt(6)*r^2*sin(2*a)+$8*sqrt(3)*(2*r^2-1)+$9*sqrt(6)*r^2*cos(2*a)+$10*sqrt(8)*r^3*sin(3*a)+$11*sqrt(8)*(3*r^3-2*r)*sin(a)+$12*sqrt(8)*(3*r^3-2*r)*cos(a)+$13*sqrt(8)*r^3*cos(3*a)+$14*sqrt(10)*r^4*sin(4*a)+$15*sqrt(10)*(4*r^4-3*r^2)*sin(2*a)+$16*sqrt(5)*(6*r^4-3*r^2)*cos(2*a)+$17*sqrt(10)*(4*r^4-3*r^2)*cos(2*a)+$18*sqrt(10)*r^4*cos(4*a),0)'

#---------------------------------
#
#@cli :: Patterns
#
#---------------------------------

_challenge:
108,86,1,3 -l[-1] -fractional_brownian_motion .25  -n 0,128 --norm -gt[-1] 60% -* -resize 1080,860,1,3,1  --l[-1] -blur 10 -shift[-1] 10,10 -endl -max -crop 10,10,100%,100% -negate -endl -n 0,255

#@cli periodic_dots : _nb_angles,_scale,_start_angle
#@cli : Generate a peridic dot pattern with 'nb angles', 'scale' and 'start angle'.
#@cli : Default values 'nb angle=6', 'scale=4' and 'start_angle=0'
#@cli : $ 64,64 -periodic_dots 3,6,.1 -repeat 34 -i [0] -done -append_tiles
periodic_dots : -skip ${1=6},${2=4},${3=.5}
-e[^-1] "Generate a periodic dot pattern with "$1" angles, scale "$2", and orientation "$3"."
-v - -repeat $! -l[$>]
 -s c -repeat $! -l[$>]
 --resize {max(w,h)},{max(w,h)},100%,100%,0
 -l[-1]
 -f 0
 -repeat $1
   -circle {w*(.5+.5/$2*cos(2*pi*($>+$3/180*pi)/$1))},{w*(.5+.5/$2*sin(2*pi*($>+$3/180*pi)/$1))},0,1,255
 -done
 -fft -a c -norm -fftshift -n 0,255
 -endl
 -resize[-1] [0],0
 -k[-1]
 -endl -done -a c
-endl -done -v +

#@cli turing_pattern : iter,dt,a,b,q,r,D
#@cli : Generate Turing pattern using a rection-diffusion equation
#@cli : du/dt = au(1-qv²) + v(1-ru)
#@cli : dv/dt =  v(b-aquv) + u(-a+rv)
#@cli : the two parameters q and r are dictating the pattern final shape
#@cli : the diffusivity parameter influcences the scale
#@cli : http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf
#@cli : http://eprints.maths.ox.ac.uk/430/1/102.pdf
turing_pattern: -skip ${1=2000},${2=.1},${3=0.855},${4=-0.95},${5=2},${6=.1},${7=.5},${8=0}
  -v - -repeat $! -l[$>]
    -r 100%,100%,100%,2 -blur 1 -n 0,1
    -repeat $1
      -progress {$>/$1*100}
      --laplacian[0] -mix_channels[-1] ($7,0;0,1)
      --f[0] 'u=i(x,y,z,0);v=i(x,y,z,1);a=$3;b=$4;q=$5;r=$6;if(c==0,a*u*(1-q*v*v)+v*(1-r*u),v*(b+a*q*u*v)+u*(-a+r*v))'
      -+[-1,-2]
      -*[-1] {$2/(1+max(abs(im),abs(iM)))}
      -+
      -if {$8==1} --l -s c -n 0,1 -a c -text $> -w -rm -endl -endif
    -done
    -s c -n 0,1 -a c
  -endl -done -v +

#@cli rays : _center_x,_center_y,_scale,_phase
#@cli : Generate rays patterns
#@cli : $ image.jpg --rays 155,127,10,10 -n[-1] 0,1 -mul
rays :
  -e[^-1] "Generate a ray pattern centered in ($1,$2)"
  -f 't=atan2(y-$2,x-$1);sin($3*t+$4)'

#@cli fractional_brownian_motion : 0<=_hurst_index<=1,_epsilon>0
#@cli : Generate fractional brownian motion nd signal
#@cli : Using a power low of the form (eps+|f|)^(-2^H-1)
#@cli : where f is the module of the frequency, H the husrt index and eps _epsilon.
#@cli : (see also -clouds)
#@cli : $ 400,300 -fractional_brownian_motion
fractional_brownian_motion : -skip ${1=.5},${2=1} -check "$1>=0&&$1<=1" -check "$2>0"
  -e[^-1] "Generate pseudo fractional brownian motion"
  -v - -repeat $! -l[$>]
    -f 0 -noise 1
    -fft -fftshift
    -if {{0,d}==1}
      -f 'rx=x-w/2;ry=y-h/2;i*($2+sqrt(rx*rx+ry*ry))^(-2*$1-1)'
    -else
      -f 'rx=x-w/2;ry=y-h/2;rz=z-d/2;i*($2+sqrt(rx*rx+ry*ry+rz*rz))^(-2*$1-1)'
    -endif
    -fftshift -ifft
    -k[0]
  -endl -done -v +

#@cli clouds : _density_of_blue_sky>0,_amplitude,0<=_hurst_index<=1,_epsilon>0
#@cli : Generate clouds on the image (see also 'frational_brownian_motion')
#@cli : $ 64,64 -repeat 3 --clouds {10+20*$>}% -done -rm[0]
clouds : -skip ${1=50%},${2=1},${3=.5},${4=1}
  -e[^-1] "Generate a cloud"
  -v - -repeat $! -l[$>]
    -channels 0
    -fractional_brownian_motion $3,$4 -negate -min $1 -negate -resize 100%,100%,1,4
    -n 0,255 -s c -n[0-2] 190,255  -n[3] 0,255 -a c
  -endl -done -v +

#@cli clearbluesky:
#@cli : Generate a Clear Blue Sky
#@cli : $ 400,300,1,3 -clearbluesky --clouds 50% -blend alpha
clearbluesky :
  -e[^-1] "Generate a blue sky"
  -v - -repeat $! -l[$>]
    1,2,1,3 -f[-1] '63,70,120,144,190,215' -resize[-1] [0],5 -k[-1]
    -endl -done -v +

#@cli mm_mozaic: size
#@cli : Create a mozaic image from the selected image
#@cli : -sp ? -mm_mozaic
mm_mozaic: -skip ${1=1}
  -repeat $! -l[$>]
  --gradient_norm -negate.
  --l. -b. .75 --ge $1 -max_patch.. 3 -d -* -endl -to_rgb. -*[0,2] -d
  -watershed.. . -rm.
  -endl -done

segment_watershed2 : -check "${1=2}>=0"
  -e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
  -v - -repeat $! -l[$>]
    min={im}
    -+ {1+$min} --gradient_norm
    -if {d>1} --f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && i<j(0,0,1) && i<j(0,0,-1),1,0)"
    -else --f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
    -endif
    -*[-3,-1] -*. -1 -watershed.. . -rm.
    -- {1+$min}
    -endl -done -v +

#@cli freqy_pattern
#@cli : Create a periodic pattern containing a lot of frequencies
#@cli : sp ? freqy_pattern
freqy_pattern: -skip ${1=0.33},${2=100}
  e[^-1] "Generate a periodic pattern with many frequencies."
  -v - -repeat $! -l[$>]
    fftpolar
    --l[0] -f 0 -repeat {s} -set 1,50%,50%,50%,$> done -blur $1,0,1 -endl
    -*[0] [-1] rm.
    ifftpolar
    n 0,{$2*pi} sin
  -endl -done -v +

#---------------------------------
#
#@cli ::  Colors
#
#---------------------------------
#@cli wavelength_color: _wavelength
#@cli : Convert a wavelength [380,780] to RGB color
#@cli : from http://scienceprimer.com
#@cli : $ 1,1,1,1,1 -repeat 100 --wavelength_color[0] {380+3*$>} -done -rm[0] -a x
wavelength_color:
-v -
-if {$1>=380&$1<440}
  R={-1*($1-440)/(440-380)}
  G=0
  B=1
-elif {$1>=440&$1<490}
  R=0
  G={($1-440)/(490-440)}
  B=1
-elif {$1>=490&$1<510}
  R=0
  G=1
  B={-1*($1-510)/(510-490)}
-elif {$1>=510&$1<580}
  R={($1-510)/(580-510)}
  G=1
  B=0
-elif {$1>=580&$1<645}
  R=1
  G={-1*($1-645)/(645-580)}
  B=0
-elif {$1>=645&$1<780}
  R=1
  G=0
  B=0
-else
  R=0
  G=0
  B=0
-endif
-repeat $! -l[$>]
-mix_channels ($R;$G;$B)
-endl -done

#---------------------------------
#
#@cli ::  GIMP
#
#---------------------------------
#@gui _<b>Details</b>

#@gui Sharpen [Whiten] : jeje_whiten_frequency, jeje_whiten_frequency_preview(0)
#@gui : Alpha = float(50,0,100)
#@gui : Cut = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter equalizes frequencies in the image.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/06/01</i>.</small>")
jeje_whiten_frequency :
  -repeat $! -l[$>] -split_opacity -l[0]
    -whiten_frequency {exp($1/100)-1}
    -if $2 -c 0,255 -n 0,255 -else -n 0,255 -endif
  -endl -a c -endl -done

jeje_whiten_frequency_preview :
  -gui_split_preview "-jeje_whiten_frequency $1,$2",$-1

#@gui _<b>Repair</b>
#@gui Smooth [Block PCA]: jeje_denoise_patch_dict, jeje_denoise_patch_dict_preview(0)
#@gui : Patch = choice(1,4,8,16,32)
#@gui : Cycles = int(8,1,32)
#@gui : Components = float(1.1,1,9)
#@gui : Coefficients = float(1.1,0,9)
#@gui : Remix = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter is quite time consuming.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
jeje_denoise_patch_dict:
  --denoise_patch_dict {2^($1+2)},$2,$3,$4
  -*[0] $5 -*[1] {1-$5} -+ -c 0,255

jeje_denoise_patch_dict_preview :
  -gui_split_preview "-jeje_denoise_patch_dict ${1--2}",$-1

#@gui Smooth [Wiener] : jeje_local_wiener, jeje_local_wiener_preview(0)
#@gui : Scale = float(2,.5,10)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Value action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_local_wiener :
-ac "-local_wiener $1",$2,$3

jeje_local_wiener_preview:
-gui_split_preview "-jeje_local_wiener $*",$-1

#@gui Smooth [IUWT] : jeje_denoise_iuwt,jeje_denoise_iuwt_preview(0)
#@gui : Threshold = float(3,0,10)
#@gui : Number of scales = int(4,2,6)
#@gui : Wavelet = choice(2,"Spline B1","Spline B2","Spline B3","Spline B4","Spline B5","Spline B6")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small><b>Note:</b>Denoise the image by thresholding the coefficient of the Isotropic Undecimated Wavelet Transform.</small>")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/17/12</i>.</small>")
jeje_denoise_iuwt :
-denoise_iuwt $1,$2,{$3+1}

jeje_denoise_iuwt_preview:
-gui_split_preview "-jeje_denoise_iuwt $1,$2,$3",$-1

#@gui Unstrip : jeje_unstrip, jeje_unstrip_preview(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Size = float(20,1,50)
#@gui : Sensitivity = float(4,1,10)
#@gui : Normalize = bool(true)
#@gui : FFT preview = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/10</i>.</small>")
jeje_unstrip :
  -unstrip $1,$2,$3
  -if $5 -tape -powerspectrum -else
  -if -$4 -n 0,255 -else -c 0,255 -endif
  -endif

jeje_unstrip_preview :
  -gui_split_preview "-jeje_unstrip $1,$2,$3,$4,$5",$-1

#@gui Repair scanned document: jeje_scandoc, jeje_scandoc_preview(0)
#@gui : note = note(Use filter is useful to post process document you scan with a digital camera. It peforms smoothing, background correction and white balance adjustement)
#@gui : Smoothness = int(3,1,7)
#@gui : Background = float(1,10,100)
#@gui : White level = float(90,0,100)
#@gui : Black level = float(5,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/11/03</i>.</small>")
jeje_scandoc :
  -scandoc $1,$2%,$3%,$4%

jeje_scandoc_preview :
  -gui_split_preview "-jeje_scandoc $1,$2,$3,$4",$-1

#@gui _<b>Patterns</b>
#@gui Periodic dots: jeje_periodic_dots, jeje_periodic_dots_preview
#@gui : Number = int(6,2,32)
#@gui : Scale = float(4,1,12)
#@gui : Angle = float(0,0,360)
#@gui : Repeat = int(1,1,10)
#@gui : Map = choice(None,default,HSV,lines,hot,cool,jet,flag,cube)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_periodic_dots:
  tW={max(w,h)/$4}
  $tW,$tW
  -periodic_dots[-1] $*
  -repeat {$4*$4-1}
   -i [-1]
  -done
  -append_tiles[1--1] $4,$4 -k[-1]
  -if {$5>0} -n 0,255 -map {$5-1} -endif

jeje_periodic_dots_preview:
  -jeje_periodic_dots $*

#@gui Turing : jeje_turing_pattern,gui_no_preview
#@gui : Scale = float(1,0,1)
#@gui : Iterations = int(2000,1,10000)
#@gui : Time step = float(.1,.01,1)
#@gui : alpha = float(.899,0,2)
#@gui : beta = float(-.91,-2,2)
#@gui : q = float(2,0,3)
#@gui : r = float(.1,0,3)
#@gui : Diffusivity = float(.25,.01,.6)
#@gui : sep = separator(), note = note(<small>Generate turing pattern using a system of coupled reaction/diffusion equations. The patterns can change from line to spots like structures depending on the parameters. You may use the 'Stencil' filter to achieve similar effects. http://en.wikipedia.org/wiki/The_Chemical_Basis_of_Morphogenesis</small>), note=note(<small>Since the computation is long there is no preview. </small>)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/01/16</i>.</small>")
jeje_turing_pattern:
  --l
    -r {$1*w},{$1*h},1,2
    -turing_pattern $2,$3,$4,$5,$6,$7,$8
  -endl
  -r[1] 100%,100%,100%,3,0 -r[1] [0],[0],1,100%,5 -rm[0] -blur .75 -n 0,255

#@gui Clouds : jeje_clouds, jeje_clouds_preview
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(.5,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_clouds :
 --clouds $1%,1,$2 -blend alpha

jeje_clouds_preview :
 -jeje_clouds $1,$2

#@gui Strip : jeje_strip, jeje_strip_preview
#@gui : Angle = float(45,0,90)
#@gui : Frequency = float(50,0,100)
#@gui : Phase =  float(0,0,180)
#@gui : Amplitude = float(1,0,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_strip :
  theta={pi*$1/180}
  -f '0.5*i*(1+$4*sin(2*pi*$2*(cos($theta)*x/w+sin($theta)*y/h)+2*pi*$3/180))'
  -c 0,255

jeje_strip_preview :
  -gui_split_preview "-jeje_strip $*",$-1

#@gui Rays : jeje_rays, jeje_rays_preview
#@gui : X center = float(50,0,100)
#@gui : Y center = float(50,0,100)
#@gui : Frequency = float(10,0,100)
#@gui : Angle = float(0,0,360)
#@gui : Proportion = float(0.5,0,1)
#@gui : Color 1 = color(255,0,0)
#@gui : Color 2 = color(255,255,0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/29</i>.</small>")
jeje_rays :
  -s c
  -l[0] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $6,$9 -endl
  -l[1] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $7,$10 -endl
  -l[2] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 -gt $5 -n $8,$11 -endl
  -a c

jeje_rays_preview:
  -gui_split_preview "-jeje_rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11",$-1

#@gui Fibers: jeje_fibers, jeje_fibers_preview
#@gui : Number = int(10,1,100)
#@gui : Length = int(50,1,100)
#@gui : Smoothness = float(10,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/07/17</i>.</small>")
jeje_fibers :
  100%,100%,1,1,0
  -l[-1]
    -fibers $1,$2%,$3
    -gt 0
    -n 0,255
  -endl
  -r[-1] [0]
  -max

jeje_fibers_preview :
-gui_split_preview "-jeje_fibers $1,$2,$3",$-1

#@gui Freqy pattern: jeje_freqy_pattern, jeje_freqy_pattern_preview
#@gui : Random = float(50,0,100)
#@gui : Scale 1 = float(33,1,100)
#@gui : Scale 2 = float(50,1,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/09/25</i>.</small>")
jeje_freqy_pattern:
  noise {$1*4}
  freqy_pattern {25/$2}%,{$3*2} n 0,255

jeje_freqy_pattern_preview:
  gui_split_preview "jeje_freqy_pattern $1,$2,$3",$4

#@gui _<b>Details</b>
#@gui Local variance normalization : jeje_normalize_local_variance, jeje_normalize_local_variance_preview
#@gui : Amplitude = float(50,0,100)
#@gui : Smoothness = float(5,0,20)
#@gui : Threshold = float(5,0,100)
#@gui : Repeat = int (1,1,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/30</i>.</small>")
jeje_normalize_local_variance :
  -apply_channels "-normalize_local_variance $1,$2,$3,$4",$5,0
  -c 0,255

jeje_normalize_local_variance_preview:
-gui_split_preview "-jeje_normalize_local_variance $1,$2,$3,$4,$5",$-1

#@gui DCP Dehaze : jeje_dehaze,jeje_dehaze_preview
#@gui : Scale = int(5,1,20)
#@gui : Strength = float(1,0,2)
#@gui : Min = float(.2,0,1)
#@gui : Max = float(1,0,1)
#@gui : Brighness = float(0,-100,100)
#@gui : Contrast = float(0,-100,100)
#@gui : Gamma = float(0,-100,100)
#@gui : Transmittance map = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Dark Channel Prior dehazing.Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/08/09</i>.</small>")
jeje_dehaze:
  -apply_channels "-dehaze {2*$1+1},$2,$3,$4,$5,$6,$7 -if $8 -k[1] -n 0,255 -to_rgb -else -k[0] -endif",rgb,1

jeje_dehaze_preview:
  -gui_split_preview "-jeje_dehaze $1,$2,$3,$4,$5,$6,$7,$8",$9

#@gui Spotify : jeje_spotify,jeje_spotify_preview
#@gui : Scale = float(1,0.75,10)
#@gui : Iteration = int(1,1,50)
#@gui : Gamma = float(1,0,10)
#@gui : Cut = bool(1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/16</i>.</small>")
jeje_spotify:
  -apply_channels "-spotify $1,$2  -apply_gamma $3 -if $4 -c 0,255 -else -n 0,255 -endif",$5

jeje_spotify_preview:
  -gui_split_preview "-jeje_spotify $1,$2,$3,$4,$5",$6

#@gui _<b>Testing</b>
#@gui <i>J&#233;J&#233;</i>
#@gui 3D Rendering: jeje_render3d, jeje_render3d_preview
#@gui : Input image = file()
#@gui : Size = int(8,4,16)
#@gui : Quality = int(6,2,16)
#@gui : Opacity = float(0.1,0,1)
#@gui : Angle X = float(240,0,360)
#@gui : Angle Y = float(0,0,360)
#@gui : Angle Z = float(30,0,360)
#@gui : Zoom = float(1,0,3)
#@gui : Top color = color(32,32,64,255)
#@gui : Bottom Color = color(64,128,96,255)
#@gui : Render = bool(false)
#@gui : sep = separator(), note = note(<b>Note:</b>Adjust the 3D view first and then enable render to compute the volume rendering.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_render3d:
  W={0,w}
  1,2,1,4 -f[-1] $9,$13,$10,$14,$11,$15,$12,$16 -resize[-1] {0,w},{0,h},1,4,5
  -blend alpha
  -i "$1" -a[1--1] z
  -l[-1]
  -if $17 -display_volume $2,$3,$4 -else  -boundingbox3d 20 -endif
  -rotate3d 0,0,1,$7
  -rotate3d 0,1,0,$6
  -rotate3d 1,0,0,$5
  -c3d -n3d -*3d {3*$W*$8/4}
  -endl
  -object3d[0] [1],50%,50%,0,1
  -n 0,255
  -rm[1]

jeje_render3d_preview:
    -jeje_render3d $"*"

#@gui Deconvolve: jeje_deconvolve, jeje_deconvolve_preview
#@gui : Iterations = int(20,1,100)
#@gui : Algorithm = choice(0,"Richardson-Lucy","Gold-Meinel")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note{"Need two layers (top layer is the blur)<br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/22/02</i>.</small>"}
jeje_deconvolve:
  -if {$2==1}
    -deconvolve_goldmeinel[0] [1],$1 -n[0] 0,255
  -else
    -deconvolve_richardsonlucy[0] [1],$1 -n[0] 0,255
  -endif

jeje_deconvolve_preview:
  -gui_split_preview "-jeje_deconvolve $1,$2,$3",$4


#@gui zernike: jeje_zernike_preview
#@gui : X = float(50,0,100)
#@gui : Y = float(50,0,100)
#@gui : R = float(50,0,100)
#@gui : Piston = float(0,-1,1)
#@gui : Horizontal tilt = float(0,-1,1)
#@gui : Vertical tilt = float(0,-1,1)
#@gui : Oblique astigmatism = float(0,-1,1)
#@gui : Defocus = float(0,-1,1)
#@gui : Vertical astigmatism = float(0,-1,1)
#@gui : Vertical trefoil = float(0,-1,1)
#@gui : Vertical coma = float(0,-1,1)
#@gui : Horizontal coma = float(0,-1,1)
#@gui : Oblique trefoil = float(0,-1,1)
#@gui : Oblique quadrafoil = float(0,-1,1)
#@gui : Oblique secondary astigmatism = float(0,-1,1)
#@gui : Primary spherical = float(0,-1,1)
#@gui : Vertical secondary astigmatism = float(0,-1,1)
#@gui : Vertical quadrafoil = float(0,-1,1)
#@gui : Binarize  = bool(false)
#@gui : Period = float(0,0,256)
#@gui : Cycle ratio = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note{"https://en.wikipedia.org/wiki/Zernike_polynomials <br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/03/12</i>.</small>"}
jeje_zernike:
  zernike {$1*w/100},{$2*h/100},{$3*w/100},${4-18}
  n 0,255
  if $19 f '100*((i/$20)%1)<$21' n 0,255 endif

jeje_zernike_preview:
 gui_split_preview "-jeje_zernike $*",$-1




# Local Variables:
# mode: sh
# time-stamp-pattern: "Lastest update: <i>%02y/%02m/%02d</i>"
# End:
#
# (End of G'MIC custom commands)
